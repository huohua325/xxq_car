# è½¯ä»¶ç»„å·¥ä½œæ€»ç»“ - ä¸»æœºç«¯Pythonæ§åˆ¶ç³»ç»Ÿ

## ğŸ“‹ ç›®å½•

- [1. é¡¹ç›®æ¦‚è¿°](#1-é¡¹ç›®æ¦‚è¿°)
- [2. æŠ€æœ¯æ ˆè¯„ä¼°ä¸é€‰å‹](#2-æŠ€æœ¯æ ˆè¯„ä¼°ä¸é€‰å‹)
- [3. é€šä¿¡åè®®è§„èŒƒ](#3-é€šä¿¡åè®®è§„èŒƒ)
- [4. æ ¸å¿ƒåŠŸèƒ½æ¨¡å—](#4-æ ¸å¿ƒåŠŸèƒ½æ¨¡å—)
- [5. å…·ä½“å®ç°ä»£ç ](#5-å…·ä½“å®ç°ä»£ç )
- [6. å¼€å‘ä»»åŠ¡æ¸…å•](#6-å¼€å‘ä»»åŠ¡æ¸…å•)
- [7. æµ‹è¯•ä¸è°ƒè¯•](#7-æµ‹è¯•ä¸è°ƒè¯•)

---

## 1. é¡¹ç›®æ¦‚è¿°

è½¯ä»¶ç»„è´Ÿè´£å¼€å‘åŸºäºPythonçš„ä¸»æœºç«¯æ§åˆ¶ç³»ç»Ÿï¼Œä½œä¸ºæ™ºèƒ½å°è½¦çš„é«˜çº§å†³ç­–ä¸­æ¢ã€‚è¯¥ç³»ç»Ÿæ¥æ”¶æ¥è‡ªSTM32å›ºä»¶çš„ä¼ æ„Ÿå™¨æ•°æ®ï¼ˆ2Dæ¿€å…‰é›·è¾¾æ‰«æå’Œé‡Œç¨‹è®¡æ•°æ®ï¼‰ï¼Œæ‰§è¡Œæ™ºèƒ½å†³ç­–ã€ç¯å¢ƒæ„ŸçŸ¥å’Œå¯¼èˆªè§„åˆ’ç­‰æ ¸å¿ƒä»»åŠ¡ã€‚

---

## 2. æŠ€æœ¯æ ˆè¯„ä¼°ä¸é€‰å‹

### 2.1 æŠ€æœ¯æ ˆå¯¹æ¯”åˆ†æ

#### âŒ åŸæ–¹æ¡ˆä¸­å¯èƒ½è½åçš„åº“

| åº“åç§° | é—®é¢˜ | æ¨èæ›¿ä»£æ–¹æ¡ˆ |
|--------|------|--------------|
| **BreezySLAM** | âš ï¸ å·²åœæ­¢ç»´æŠ¤(2016å¹´)ï¼ŒåŠŸèƒ½ç®€é™‹ | **æ›¿ä»£1: SLAM Toolbox** (ROS2)<br>**æ›¿ä»£2: Hector SLAM** (è½»é‡çº§)<br>**æ›¿ä»£3: è‡ªå·±å®ç°ç®€å•æ …æ ¼SLAM** |
| **PyRoboViz** | âš ï¸ ç¤¾åŒºä¸æ´»è·ƒï¼Œå¯èƒ½ä¸å­˜åœ¨ | **æ›¿ä»£: Matplotlib + OpenCV**<br>æˆ– **pygame**ï¼ˆå®æ—¶æ¸²æŸ“ï¼‰ |
| **PythonRobotics** | âœ… ä»åœ¨ç»´æŠ¤ï¼Œä½†ä»…ä½œå‚è€ƒ | ä¿ç•™ï¼Œä½œä¸ºç®—æ³•å‚è€ƒå®ç° |

#### âœ… æ¨èçš„ç°ä»£åŒ–æŠ€æœ¯æ ˆ

| åŠŸèƒ½æ¨¡å— | æ¨èæ–¹æ¡ˆ | ä¼˜åŠ¿ | å®‰è£…å‘½ä»¤ |
|---------|---------|------|---------|
| **SLAMå»ºå›¾** | **è‡ªå®ç°å æ®æ …æ ¼SLAM**<br>+ NumPyä¼˜åŒ– | å¯æ§æ€§å¼ºã€æ— ä¾èµ–ã€é€‚åˆæ•™å­¦ | `pip install numpy` |
| **å®æ—¶å¯è§†åŒ–** | **Matplotlib + Animation**<br>æˆ– **Pygame** | æˆç†Ÿç¨³å®šã€æ–‡æ¡£ä¸°å¯Œ | `pip install matplotlib pygame` |
| **è·¯å¾„è§„åˆ’** | **python-pathfinding**<br>+ è‡ªå®ç°DWA | ç°ä»£åŒ–ã€æ€§èƒ½å¥½ | `pip install pathfinding` |
| **ä¸²å£é€šä¿¡** | **PySerial** | âœ… è¡Œä¸šæ ‡å‡†ï¼Œä¿æŒä¸å˜ | `pip install pyserial` |
| **æ•°æ®å¤„ç†** | **NumPy + Pandas** | é«˜æ€§èƒ½æ•°å€¼è®¡ç®— | `pip install numpy pandas` |
| **ç§‘å­¦è®¡ç®—** | **SciPy** | æ»¤æ³¢ã€æ’å€¼ç­‰é«˜çº§åŠŸèƒ½ | `pip install scipy` |

### 2.2 æœ€ç»ˆé€‰å®šæŠ€æœ¯æ ˆ

```python
# requirements.txt å®Œæ•´ä¾èµ–åˆ—è¡¨

# æ ¸å¿ƒè®¡ç®—åº“
numpy>=1.24.0              # æ•°å€¼è®¡ç®—
scipy>=1.10.0              # ç§‘å­¦è®¡ç®—ï¼ˆæ»¤æ³¢ã€ä¼˜åŒ–ï¼‰
pandas>=2.0.0              # æ•°æ®åˆ†æï¼ˆå¯é€‰ï¼‰

# é€šä¿¡åº“
pyserial>=3.5              # è“ç‰™ä¸²å£é€šä¿¡

# å¯è§†åŒ–åº“
matplotlib>=3.7.0          # å®æ—¶åœ°å›¾å¯è§†åŒ–
pygame>=2.5.0              # æ¸¸æˆå¼•æ“ï¼Œç”¨äºæ›´æµç•…çš„å®æ—¶æ¸²æŸ“ï¼ˆå¯é€‰ï¼‰

# è·¯å¾„è§„åˆ’
pathfinding>=1.0.0         # A*ç­‰è·¯å¾„è§„åˆ’ç®—æ³•

# å›¾åƒå¤„ç†ï¼ˆå¯é€‰ï¼Œç”¨äºåœ°å›¾å¤„ç†ï¼‰
opencv-python>=4.8.0       # OpenCVï¼ˆå¯é€‰ï¼‰
Pillow>=10.0.0             # å›¾åƒå¤„ç†ï¼ˆå¯é€‰ï¼‰

# å¼€å‘å·¥å…·
pytest>=7.4.0              # å•å…ƒæµ‹è¯•
black>=23.0.0              # ä»£ç æ ¼å¼åŒ–
```

### 2.3 ä¸ºä»€ä¹ˆä¸ç”¨ROSï¼Ÿ

**è€ƒè™‘å› ç´ ï¼š**

| ROSä¼˜åŠ¿ | ROSåŠ£åŠ¿ | æœ¬é¡¹ç›®é€‰æ‹© |
|---------|---------|-----------|
| å®Œæ•´çš„SLAMå·¥å…·é“¾ | å­¦ä¹ æ›²çº¿é™¡å³­ | âŒ ä¸ä½¿ç”¨ROS |
| ä¸°å¯Œçš„å¯¼èˆªåŒ… | Windowsæ”¯æŒå·® | |
| æˆç†Ÿçš„å¯è§†åŒ–å·¥å…· | ä¾èµ–å¤æ‚ | |

**ç»“è®ºï¼š** æœ¬é¡¹ç›®é‡‡ç”¨**çº¯Pythonè½»é‡çº§æ–¹æ¡ˆ**ï¼Œæ›´çµæ´»ã€æ›´é€‚åˆå¿«é€Ÿå¼€å‘å’Œè°ƒè¯•ã€‚

---

## 3. é€šä¿¡åè®®è§„èŒƒ

### 3.1 é€šä¿¡æ¶æ„æ€»è§ˆ

```
STM32å›ºä»¶ç«¯ (UART4è“ç‰™)  â†â†’  Pythonä¸»æœºç«¯
    â†“                            â†“
  ä¼ æ„Ÿå™¨æ•°æ®                   å¯¼èˆªæŒ‡ä»¤
  - é›·è¾¾æ‰«æ                   - ç›®æ ‡ä½ç½®
  - MPUå§¿æ€                    - é€Ÿåº¦æ§åˆ¶
  - ç¼–ç å™¨                     - æ¨¡å¼åˆ‡æ¢
```

### 3.2 æ•°æ®åŒ…æ ¼å¼è®¾è®¡

#### ğŸ“¤ ä¸Šè¡Œæ•°æ®ï¼ˆSTM32 â†’ PCï¼‰

##### æ•°æ®åŒ…1: æ¿€å…‰é›·è¾¾æ•°æ®

**æ ¼å¼ï¼š** JSONå­—ç¬¦ä¸²ï¼ˆä¾¿äºè§£æå’Œè°ƒè¯•ï¼‰

```json
{
  "type": "LIDAR",
  "timestamp": 12345678,
  "data": {
    "total_points": 652,
    "angle_coverage": 359.8,
    "sectors": [
      {
        "sector_id": 0,
        "angle_center": 0,
        "count": 82,
        "min_dist": 1.25,
        "avg_dist": 3.42
      },
      // ... 8ä¸ªæ‰‡åŒºæ•°æ®
    ],
    "raw_points": [  // å¯é€‰ï¼šè¯¦ç»†ç‚¹äº‘æ•°æ®
      {"angle": 0.5, "distance": 1.25, "quality": 67},
      // ...
    ]
  }
}
```

**å‘é€æ—¶æœºï¼š** 
- æ–¹å¼1ï¼šå›ºä»¶æ”¶åˆ° `A` å‘½ä»¤åä¸»åŠ¨å‘é€å®Œæ•´æ‰«æç»“æœ
- æ–¹å¼2ï¼šä»¥å›ºå®šé¢‘ç‡ï¼ˆå¦‚1Hzï¼‰å‘é€æœ€æ–°æ‰«ææ•°æ®

**Pythonæ¥æ”¶ç¤ºä¾‹ï¼š**
```python
import json

def parse_lidar_data(serial_line):
    try:
        data = json.loads(serial_line)
        if data['type'] == 'LIDAR':
            return data['data']
    except json.JSONDecodeError:
        return None
```

---

##### æ•°æ®åŒ…2: MPU6500å§¿æ€æ•°æ®

**æ ¼å¼ï¼š** ç®€åŒ–CSVæ ¼å¼ï¼ˆé«˜é¢‘ç‡æ•°æ®ï¼Œå‡å°‘å¼€é”€ï¼‰

```
MPU,timestamp,roll,pitch,accel_x,accel_y,accel_z,gyro_x,gyro_y,gyro_z
```

**ç¤ºä¾‹ï¼š**
```
MPU,12345678,0.23,-1.15,0.012,-0.035,9.815,0.23,-0.15,0.08
```

**å­—æ®µè¯´æ˜ï¼š**
- `timestamp`: æ¯«ç§’æ—¶é—´æˆ³
- `roll`: æ¨ªæ»šè§’ï¼ˆåº¦ï¼‰
- `pitch`: ä¿¯ä»°è§’ï¼ˆåº¦ï¼‰
- `accel_x/y/z`: åŠ é€Ÿåº¦ï¼ˆm/sÂ²ï¼‰
- `gyro_x/y/z`: è§’é€Ÿåº¦ï¼ˆÂ°/sï¼‰

**å‘é€é¢‘ç‡ï¼š** 50Hzï¼ˆæ¯20msä¸€æ¬¡ï¼‰

**Pythonæ¥æ”¶ç¤ºä¾‹ï¼š**
```python
def parse_mpu_data(line):
    parts = line.strip().split(',')
    if parts[0] == 'MPU':
        return {
            'timestamp': int(parts[1]),
            'roll': float(parts[2]),
            'pitch': float(parts[3]),
            'accel': [float(parts[4]), float(parts[5]), float(parts[6])],
            'gyro': [float(parts[7]), float(parts[8]), float(parts[9])]
        }
```

---

##### æ•°æ®åŒ…3: é‡Œç¨‹è®¡æ•°æ®

**æ ¼å¼ï¼š** CSVæ ¼å¼

```
ODO,timestamp,left_speed_rps,right_speed_rps,left_count,right_count
```

**ç¤ºä¾‹ï¼š**
```
ODO,12345678,3.5,3.5,12450,12470
```

**å­—æ®µè¯´æ˜ï¼š**
- `left/right_speed_rps`: å·¦å³è½®é€Ÿåº¦ï¼ˆè½¬/ç§’ï¼‰
- `left/right_count`: ç¼–ç å™¨ç´¯è®¡è®¡æ•°

**å‘é€é¢‘ç‡ï¼š** 50Hzï¼ˆä¸MPUåŒæ­¥ï¼‰

---

##### æ•°æ®åŒ…4: ä½å§¿ä¼°è®¡ï¼ˆèåˆç»“æœï¼‰

**æ ¼å¼ï¼š** CSVæ ¼å¼

```
POSE,timestamp,x,y,theta
```

**ç¤ºä¾‹ï¼š**
```
POSE,12345678,1.25,0.85,45.0
```

**å­—æ®µè¯´æ˜ï¼š**
- `x, y`: æœºå™¨äººä½ç½®ï¼ˆç±³ï¼‰
- `theta`: æœå‘è§’ï¼ˆåº¦ï¼Œ0Â°ä¸ºæ­£å‰æ–¹ï¼‰

**å‘é€é¢‘ç‡ï¼š** 20Hz

---

#### ğŸ“¥ ä¸‹è¡Œæ•°æ®ï¼ˆPC â†’ STM32ï¼‰

##### æŒ‡ä»¤1: å¯¼èˆªæ§åˆ¶

**æ ¼å¼ï¼š** ç®€æ´å‘½ä»¤æ ¼å¼

```
NAV,x,y,theta,speed
```

**ç¤ºä¾‹ï¼š**
```
NAV,2.5,1.8,90.0,3.0
```

**å­—æ®µè¯´æ˜ï¼š**
- `x, y`: ç›®æ ‡ä½ç½®ï¼ˆç±³ï¼‰
- `theta`: ç›®æ ‡æœå‘ï¼ˆåº¦ï¼‰
- `speed`: ç›®æ ‡é€Ÿåº¦ï¼ˆRPSï¼‰

---

##### æŒ‡ä»¤2: é€Ÿåº¦æ§åˆ¶

**æ ¼å¼ï¼š**
```
SPD,left_speed,right_speed
```

**ç¤ºä¾‹ï¼š**
```
SPD,3.5,3.5  # ç›´è¡Œ
SPD,2.0,4.0  # å³è½¬
```

---

##### æŒ‡ä»¤3: æ¨¡å¼æ§åˆ¶

**æ ¼å¼ï¼š**
```
MODE,mode_id
```

**æ¨¡å¼å®šä¹‰ï¼š**
- `MODE,0` = åœæ­¢
- `MODE,1` = PIDå‰è¿›
- `MODE,2` = PIDåé€€
- `MODE,3` = å·¦è½¬
- `MODE,4` = å³è½¬
- `MODE,5` = è‡ªåŠ¨å¯¼èˆªæ¨¡å¼

---

### 3.3 é€šä¿¡åè®®å®ç°ï¼ˆSTM32ç«¯ï¼‰

**åœ¨ main.c ä¸­æ·»åŠ æ•°æ®å‘é€å‡½æ•°ï¼š**

```c
/* å‘é€é›·è¾¾JSONæ•°æ® */
void Send_Lidar_JSON(UART_HandleTypeDef *huart, RadarScanResult *result) {
    char json_buf[2048];
    int pos = 0;
    
    pos += snprintf(json_buf + pos, sizeof(json_buf) - pos, 
                    "{\"type\":\"LIDAR\",\"timestamp\":%lu,\"data\":{", HAL_GetTick());
    pos += snprintf(json_buf + pos, sizeof(json_buf) - pos,
                    "\"total_points\":%d,\"angle_coverage\":%.1f,\"sectors\":[",
                    result->total_points, result->angle_coverage);
    
    for (int i = 0; i < 8; i++) {
        pos += snprintf(json_buf + pos, sizeof(json_buf) - pos,
                        "{\"sector_id\":%d,\"angle_center\":%d,\"count\":%d,\"min_dist\":%.2f,\"avg_dist\":%.2f}",
                        i, i*45, result->sectors[i].count, 
                        result->sectors[i].min_dist, result->sectors[i].avg_dist);
        if (i < 7) pos += snprintf(json_buf + pos, sizeof(json_buf) - pos, ",");
    }
    
    pos += snprintf(json_buf + pos, sizeof(json_buf) - pos, "]}}\n");
    
    HAL_UART_Transmit(huart, (uint8_t*)json_buf, pos, 1000);
}

/* å‘é€MPUæ•°æ®ï¼ˆCSVï¼‰ */
void Send_MPU_CSV(UART_HandleTypeDef *huart, float roll, float pitch, 
                  float ax, float ay, float az, float gx, float gy, float gz) {
    char csv_buf[128];
    int len = snprintf(csv_buf, sizeof(csv_buf),
                       "MPU,%lu,%.2f,%.2f,%.3f,%.3f,%.3f,%.2f,%.2f,%.2f\n",
                       HAL_GetTick(), roll, pitch, ax, ay, az, gx, gy, gz);
    HAL_UART_Transmit(huart, (uint8_t*)csv_buf, len, 100);
}

/* å‘é€é‡Œç¨‹è®¡æ•°æ®ï¼ˆCSVï¼‰ */
void Send_Odometry_CSV(UART_HandleTypeDef *huart, float left_rps, float right_rps,
                       int32_t left_count, int32_t right_count) {
    char csv_buf[128];
    int len = snprintf(csv_buf, sizeof(csv_buf),
                       "ODO,%lu,%.2f,%.2f,%ld,%ld\n",
                       HAL_GetTick(), left_rps, right_rps, left_count, right_count);
    HAL_UART_Transmit(huart, (uint8_t*)csv_buf, len, 100);
}

/* å‘é€ä½å§¿ä¼°è®¡ï¼ˆCSVï¼‰ */
void Send_Pose_CSV(UART_HandleTypeDef *huart, float x, float y, float theta) {
    char csv_buf[64];
    int len = snprintf(csv_buf, sizeof(csv_buf),
                       "POSE,%lu,%.3f,%.3f,%.2f\n",
                       HAL_GetTick(), x, y, theta);
    HAL_UART_Transmit(huart, (uint8_t*)csv_buf, len, 100);
}
```

---

### 3.4 é€šä¿¡åè®®å®ç°ï¼ˆPythonç«¯ï¼‰

**å®Œæ•´é€šä¿¡ç±»å®ç°ï¼š**

```python
import serial
import json
import time
import threading
from dataclasses import dataclass
from typing import Optional, Callable

@dataclass
class LidarData:
    timestamp: int
    total_points: int
    angle_coverage: float
    sectors: list

@dataclass
class MPUData:
    timestamp: int
    roll: float
    pitch: float
    accel: list  # [x, y, z]
    gyro: list   # [x, y, z]

@dataclass
class OdometryData:
    timestamp: int
    left_speed: float
    right_speed: float
    left_count: int
    right_count: int

@dataclass
class PoseData:
    timestamp: int
    x: float
    y: float
    theta: float

class RobotComm:
    """æœºå™¨äººé€šä¿¡ç±»"""
    
    def __init__(self, port='COM5', baudrate=115200):
        self.serial = serial.Serial(port, baudrate, timeout=0.1)
        self.running = False
        self.receive_thread = None
        
        # æœ€æ–°æ•°æ®ç¼“å­˜
        self.latest_lidar: Optional[LidarData] = None
        self.latest_mpu: Optional[MPUData] = None
        self.latest_odom: Optional[OdometryData] = None
        self.latest_pose: Optional[PoseData] = None
        
        # å›è°ƒå‡½æ•°
        self.on_lidar_update: Optional[Callable] = None
        self.on_mpu_update: Optional[Callable] = None
        self.on_odom_update: Optional[Callable] = None
        self.on_pose_update: Optional[Callable] = None
    
    def start(self):
        """å¯åŠ¨æ¥æ”¶çº¿ç¨‹"""
        self.running = True
        self.receive_thread = threading.Thread(target=self._receive_loop, daemon=True)
        self.receive_thread.start()
    
    def stop(self):
        """åœæ­¢é€šä¿¡"""
        self.running = False
        if self.receive_thread:
            self.receive_thread.join(timeout=1)
        self.serial.close()
    
    def _receive_loop(self):
        """æ¥æ”¶å¾ªç¯ï¼ˆåœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡Œï¼‰"""
        buffer = ""
        
        while self.running:
            try:
                if self.serial.in_waiting:
                    data = self.serial.read(self.serial.in_waiting).decode('utf-8', errors='ignore')
                    buffer += data
                    
                    # æŒ‰è¡Œå¤„ç†
                    while '\n' in buffer:
                        line, buffer = buffer.split('\n', 1)
                        self._parse_line(line.strip())
                        
            except Exception as e:
                print(f"[COMM ERROR] {e}")
                time.sleep(0.1)
    
    def _parse_line(self, line: str):
        """è§£æä¸€è¡Œæ•°æ®"""
        if not line:
            return
        
        # JSONæ ¼å¼ï¼ˆé›·è¾¾æ•°æ®ï¼‰
        if line.startswith('{'):
            try:
                data = json.loads(line)
                if data['type'] == 'LIDAR':
                    self.latest_lidar = LidarData(
                        timestamp=data['timestamp'],
                        total_points=data['data']['total_points'],
                        angle_coverage=data['data']['angle_coverage'],
                        sectors=data['data']['sectors']
                    )
                    if self.on_lidar_update:
                        self.on_lidar_update(self.latest_lidar)
            except json.JSONDecodeError:
                pass
        
        # CSVæ ¼å¼
        else:
            parts = line.split(',')
            
            if parts[0] == 'MPU' and len(parts) == 10:
                self.latest_mpu = MPUData(
                    timestamp=int(parts[1]),
                    roll=float(parts[2]),
                    pitch=float(parts[3]),
                    accel=[float(parts[4]), float(parts[5]), float(parts[6])],
                    gyro=[float(parts[7]), float(parts[8]), float(parts[9])]
                )
                if self.on_mpu_update:
                    self.on_mpu_update(self.latest_mpu)
            
            elif parts[0] == 'ODO' and len(parts) == 6:
                self.latest_odom = OdometryData(
                    timestamp=int(parts[1]),
                    left_speed=float(parts[2]),
                    right_speed=float(parts[3]),
                    left_count=int(parts[4]),
                    right_count=int(parts[5])
                )
                if self.on_odom_update:
                    self.on_odom_update(self.latest_odom)
            
            elif parts[0] == 'POSE' and len(parts) == 5:
                self.latest_pose = PoseData(
                    timestamp=int(parts[1]),
                    x=float(parts[2]),
                    y=float(parts[3]),
                    theta=float(parts[4])
                )
                if self.on_pose_update:
                    self.on_pose_update(self.latest_pose)
    
    def send_navigation_command(self, x: float, y: float, theta: float, speed: float):
        """å‘é€å¯¼èˆªæŒ‡ä»¤"""
        cmd = f"NAV,{x:.3f},{y:.3f},{theta:.2f},{speed:.2f}\n"
        self.serial.write(cmd.encode())
    
    def send_speed_command(self, left_speed: float, right_speed: float):
        """å‘é€é€Ÿåº¦æŒ‡ä»¤"""
        cmd = f"SPD,{left_speed:.2f},{right_speed:.2f}\n"
        self.serial.write(cmd.encode())
    
    def send_mode_command(self, mode: int):
        """å‘é€æ¨¡å¼æŒ‡ä»¤"""
        cmd = f"MODE,{mode}\n"
        self.serial.write(cmd.encode())
    
    def request_lidar_scan(self):
        """è¯·æ±‚é›·è¾¾æ‰«æ"""
        self.serial.write(b'A')
```

---

## 4. æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

### 2.1 è‡ªä¸»å¯¼èˆªä¸ç¯å¢ƒæ¢ç´¢

**ç›®æ ‡ï¼š** åœ¨æœªçŸ¥è¿·å®«ç¯å¢ƒä¸­å®ç°è‡ªä¸»æ¢ç´¢å¹¶å®šä½å‡ºå£ç‚¹

**æŠ€æœ¯æ–¹æ¡ˆï¼š** åŸºäºFrontieræ£€æµ‹çš„è‡ªä¸»æ¢ç´¢ç®—æ³•

#### å·¥ä½œåŸç†

Frontieræ£€æµ‹æ–¹æ³•é€šè¿‡åˆ†æåŠ¨æ€æ„å»ºçš„å æ®æ …æ ¼åœ°å›¾ï¼Œè¯†åˆ«"å‰æ²¿å•å…ƒæ ¼"ï¼ˆfrontier cellsï¼‰â€”â€”å³å·²çŸ¥è‡ªç”±ç©ºé—´ä¸æœªæ¢ç´¢åŒºåŸŸä¹‹é—´çš„è¾¹ç•Œã€‚è¿™äº›å‰æ²¿è¢«ä¼˜å…ˆä½œä¸ºåŠ¨æ€å¯¼èˆªç›®æ ‡ï¼Œå¼•å¯¼æœºå™¨äººé€æ­¥æ˜ å°„æ•´ä¸ªç¯å¢ƒã€‚

#### æ¢ç´¢æµç¨‹

æ¢ç´¢è¿‡ç¨‹éµå¾ªä»¥ä¸‹æŒç»­å¾ªç¯ï¼š

1. **å‰æ²¿è¯†åˆ«**
   - åœ¨å½“å‰SLAMåœ°å›¾ä¸­è¯†åˆ«æ‰€æœ‰å‰æ²¿å•å…ƒæ ¼
   - åˆ†æå·²çŸ¥åŒºåŸŸä¸æœªçŸ¥åŒºåŸŸçš„è¾¹ç•Œ

2. **ç›®æ ‡é€‰æ‹©**
   - æ ¹æ®è·ç¦»æˆ–ä¿¡æ¯å¢ç›Šé€‰æ‹©æœ€è¿‘æˆ–æœ€æœ‰å‰æ™¯çš„å‰æ²¿
   - ä½¿ç”¨å¯å‘å¼ç®—æ³•ä¼˜åŒ–æ¢ç´¢æ•ˆç‡

3. **è·¯å¾„è§„åˆ’**
   - ä½¿ç”¨A*ç®—æ³•è¿›è¡Œå…¨å±€è·¯å¾„è§„åˆ’
   - ä½¿ç”¨åŠ¨æ€çª—å£æ³•ï¼ˆDWAï¼‰[8]è¿›è¡Œå±€éƒ¨é¿éšœ
   - è§„åˆ’åˆ°é€‰å®šå‰æ²¿çš„æœ€ä¼˜è·¯å¾„

4. **æŒç»­æ¢ç´¢**
   - ç»§ç»­æ¢ç´¢ç›´åˆ°æ•´ä¸ªç¯å¢ƒè¢«æ˜ å°„å®Œæˆ
   - æˆ–æˆåŠŸå®šä½åˆ°å‡ºå£ç‚¹

5. **æŒ‡ä»¤ä¼ è¾“**
   - å°†è®¡ç®—çš„å¯¼èˆªæŒ‡ä»¤ä¼ è¾“åˆ°æœºå™¨äººå›ºä»¶æ‰§è¡Œ
   - å®æ—¶ç›‘æ§æ‰§è¡ŒçŠ¶æ€å¹¶è°ƒæ•´ç­–ç•¥

#### å…³é”®æŠ€æœ¯ç‚¹

- **å æ®æ …æ ¼åœ°å›¾æ„å»º**ï¼šå®æ—¶æ›´æ–°ç¯å¢ƒåœ°å›¾
- **å‰æ²¿æ£€æµ‹ç®—æ³•**ï¼šé«˜æ•ˆè¯†åˆ«æ¢ç´¢è¾¹ç•Œ
- **å¯å‘å¼æœç´¢**ï¼šä¼˜åŒ–æ¢ç´¢è·¯å¾„é€‰æ‹©
- **åŠ¨æ€ç›®æ ‡è°ƒæ•´**ï¼šæ ¹æ®å®æ—¶åé¦ˆè°ƒæ•´æ¢ç´¢ç­–ç•¥

---

### 2.2 SLAMåœ°å›¾æ„å»ºä¸å¯è§†åŒ–

**ç›®æ ‡ï¼š** å®æ—¶æ„å»ºç¯å¢ƒåœ°å›¾å¹¶å¯è§†åŒ–æœºå™¨äººçŠ¶æ€

**æŠ€æœ¯æ–¹æ¡ˆï¼š** BreezySLAM [6] + PyRoboViz [7]

#### åœ°å›¾æ„å»º

ä½¿ç”¨BreezySLAM [6]ä½œä¸ºåŸºç¡€ä»£ç ï¼Œæ„å»ºå®æ—¶å æ®æ …æ ¼åœ°å›¾ï¼š

- **æ•°æ®èåˆ**ï¼šé›†æˆ2Dæ¿€å…‰é›·è¾¾å’Œé‡Œç¨‹è®¡æ•°æ®
- **å®šä½ä¼°è®¡**ï¼šå‡†ç¡®ä¼°è®¡æœºå™¨äººåœ¨è¿·å®«ä¸­çš„ä½ç½®å’Œæ–¹å‘
- **åŠ¨æ€æ›´æ–°**ï¼šéšç€æœºå™¨äººç§»åŠ¨ï¼ŒæŒç»­æ›´æ–°SLAMæ„å»ºçš„åœ°å›¾
- **è½¨è¿¹è®°å½•**ï¼šè®°å½•æœºå™¨äººçš„è¿åŠ¨è½¨è¿¹

#### å®æ—¶å¯è§†åŒ–

ä½¿ç”¨PyRoboViz [7]è¿›è¡Œå®æ—¶å¯è§†åŒ–å±•ç¤ºï¼ˆå¦‚å›¾3æ‰€ç¤ºï¼‰ï¼š

![PyRoboVizç¤ºä¾‹](å‚è€ƒå›¾3)

**å¯è§†åŒ–å†…å®¹åŒ…æ‹¬ï¼š**

- **2Dæ¿€å…‰é›·è¾¾ç‚¹äº‘æ•°æ®**ï¼šå®æ—¶æ˜¾ç¤ºç¯å¢ƒæ‰«æç»“æœ
- **æœºå™¨äººå½“å‰ä½å§¿**ï¼š(x, y, Î¸)åæ ‡å’Œæœå‘
- **SLAMç”Ÿæˆçš„åœ°å›¾**ï¼šå æ®æ …æ ¼åœ°å›¾å±•ç¤º
- **è¿åŠ¨è½¨è¿¹**ï¼šæœºå™¨äººçš„ç§»åŠ¨è·¯å¾„

**æ ¸å¿ƒç»„ä»¶ï¼š**

1. **BreezySLAM [6]åº”ç”¨**
   - ä»2Dæ¿€å…‰é›·è¾¾å’Œé‡Œç¨‹è®¡æ•°æ®æ„å»º2Då æ®æ …æ ¼åœ°å›¾
   - å¤„ç†ä¼ æ„Ÿå™¨æ•°æ®èåˆå’Œåœ°å›¾æ›´æ–°

2. **PyRoboViz [7]å¯è§†åŒ–**
   - å®æ—¶å±•ç¤ºåœ°å›¾æ„å»ºè¿‡ç¨‹
   - æ˜¾ç¤º2Dæ¿€å…‰é›·è¾¾ç‚¹äº‘
   - æ˜¾ç¤ºæœºå™¨äººå½“å‰ä½å§¿(x,y,Î¸)
   - å±•ç¤ºSLAMç”Ÿæˆçš„åœ°å›¾å’Œå¯¼èˆªè·¯å¾„

#### æŠ€æœ¯ä¼˜åŠ¿

- **å®æ—¶æ€§**ï¼šä½å»¶è¿Ÿåœ°å›¾æ›´æ–°å’Œæ˜¾ç¤º
- **ç²¾ç¡®æ€§**ï¼šå¤šä¼ æ„Ÿå™¨èåˆæé«˜å®šä½ç²¾åº¦
- **å¯è§†åŒ–**ï¼šç›´è§‚ç›‘æ§æœºå™¨äººæ¢ç´¢è¿›åº¦
- **è°ƒè¯•å‹å¥½**ï¼šä¾¿äºåˆ†æå’Œä¼˜åŒ–ç®—æ³•æ€§èƒ½

---

### 2.3 è·¯å¾„è§„åˆ’ä¸å¯¼èˆª

**ç›®æ ‡ï¼š** å®Œæˆæ¢ç´¢åè§„åˆ’ä»å‡ºå£è¿”å›èµ·ç‚¹çš„æœ€ä¼˜è·¯å¾„

**æŠ€æœ¯æ–¹æ¡ˆï¼š** åŸºäºPythonRoboticsåº“çš„é²æ£’è·¯å¾„è§„åˆ’ç®—æ³•

#### è§„åˆ’æµç¨‹

ä¸€æ—¦å®šä½åˆ°å‡ºå£ç‚¹å¹¶å®Œæˆåœ°å›¾æ„å»ºï¼Œç³»ç»Ÿå°†ï¼š

1. **èˆªç‚¹ç¡®å®š**
   - ç¡®å®šé«˜æ•ˆçš„è¿·å®«æ¢ç´¢èˆªç‚¹
   - æ ‡è®°å‡ºå£æ£€æµ‹ç‚¹
   - è§„åˆ’è¿”å›èµ·ç‚¹çš„è·¯çº¿

2. **å…¨å±€è·¯å¾„è§„åˆ’**
   - ä½¿ç”¨A*ç®—æ³•[8]è¿›è¡Œå…¨å±€è·¯å¾„è§„åˆ’
   - åœ¨å®Œæ•´åœ°å›¾ä¸Šè®¡ç®—æœ€ä¼˜è·¯å¾„
   - è€ƒè™‘è·¯å¾„é•¿åº¦å’Œå®‰å…¨æ€§

3. **å±€éƒ¨é¿éšœ**
   - ä½¿ç”¨åŠ¨æ€çª—å£æ³•ï¼ˆDWAï¼‰è¿›è¡Œå®æ—¶å±€éƒ¨é¿éšœ
   - åº”å¯¹åŠ¨æ€éšœç¢ç‰©å’Œä¼ æ„Ÿå™¨å™ªå£°
   - ç¡®ä¿å¹³æ»‘çš„è¿åŠ¨è½¨è¿¹

4. **å‰æ²¿æ¢ç´¢å¯¼èˆª**
   - ä½¿ç”¨Frontier Detectionç®—æ³•
   - åœ¨æœªçŸ¥ç¯å¢ƒä¸­è¿›è¡ŒåŸºäºæ¢ç´¢çš„å¯¼èˆª
   - åˆ©ç”¨PythonRobotics [8]åº“çš„å‚è€ƒç®—æ³•

5. **æŒ‡ä»¤ç”Ÿæˆä¸ä¼ è¾“**
   - ç”Ÿæˆç›®æ ‡ä½ç½®æŒ‡ä»¤(x,y,Î¸)
   - å°†å¯¼èˆªå‘½ä»¤ä¼ è¾“åˆ°æœºå™¨äººå›ºä»¶æ‰§è¡Œ
   - é€šè¿‡PIDæ§åˆ¶å®ç°ç²¾ç¡®çš„é€Ÿåº¦å’Œä½ç½®æ§åˆ¶

#### ç®—æ³•åº“

**PythonRobotics [8]åº“åº”ç”¨ï¼š**

- **A*ç®—æ³•**ï¼šå…¨å±€æœ€ä¼˜è·¯å¾„æœç´¢
- **DWAç®—æ³•**ï¼šåŠ¨æ€çª—å£é¿éšœ
- **Frontier Detection**ï¼šæœªçŸ¥ç¯å¢ƒæ¢ç´¢
- **è·¯å¾„å¹³æ»‘**ï¼šä¼˜åŒ–è¿åŠ¨è½¨è¿¹

#### æ§åˆ¶ç­–ç•¥

- **ä½ç½®æ§åˆ¶**ï¼šç²¾ç¡®åˆ°è¾¾ç›®æ ‡ç‚¹
- **é€Ÿåº¦æ§åˆ¶**ï¼šå¹³æ»‘åŠ å‡é€Ÿ
- **è§’åº¦æ§åˆ¶**ï¼šå‡†ç¡®è½¬å‘
- **å®æ—¶è°ƒæ•´**ï¼šæ ¹æ®ä¼ æ„Ÿå™¨åé¦ˆåŠ¨æ€ä¿®æ­£

---

### 2.4 é€šä¿¡ä¸æ•°æ®ç®¡ç†

**ç›®æ ‡ï¼š** å®ç°ä¸»æœºä¸æœºå™¨äººä¹‹é—´çš„å¯é æ— çº¿é€šä¿¡å’Œæ•°æ®å¤„ç†

**æŠ€æœ¯æ–¹æ¡ˆï¼š** åŸºäºPySerial [9]çš„è“ç‰™é€šä¿¡

#### é€šä¿¡æ¶æ„

ä½¿ç”¨PySerial [9]åº“é€šè¿‡è“ç‰™å®ç°æ— çº¿é€šä¿¡ï¼š

- **é€šä¿¡æ–¹å¼**ï¼šè“ç‰™ï¼ˆUART4ï¼‰
- **æ³¢ç‰¹ç‡**ï¼š115200
- **é€šä¿¡æ¨¡å¼**ï¼šåŒå‘å®æ—¶é€šä¿¡
- **åè®®**ï¼šè‡ªå®šä¹‰æ•°æ®åŒ…åè®®

#### æ•°æ®æµå‘

**ä¸Šè¡Œæ•°æ®ï¼ˆæœºå™¨äººâ†’ä¸»æœºï¼‰ï¼š**

1. **2Dæ¿€å…‰é›·è¾¾æ•°æ®**
   - 360Â°æ‰«æç‚¹äº‘æ•°æ®
   - è·ç¦»å’Œè§’åº¦ä¿¡æ¯
   - æ•°æ®è´¨é‡æ ‡å¿—

2. **é‡Œç¨‹è®¡æ•°æ®**
   - å·¦å³è½®ç¼–ç å™¨è®¡æ•°
   - è½®é€Ÿä¿¡æ¯ï¼ˆRPSï¼‰
   - æ—¶é—´æˆ³

3. **æœºå™¨äººå½“å‰ä½å§¿**
   - ä½ç½®åæ ‡(x, y)
   - æœå‘è§’åº¦Î¸
   - MPU6500å§¿æ€æ•°æ®ï¼ˆRoll, Pitchï¼‰

**ä¸‹è¡Œæ•°æ®ï¼ˆä¸»æœºâ†’æœºå™¨äººï¼‰ï¼š**

1. **å¯¼èˆªæ§åˆ¶æŒ‡ä»¤**
   - ç›®æ ‡ä½ç½®(x, y, Î¸)
   - è¿åŠ¨æ¨¡å¼ï¼ˆå‰è¿›/åé€€/è½¬å‘/åœæ­¢ï¼‰
   - é€Ÿåº¦æŒ‡ä»¤

2. **PIDå‚æ•°**
   - é€Ÿåº¦æ§åˆ¶å‚æ•°
   - ä½ç½®æ§åˆ¶å‚æ•°
   - å®æ—¶è°ƒæ•´æŒ‡ä»¤

#### æ§åˆ¶å¾ªç¯

å®ç°é—­ç¯æ§åˆ¶å’Œè‡ªé€‚åº”å†³ç­–ï¼š

- **æ•°æ®æ¥æ”¶**ï¼šæŒç»­æ¥æ”¶ä¼ æ„Ÿå™¨æ•°æ®åŒ…
- **æ•°æ®å¤„ç†**ï¼šè§£æå’ŒéªŒè¯æ•°æ®
- **å†³ç­–è®¡ç®—**ï¼šåŸºäºå®æ—¶ç¯å¢ƒåé¦ˆè¿›è¡Œè·¯å¾„è§„åˆ’
- **æŒ‡ä»¤å‘é€**ï¼šå‘é€å®æ—¶æ§åˆ¶å¯¼èˆªå‘½ä»¤
- **åé¦ˆè°ƒæ•´**ï¼šæ ¹æ®æ‰§è¡Œç»“æœè°ƒæ•´ç­–ç•¥

#### æ•°æ®ç®¡ç†åŠŸèƒ½

**æ•°æ®è®°å½•ï¼š**
- ç¦»çº¿åˆ†ææ—¥å¿—
- ä¼ æ„Ÿå™¨æ•°æ®è®°å½•
- æœºå™¨äººè½¨è¿¹è®°å½•
- SLAMåœ°å›¾ä¿å­˜

**è°ƒè¯•åŠŸèƒ½ï¼š**
- å®æ—¶æ•°æ®ç›‘æ§
- æ€§èƒ½è¯„ä¼°å·¥å…·
- é”™è¯¯è¯Šæ–­æ—¥å¿—
- é€šä¿¡è´¨é‡æ£€æµ‹

**æ•°æ®åˆ†æï¼š**
- ä¼ æ„Ÿå™¨æ•°æ®è´¨é‡åˆ†æ
- è½¨è¿¹ç²¾åº¦è¯„ä¼°
- SLAMå‡†ç¡®æ€§éªŒè¯
- ç³»ç»Ÿæ€§èƒ½è¯„ä¼°

---

## 5. å…·ä½“å®ç°ä»£ç 

### 5.1 ç®€å•SLAMå®ç°ï¼ˆå æ®æ …æ ¼åœ°å›¾ï¼‰

```python
import numpy as np
from typing import Tuple

class OccupancyGridMap:
    """å æ®æ …æ ¼åœ°å›¾"""
    
    def __init__(self, width: int = 500, height: int = 500, resolution: float = 0.05):
        """
        Args:
            width, height: åœ°å›¾æ …æ ¼æ•°é‡
            resolution: åˆ†è¾¨ç‡ï¼ˆç±³/æ …æ ¼ï¼‰
        """
        self.width = width
        self.height = height
        self.resolution = resolution
        
        # åœ°å›¾æ•°æ®ï¼š0=æœªçŸ¥, 0.5=ç©ºé—², 1=å ç”¨
        self.grid = np.ones((height, width)) * 0.5
        
        # æœºå™¨äººåˆå§‹ä½ç½®ï¼ˆåœ°å›¾ä¸­å¿ƒï¼‰
        self.robot_x = width // 2
        self.robot_y = height // 2
        self.robot_theta = 0.0
    
    def world_to_grid(self, x: float, y: float) -> Tuple[int, int]:
        """ä¸–ç•Œåæ ‡ â†’ æ …æ ¼åæ ‡"""
        grid_x = int(self.robot_x + x / self.resolution)
        grid_y = int(self.robot_y - y / self.resolution)  # Yè½´ç¿»è½¬
        return grid_x, grid_y
    
    def grid_to_world(self, grid_x: int, grid_y: int) -> Tuple[float, float]:
        """æ …æ ¼åæ ‡ â†’ ä¸–ç•Œåæ ‡"""
        x = (grid_x - self.robot_x) * self.resolution
        y = -(grid_y - self.robot_y) * self.resolution
        return x, y
    
    def update_with_lidar(self, lidar_data, robot_pose):
        """ç”¨é›·è¾¾æ•°æ®æ›´æ–°åœ°å›¾
        
        Args:
            lidar_data: LidarDataå¯¹è±¡
            robot_pose: (x, y, theta) æœºå™¨äººä½å§¿
        """
        rx, ry, rtheta = robot_pose
        
        for sector in lidar_data.sectors:
            if sector['count'] == 0:
                continue
            
            # æ‰‡åŒºè§’åº¦
            angle_deg = sector['angle_center']
            angle_rad = np.deg2rad(angle_deg) + rtheta
            
            # éšœç¢ç‰©ä½ç½®
            dist = sector['min_dist']
            if dist > 0.1 and dist < 10.0:  # æœ‰æ•ˆèŒƒå›´
                obs_x = rx + dist * np.cos(angle_rad)
                obs_y = ry + dist * np.sin(angle_rad)
                
                # è½¬æ¢ä¸ºæ …æ ¼åæ ‡
                grid_x, grid_y = self.world_to_grid(obs_x, obs_y)
                
                # æ ‡è®°éšœç¢ç‰©
                if 0 <= grid_x < self.width and 0 <= grid_y < self.height:
                    self.grid[grid_y, grid_x] = 1.0  # å ç”¨
                
                # å°„çº¿è¿½è¸ªï¼šæ ‡è®°é€”å¾„åŒºåŸŸä¸ºç©ºé—²
                self._ray_trace(rx, ry, obs_x, obs_y, mark_free=True)
    
    def _ray_trace(self, x0, y0, x1, y1, mark_free=True):
        """å°„çº¿è¿½è¸ªï¼ˆBresenhamç®—æ³•ï¼‰"""
        gx0, gy0 = self.world_to_grid(x0, y0)
        gx1, gy1 = self.world_to_grid(x1, y1)
        
        dx = abs(gx1 - gx0)
        dy = abs(gy1 - gy0)
        sx = 1 if gx0 < gx1 else -1
        sy = 1 if gy0 < gy1 else -1
        err = dx - dy
        
        while True:
            if 0 <= gx0 < self.width and 0 <= gy0 < self.height:
                if mark_free and self.grid[gy0, gx0] != 1.0:
                    self.grid[gy0, gx0] = 0.0  # ç©ºé—²
            
            if gx0 == gx1 and gy0 == gy1:
                break
            
            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                gx0 += sx
            if e2 < dx:
                err += dx
                gy0 += sy
    
    def get_map_array(self):
        """è·å–åœ°å›¾æ•°ç»„ï¼ˆç”¨äºå¯è§†åŒ–ï¼‰"""
        return self.grid
```

---

### 5.2 Frontieræ£€æµ‹ï¼ˆæ¢ç´¢ç®—æ³•ï¼‰

```python
class FrontierDetector:
    """å‰æ²¿æ£€æµ‹å™¨"""
    
    def __init__(self, map_obj: OccupancyGridMap):
        self.map = map_obj
    
    def find_frontiers(self):
        """æŸ¥æ‰¾æ‰€æœ‰å‰æ²¿ç‚¹"""
        frontiers = []
        grid = self.map.grid
        
        for y in range(1, self.map.height - 1):
            for x in range(1, self.map.width - 1):
                if self._is_frontier(x, y):
                    # è½¬æ¢ä¸ºä¸–ç•Œåæ ‡
                    wx, wy = self.map.grid_to_world(x, y)
                    frontiers.append((wx, wy))
        
        return self._cluster_frontiers(frontiers)
    
    def _is_frontier(self, x, y):
        """åˆ¤æ–­æ˜¯å¦ä¸ºå‰æ²¿ç‚¹"""
        grid = self.map.grid
        
        # å½“å‰æ ¼å­å¿…é¡»æ˜¯ç©ºé—²çš„
        if grid[y, x] != 0.0:
            return False
        
        # æ£€æŸ¥8é‚»åŸŸæ˜¯å¦æœ‰æœªçŸ¥åŒºåŸŸ
        for dy in [-1, 0, 1]:
            for dx in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                ny, nx = y + dy, x + dx
                if 0 <= nx < self.map.width and 0 <= ny < self.map.height:
                    if grid[ny, nx] == 0.5:  # æœªçŸ¥
                        return True
        return False
    
    def _cluster_frontiers(self, frontiers, cluster_dist=0.3):
        """èšç±»å‰æ²¿ç‚¹"""
        if not frontiers:
            return []
        
        clusters = []
        used = set()
        
        for i, (x1, y1) in enumerate(frontiers):
            if i in used:
                continue
            
            cluster = [(x1, y1)]
            used.add(i)
            
            for j, (x2, y2) in enumerate(frontiers):
                if j in used:
                    continue
                dist = np.sqrt((x1-x2)**2 + (y1-y2)**2)
                if dist < cluster_dist:
                    cluster.append((x2, y2))
                    used.add(j)
            
            if len(cluster) > 5:  # è¿‡æ»¤å°ç°‡
                # è®¡ç®—ç°‡ä¸­å¿ƒ
                cx = np.mean([p[0] for p in cluster])
                cy = np.mean([p[1] for p in cluster])
                clusters.append((cx, cy))
        
        return clusters
    
    def select_best_frontier(self, frontiers, robot_pose):
        """é€‰æ‹©æœ€ä½³å‰æ²¿ï¼ˆæœ€è¿‘çš„ï¼‰"""
        if not frontiers:
            return None
        
        rx, ry, _ = robot_pose
        best = None
        min_dist = float('inf')
        
        for fx, fy in frontiers:
            dist = np.sqrt((fx-rx)**2 + (fy-ry)**2)
            if dist < min_dist:
                min_dist = dist
                best = (fx, fy)
        
        return best
```

---

### 5.3 A*è·¯å¾„è§„åˆ’

```python
from pathfinding.core.grid import Grid
from pathfinding.finder.a_star import AStarFinder

class PathPlanner:
    """è·¯å¾„è§„åˆ’å™¨"""
    
    def __init__(self, map_obj: OccupancyGridMap):
        self.map = map_obj
    
    def plan_path(self, start, goal):
        """A*è·¯å¾„è§„åˆ’
        
        Args:
            start: (x, y) èµ·ç‚¹ï¼ˆä¸–ç•Œåæ ‡ï¼‰
            goal: (x, y) ç»ˆç‚¹ï¼ˆä¸–ç•Œåæ ‡ï¼‰
        
        Returns:
            è·¯å¾„ç‚¹åˆ—è¡¨ [(x, y), ...]
        """
        # è½¬æ¢ä¸ºæ …æ ¼åæ ‡
        sx, sy = self.map.world_to_grid(*start)
        gx, gy = self.map.world_to_grid(*goal)
        
        # åˆ›å»ºç½‘æ ¼ï¼ˆ0=å¯é€šè¡Œ, 1=éšœç¢ç‰©ï¼‰
        grid_data = (self.map.grid < 0.8).astype(int)
        grid = Grid(matrix=grid_data)
        
        start_node = grid.node(sx, sy)
        end_node = grid.node(gx, gy)
        
        finder = AStarFinder()
        path, runs = finder.find_path(start_node, end_node, grid)
        
        # è½¬æ¢å›ä¸–ç•Œåæ ‡
        world_path = [self.map.grid_to_world(x, y) for x, y in path]
        
        return world_path
```

---

### 5.4 åŠ¨æ€çª—å£æ³•ï¼ˆDWAï¼‰å±€éƒ¨é¿éšœ

```python
class DWA:
    """åŠ¨æ€çª—å£æ³•é¿éšœ"""
    
    def __init__(self):
        self.max_speed = 1.0  # m/s
        self.max_yaw_rate = 40.0  # deg/s
        self.max_accel = 0.5  # m/s^2
        self.v_resolution = 0.1
        self.yaw_rate_resolution = 5.0
        self.dt = 0.1
    
    def plan(self, robot_state, goal, lidar_data):
        """DWAè§„åˆ’
        
        Args:
            robot_state: (x, y, theta, v, omega)
            goal: (gx, gy)
            lidar_data: LidarDataå¯¹è±¡
        
        Returns:
            (v, omega) é€Ÿåº¦å’Œè§’é€Ÿåº¦
        """
        x, y, theta, v, omega = robot_state
        gx, gy = goal
        
        # åŠ¨æ€çª—å£
        v_range = self._calc_dynamic_window(v, omega)
        
        best_v, best_w = 0, 0
        max_score = -float('inf')
        
        # éå†æ‰€æœ‰å¯èƒ½çš„é€Ÿåº¦
        for v_test in np.arange(v_range[0], v_range[1], self.v_resolution):
            for w_test in np.arange(v_range[2], v_range[3], np.deg2rad(self.yaw_rate_resolution)):
                # é¢„æµ‹è½¨è¿¹
                traj = self._predict_trajectory(x, y, theta, v_test, w_test)
                
                # è¯„åˆ†
                heading_score = self._calc_heading_score(traj, gx, gy)
                dist_score = self._calc_dist_score(traj, lidar_data)
                vel_score = v_test / self.max_speed
                
                total_score = 0.5*heading_score + 0.3*dist_score + 0.2*vel_score
                
                if total_score > max_score:
                    max_score = total_score
                    best_v = v_test
                    best_w = w_test
        
        return best_v, best_w
    
    def _calc_dynamic_window(self, v, omega):
        """è®¡ç®—åŠ¨æ€çª—å£"""
        v_min = max(0, v - self.max_accel * self.dt)
        v_max = min(self.max_speed, v + self.max_accel * self.dt)
        w_min = omega - np.deg2rad(self.max_yaw_rate) * self.dt
        w_max = omega + np.deg2rad(self.max_yaw_rate) * self.dt
        return [v_min, v_max, w_min, w_max]
    
    def _predict_trajectory(self, x, y, theta, v, omega):
        """é¢„æµ‹è½¨è¿¹"""
        traj = []
        for _ in range(10):  # é¢„æµ‹1ç§’
            x += v * np.cos(theta) * self.dt
            y += v * np.sin(theta) * self.dt
            theta += omega * self.dt
            traj.append((x, y, theta))
        return traj
    
    def _calc_heading_score(self, traj, gx, gy):
        """è®¡ç®—æœå‘å¾—åˆ†"""
        x, y, theta = traj[-1]
        angle_to_goal = np.arctan2(gy - y, gx - x)
        score = 1.0 - abs(angle_to_goal - theta) / np.pi
        return max(0, score)
    
    def _calc_dist_score(self, traj, lidar_data):
        """è®¡ç®—è·ç¦»å¾—åˆ†ï¼ˆé¿éšœï¼‰"""
        # ç®€åŒ–ï¼šæ£€æŸ¥è½¨è¿¹ç»ˆç‚¹æ˜¯å¦å®‰å…¨
        x, y, _ = traj[-1]
        # TODO: æ ¹æ®lidar_dataè®¡ç®—å¾—åˆ†
        return 1.0
```

---

### 5.5 å®æ—¶å¯è§†åŒ–ï¼ˆMatplotlibï¼‰

```python
import matplotlib.pyplot as plt
import matplotlib.animation as animation

class MapVisualizer:
    """åœ°å›¾å¯è§†åŒ–"""
    
    def __init__(self, map_obj: OccupancyGridMap):
        self.map = map_obj
        self.fig, self.ax = plt.subplots(figsize=(10, 10))
        
        # åˆå§‹åŒ–å›¾åƒ
        self.img = self.ax.imshow(map_obj.grid, cmap='gray_r', 
                                   vmin=0, vmax=1, origin='upper')
        
        # æœºå™¨äººä½ç½®
        self.robot_scatter = self.ax.scatter([], [], c='blue', s=100, marker='o')
        
        # è·¯å¾„
        self.path_line, = self.ax.plot([], [], 'r-', linewidth=2)
        
        # å‰æ²¿ç‚¹
        self.frontier_scatter = self.ax.scatter([], [], c='green', s=50, marker='x')
        
        self.ax.set_title('SLAM Map')
        self.ax.grid(True, alpha=0.3)
    
    def update(self, robot_pose, path=None, frontiers=None):
        """æ›´æ–°æ˜¾ç¤º"""
        # æ›´æ–°åœ°å›¾
        self.img.set_data(self.map.grid)
        
        # æ›´æ–°æœºå™¨äººä½ç½®
        rx, ry, _ = robot_pose
        gx, gy = self.map.world_to_grid(rx, ry)
        self.robot_scatter.set_offsets([[gx, gy]])
        
        # æ›´æ–°è·¯å¾„
        if path:
            path_grid = [self.map.world_to_grid(x, y) for x, y in path]
            px = [p[0] for p in path_grid]
            py = [p[1] for p in path_grid]
            self.path_line.set_data(px, py)
        
        # æ›´æ–°å‰æ²¿ç‚¹
        if frontiers:
            f_grid = [self.map.world_to_grid(x, y) for x, y in frontiers]
            self.frontier_scatter.set_offsets(f_grid)
        
        self.fig.canvas.draw()
        self.fig.canvas.flush_events()
```

---

### 5.6 ä¸»æ§åˆ¶å¾ªç¯

```python
import time

class RobotController:
    """æœºå™¨äººä¸»æ§åˆ¶å™¨"""
    
    def __init__(self, comm: RobotComm):
        self.comm = comm
        self.map = OccupancyGridMap(width=500, height=500, resolution=0.05)
        self.frontier_detector = FrontierDetector(self.map)
        self.path_planner = PathPlanner(self.map)
        self.dwa = DWA()
        self.visualizer = MapVisualizer(self.map)
        
        # å½“å‰çŠ¶æ€
        self.robot_pose = (0.0, 0.0, 0.0)  # x, y, theta
        self.robot_velocity = (0.0, 0.0)    # v, omega
        self.current_path = []
        self.exploration_complete = False
    
    def run(self):
        """ä¸»å¾ªç¯"""
        print("[ROBOT] Starting autonomous exploration...")
        
        # å¯åŠ¨é€šä¿¡
        self.comm.on_lidar_update = self.on_lidar_received
        self.comm.on_pose_update = self.on_pose_received
        self.comm.start()
        
        # æ˜¾ç¤ºçª—å£
        plt.ion()
        plt.show()
        
        while not self.exploration_complete:
            # 1. è¯·æ±‚é›·è¾¾æ‰«æ
            self.comm.request_lidar_scan()
            time.sleep(1)  # ç­‰å¾…æ‰«æå®Œæˆ
            
            # 2. æ£€æµ‹å‰æ²¿
            frontiers = self.frontier_detector.find_frontiers()
            
            if not frontiers:
                print("[ROBOT] Exploration complete!")
                self.exploration_complete = True
                break
            
            # 3. é€‰æ‹©ç›®æ ‡å‰æ²¿
            target = self.frontier_detector.select_best_frontier(
                frontiers, self.robot_pose
            )
            
            if target:
                print(f"[ROBOT] Target frontier: {target}")
                
                # 4. è§„åˆ’è·¯å¾„
                self.current_path = self.path_planner.plan_path(
                    self.robot_pose[:2], target
                )
                
                # 5. æ‰§è¡Œå¯¼èˆª
                self.navigate_to_goal(target)
            
            # 6. æ›´æ–°å¯è§†åŒ–
            self.visualizer.update(self.robot_pose, self.current_path, frontiers)
            time.sleep(0.1)
        
        print("[ROBOT] Mission complete!")
        self.comm.stop()
    
    def on_lidar_received(self, lidar_data: LidarData):
        """é›·è¾¾æ•°æ®å›è°ƒ"""
        self.map.update_with_lidar(lidar_data, self.robot_pose)
        print(f"[LIDAR] Updated map with {lidar_data.total_points} points")
    
    def on_pose_received(self, pose_data: PoseData):
        """ä½å§¿æ•°æ®å›è°ƒ"""
        self.robot_pose = (pose_data.x, pose_data.y, np.deg2rad(pose_data.theta))
    
    def navigate_to_goal(self, goal):
        """å¯¼èˆªåˆ°ç›®æ ‡ç‚¹"""
        print(f"[NAV] Navigating to {goal}")
        
        while True:
            # è®¡ç®—è·ç¦»
            rx, ry, rtheta = self.robot_pose
            dist = np.sqrt((goal[0]-rx)**2 + (goal[1]-ry)**2)
            
            if dist < 0.2:  # åˆ°è¾¾ç›®æ ‡
                self.comm.send_mode_command(0)  # åœæ­¢
                print("[NAV] Goal reached!")
                break
            
            # DWAé¿éšœ
            v, omega = self.dwa.plan(
                (*self.robot_pose, *self.robot_velocity),
                goal,
                self.comm.latest_lidar
            )
            
            # å‘é€é€Ÿåº¦æŒ‡ä»¤
            # è¿™é‡Œéœ€è¦è½¬æ¢ä¸ºå·¦å³è½®é€Ÿåº¦
            wheel_base = 0.2  # è½®è·ï¼ˆç±³ï¼‰
            left_speed = v - omega * wheel_base / 2
            right_speed = v + omega * wheel_base / 2
            
            self.comm.send_speed_command(left_speed, right_speed)
            time.sleep(0.1)
```

---

### 5.7 å®Œæ•´ç¨‹åºå…¥å£

```python
# main.py

if __name__ == "__main__":
    # é…ç½®ä¸²å£
    PORT = 'COM5'  # Windows
    # PORT = '/dev/ttyUSB0'  # Linux
    BAUDRATE = 115200
    
    # åˆ›å»ºé€šä¿¡å¯¹è±¡
    comm = RobotComm(port=PORT, baudrate=BAUDRATE)
    
    # åˆ›å»ºæ§åˆ¶å™¨
    controller = RobotController(comm)
    
    try:
        # è¿è¡Œä¸»å¾ªç¯
        controller.run()
    except KeyboardInterrupt:
        print("\n[MAIN] Interrupted by user")
    finally:
        comm.stop()
        print("[MAIN] Program exit")
```

---

## 6. å¼€å‘ä»»åŠ¡æ¸…å•ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰

### ğŸ“Œ é˜¶æ®µä¸€ï¼šåŸºç¡€é€šä¿¡ï¼ˆç¬¬1-2å‘¨ï¼‰

- [ ] **1.1 ç¯å¢ƒæ­å»º**
  - [ ] å®‰è£…Python 3.8+
  - [ ] å®‰è£…ä¾èµ–åº“ï¼ˆ`pip install -r requirements.txt`ï¼‰
  - [ ] é…ç½®å¼€å‘IDEï¼ˆVSCode/PyCharmï¼‰
  - [ ] æ­å»ºç‰ˆæœ¬æ§åˆ¶ï¼ˆGitï¼‰

- [ ] **1.2 é€šä¿¡æ¨¡å—å¼€å‘**
  - [ ] å®ç° `RobotComm` ç±»ï¼ˆä¸²å£é€šä¿¡ï¼‰
  - [ ] å®ç°æ•°æ®åŒ…è§£æï¼ˆJSON + CSVï¼‰
  - [ ] å®ç°å›è°ƒæœºåˆ¶
  - [ ] é€šä¿¡ç¨³å®šæ€§æµ‹è¯•

- [ ] **1.3 å›ºä»¶ç«¯é…åˆ**
  - [ ] ä¸å›ºä»¶ç»„ç¡®å®šé€šä¿¡åè®®
  - [ ] å®ç°STM32ç«¯æ•°æ®å‘é€å‡½æ•°
  - [ ] è”è°ƒæµ‹è¯•é›·è¾¾æ•°æ®ä¼ è¾“
  - [ ] è”è°ƒæµ‹è¯•MPU/é‡Œç¨‹è®¡æ•°æ®

**éªŒæ”¶æ ‡å‡†ï¼š** PCèƒ½æ­£å¸¸æ¥æ”¶å’Œè§£ææ‰€æœ‰ä¼ æ„Ÿå™¨æ•°æ®

---

### ğŸ“Œ é˜¶æ®µäºŒï¼šSLAMå»ºå›¾ï¼ˆç¬¬3-4å‘¨ï¼‰

- [ ] **2.1 å æ®æ …æ ¼åœ°å›¾**
  - [ ] å®ç° `OccupancyGridMap` ç±»
  - [ ] å®ç°ä¸–ç•Œåæ ‡â†”æ …æ ¼åæ ‡è½¬æ¢
  - [ ] å®ç°é›·è¾¾æ•°æ®æ›´æ–°åœ°å›¾
  - [ ] å®ç°å°„çº¿è¿½è¸ªç®—æ³•

- [ ] **2.2 å¯è§†åŒ–ç³»ç»Ÿ**
  - [ ] å®ç° `MapVisualizer` ç±»ï¼ˆMatplotlibï¼‰
  - [ ] å®æ—¶æ˜¾ç¤ºåœ°å›¾
  - [ ] æ˜¾ç¤ºæœºå™¨äººä½ç½®å’Œæœå‘
  - [ ] æ˜¾ç¤ºé›·è¾¾æ‰«æç‚¹äº‘

- [ ] **2.3 æµ‹è¯•ä¸è°ƒè¯•**
  - [ ] é™æ€ç¯å¢ƒå»ºå›¾æµ‹è¯•
  - [ ] åŠ¨æ€ç¯å¢ƒå»ºå›¾æµ‹è¯•
  - [ ] åœ°å›¾ç²¾åº¦éªŒè¯

**éªŒæ”¶æ ‡å‡†ï¼š** èƒ½å®æ—¶æ„å»ºå’Œæ˜¾ç¤ºç¯å¢ƒåœ°å›¾

---

### ğŸ“Œ é˜¶æ®µä¸‰ï¼šå¯¼èˆªè§„åˆ’ï¼ˆç¬¬5-7å‘¨ï¼‰

- [ ] **3.1 Frontieræ¢ç´¢**
  - [ ] å®ç° `FrontierDetector` ç±»
  - [ ] å‰æ²¿ç‚¹æ£€æµ‹ç®—æ³•
  - [ ] å‰æ²¿ç‚¹èšç±»ç®—æ³•
  - [ ] ç›®æ ‡å‰æ²¿é€‰æ‹©ç­–ç•¥

- [ ] **3.2 è·¯å¾„è§„åˆ’**
  - [ ] é›†æˆA*ç®—æ³•ï¼ˆpathfindingåº“ï¼‰
  - [ ] å®ç° `PathPlanner` ç±»
  - [ ] è·¯å¾„å¹³æ»‘å¤„ç†
  - [ ] è·¯å¾„å¯è§†åŒ–

- [ ] **3.3 DWAå±€éƒ¨é¿éšœ**
  - [ ] å®ç° `DWA` ç±»
  - [ ] åŠ¨æ€çª—å£è®¡ç®—
  - [ ] è½¨è¿¹è¯„åˆ†å‡½æ•°
  - [ ] é€Ÿåº¦æŒ‡ä»¤ç”Ÿæˆ

- [ ] **3.4 ä¸»æ§åˆ¶å¾ªç¯**
  - [ ] å®ç° `RobotController` ç±»
  - [ ] æ¢ç´¢â†’è§„åˆ’â†’æ‰§è¡Œæµç¨‹
  - [ ] çŠ¶æ€æœºç®¡ç†
  - [ ] å¼‚å¸¸å¤„ç†æœºåˆ¶

**éªŒæ”¶æ ‡å‡†ï¼š** æœºå™¨äººèƒ½è‡ªä¸»æ¢ç´¢æœªçŸ¥ç¯å¢ƒå¹¶è¿”å›èµ·ç‚¹

---

### ğŸ“Œ é˜¶æ®µå››ï¼šç³»ç»Ÿé›†æˆä¸ä¼˜åŒ–ï¼ˆç¬¬8-9å‘¨ï¼‰

- [ ] **4.1 ç³»ç»Ÿé›†æˆ**
  - [ ] æ‰€æœ‰æ¨¡å—è”è°ƒ
  - [ ] å®é™…è¿·å®«ç¯å¢ƒæµ‹è¯•
  - [ ] é•¿æ—¶é—´è¿è¡Œç¨³å®šæ€§æµ‹è¯•

- [ ] **4.2 æ€§èƒ½ä¼˜åŒ–**
  - [ ] SLAMè®¡ç®—ä¼˜åŒ–ï¼ˆNumPyå‘é‡åŒ–ï¼‰
  - [ ] Frontieræ£€æµ‹åŠ é€Ÿ
  - [ ] å¯è§†åŒ–å¸§ç‡ä¼˜åŒ–
  - [ ] å†…å­˜ä½¿ç”¨ä¼˜åŒ–

- [ ] **4.3 é²æ£’æ€§æå‡**
  - [ ] é€šä¿¡ä¸¢åŒ…å¤„ç†
  - [ ] ä¼ æ„Ÿå™¨æ•°æ®å¼‚å¸¸å¤„ç†
  - [ ] è·¯å¾„è§„åˆ’å¤±è´¥æ¢å¤
  - [ ] å¡æ­»æ£€æµ‹ä¸è„±å›°

- [ ] **4.4 æ–‡æ¡£ä¸äº¤ä»˜**
  - [ ] ä»£ç æ³¨é‡Šå®Œå–„
  - [ ] ç”¨æˆ·ä½¿ç”¨æ‰‹å†Œ
  - [ ] APIæ–‡æ¡£
  - [ ] æ¼”ç¤ºè§†é¢‘åˆ¶ä½œ

**éªŒæ”¶æ ‡å‡†ï¼š** ç³»ç»Ÿç¨³å®šè¿è¡Œï¼ŒæˆåŠŸç‡>90%

---

## 7. æµ‹è¯•ä¸è°ƒè¯•

### 7.1 å•å…ƒæµ‹è¯•ç¤ºä¾‹

```python
# tests/test_occupancy_map.py

import pytest
import numpy as np
from slam.occupancy_map import OccupancyGridMap

def test_world_to_grid_conversion():
    """æµ‹è¯•åæ ‡è½¬æ¢"""
    map_obj = OccupancyGridMap(width=100, height=100, resolution=0.1)
    
    # æµ‹è¯•ä¸­å¿ƒç‚¹
    gx, gy = map_obj.world_to_grid(0, 0)
    assert gx == 50 and gy == 50
    
    # æµ‹è¯•åç§»ç‚¹
    gx, gy = map_obj.world_to_grid(1.0, 0.5)
    assert gx == 60 and gy == 45

def test_ray_tracing():
    """æµ‹è¯•å°„çº¿è¿½è¸ª"""
    map_obj = OccupancyGridMap(width=100, height=100, resolution=0.1)
    
    # å°„çº¿è¿½è¸ªåº”è¯¥æ ‡è®°é€”å¾„æ ¼å­ä¸ºç©ºé—²
    map_obj._ray_trace(0, 0, 1.0, 1.0, mark_free=True)
    
    # æ£€æŸ¥è·¯å¾„ä¸Šçš„æ ¼å­
    gx, gy = map_obj.world_to_grid(0.5, 0.5)
    assert map_obj.grid[gy, gx] == 0.0  # ç©ºé—²
```

---

### 7.2 é€šä¿¡æµ‹è¯•è„šæœ¬

```python
# tests/test_communication.py

from communication.robot_comm import RobotComm
import time

def test_lidar_reception():
    """æµ‹è¯•é›·è¾¾æ•°æ®æ¥æ”¶"""
    comm = RobotComm(port='COM5', baudrate=115200)
    comm.start()
    
    received = False
    
    def on_lidar(data):
        nonlocal received
        print(f"[TEST] Received {data.total_points} lidar points")
        received = True
    
    comm.on_lidar_update = on_lidar
    comm.request_lidar_scan()
    
    # ç­‰å¾…5ç§’
    for _ in range(50):
        time.sleep(0.1)
        if received:
            break
    
    assert received, "æœªæ”¶åˆ°é›·è¾¾æ•°æ®"
    comm.stop()

if __name__ == "__main__":
    test_lidar_reception()
```

---

### 7.3 è°ƒè¯•æŠ€å·§

#### é—®é¢˜1ï¼šåœ°å›¾æ„å»ºä¸å‡†ç¡®

**æ’æŸ¥æ­¥éª¤ï¼š**
```python
# 1. æ£€æŸ¥é›·è¾¾æ•°æ®è´¨é‡
def debug_lidar_data(lidar_data):
    print(f"æ€»ç‚¹æ•°: {lidar_data.total_points}")
    print(f"è§’åº¦è¦†ç›–: {lidar_data.angle_coverage}Â°")
    for sector in lidar_data.sectors:
        print(f"æ‰‡åŒº{sector['sector_id']}: {sector['count']}ç‚¹, æœ€è¿‘{sector['min_dist']:.2f}m")

# 2. å¯è§†åŒ–å°„çº¿è¿½è¸ª
def visualize_ray_trace(map_obj):
    plt.figure()
    plt.imshow(map_obj.grid, cmap='gray_r')
    plt.colorbar()
    plt.title("Ray Tracing Result")
    plt.show()

# 3. æ£€æŸ¥åæ ‡è½¬æ¢
def test_coordinate_transform(map_obj):
    test_points = [(0, 0), (1, 0), (0, 1), (-1, -1)]
    for wx, wy in test_points:
        gx, gy = map_obj.world_to_grid(wx, wy)
        wx2, wy2 = map_obj.grid_to_world(gx, gy)
        print(f"World({wx},{wy}) -> Grid({gx},{gy}) -> World({wx2:.2f},{wy2:.2f})")
```

---

#### é—®é¢˜2ï¼šè·¯å¾„è§„åˆ’å¤±è´¥

**è§£å†³æ–¹æ¡ˆï¼š**
```python
def debug_path_planning(planner, start, goal):
    # æ£€æŸ¥èµ·ç‚¹å’Œç»ˆç‚¹æ˜¯å¦åœ¨åœ°å›¾å†…
    sx, sy = planner.map.world_to_grid(*start)
    gx, gy = planner.map.world_to_grid(*goal)
    
    print(f"èµ·ç‚¹æ …æ ¼åæ ‡: ({sx}, {sy})")
    print(f"ç»ˆç‚¹æ …æ ¼åæ ‡: ({gx}, {gy})")
    
    # æ£€æŸ¥æ˜¯å¦åœ¨éšœç¢ç‰©ä¸Š
    if planner.map.grid[sy, sx] >= 0.8:
        print("âš ï¸ èµ·ç‚¹åœ¨éšœç¢ç‰©ä¸Šï¼")
    if planner.map.grid[gy, gx] >= 0.8:
        print("âš ï¸ ç»ˆç‚¹åœ¨éšœç¢ç‰©ä¸Šï¼")
    
    # å¯è§†åŒ–åœ°å›¾å’Œèµ·ç»ˆç‚¹
    plt.figure()
    plt.imshow(planner.map.grid, cmap='gray_r')
    plt.scatter([sx], [sy], c='blue', s=100, label='Start')
    plt.scatter([gx], [gy], c='red', s=100, label='Goal')
    plt.legend()
    plt.show()
```

---

#### é—®é¢˜3ï¼šé€šä¿¡å»¶è¿Ÿé«˜

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**
```python
# 1. å‡å°‘JSONæ•°æ®å¤§å°ï¼ˆä¸å‘é€raw_pointsï¼‰
# 2. æé«˜ä¸²å£æ³¢ç‰¹ç‡åˆ°230400æˆ–460800
# 3. ä½¿ç”¨äºŒè¿›åˆ¶æ ¼å¼ä»£æ›¿JSON

# ç¤ºä¾‹ï¼šäºŒè¿›åˆ¶æ ¼å¼
import struct

def pack_lidar_binary(sectors):
    """å°†é›·è¾¾æ•°æ®æ‰“åŒ…ä¸ºäºŒè¿›åˆ¶"""
    # æ ¼å¼: [header(2B)] + [sector_count(1B)] + [sectors...]
    # æ¯ä¸ªsector: [id(1B), count(1B), min_dist(4B), avg_dist(4B)]
    data = b'LD'  # å¤´éƒ¨
    data += struct.pack('B', len(sectors))
    for s in sectors:
        data += struct.pack('BBff', s['sector_id'], s['count'], 
                           s['min_dist'], s['avg_dist'])
    return data
```

---

## 8. é¡¹ç›®æ–‡ä»¶ç»“æ„

```
robot_control/
â”œâ”€â”€ requirements.txt           # ä¾èµ–åº“åˆ—è¡¨
â”œâ”€â”€ main.py                   # ä¸»ç¨‹åºå…¥å£
â”œâ”€â”€ config.py                 # é…ç½®æ–‡ä»¶
â”œâ”€â”€ communication/            # é€šä¿¡æ¨¡å—
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ robot_comm.py         # é€šä¿¡ç±»
â”‚   â””â”€â”€ protocol.py           # åè®®å®šä¹‰
â”œâ”€â”€ slam/                     # SLAMæ¨¡å—
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ occupancy_map.py      # å æ®æ …æ ¼åœ°å›¾
â”‚   â””â”€â”€ frontier_detector.py  # Frontieræ£€æµ‹
â”œâ”€â”€ navigation/               # å¯¼èˆªæ¨¡å—
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ path_planner.py       # A*è·¯å¾„è§„åˆ’
â”‚   â”œâ”€â”€ dwa.py                # åŠ¨æ€çª—å£é¿éšœ
â”‚   â””â”€â”€ controller.py         # ä¸»æ§åˆ¶å™¨
â”œâ”€â”€ visualization/            # å¯è§†åŒ–æ¨¡å—
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ map_visualizer.py     # åœ°å›¾å¯è§†åŒ–
â”œâ”€â”€ utils/                    # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ math_utils.py         # æ•°å­¦å·¥å…·
â”‚   â””â”€â”€ logger.py             # æ—¥å¿—å·¥å…·
â””â”€â”€ tests/                    # æµ‹è¯•ä»£ç 
    â”œâ”€â”€ test_communication.py
    â”œâ”€â”€ test_slam.py
    â””â”€â”€ test_navigation.py
```

---

## 9. å…³é”®æŠ€æœ¯æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ

### 9.1 å®æ—¶æ€§è¦æ±‚

**æŒ‘æˆ˜ï¼š** SLAMè®¡ç®—ã€è·¯å¾„è§„åˆ’éœ€è¦åœ¨å®æ—¶å†…å®Œæˆï¼ˆ<100msï¼‰

**è§£å†³æ–¹æ¡ˆï¼š**
- NumPyå‘é‡åŒ–è®¡ç®—ï¼ˆé¿å…Pythonå¾ªç¯ï¼‰
- é™ä½åœ°å›¾åˆ†è¾¨ç‡ï¼ˆ0.05mâ†’0.1mï¼‰
- é™åˆ¶Frontieræ£€æµ‹èŒƒå›´
- ä½¿ç”¨C++æ‰©å±•ï¼ˆå¦‚Cythonï¼‰åŠ é€Ÿå…³é”®ç®—æ³•

```python
# ä¼˜åŒ–ç¤ºä¾‹ï¼šå‘é‡åŒ–å°„çº¿è¿½è¸ª
def fast_ray_trace(self, start, end, mark_free=True):
    # ä½¿ç”¨NumPyå‘é‡æ“ä½œä»£æ›¿å¾ªç¯
    points = np.linspace(start, end, num=50)
    grid_points = self.world_to_grid_vectorized(points)
    self.grid[grid_points[:, 1], grid_points[:, 0]] = 0.0
```

---

### 9.2 é€šä¿¡å¯é æ€§

**æŒ‘æˆ˜ï¼š** è“ç‰™é€šä¿¡å¯èƒ½å­˜åœ¨å»¶è¿Ÿå’Œä¸¢åŒ…

**è§£å†³æ–¹æ¡ˆï¼š**
```python
class ReliableComm:
    """å¯é é€šä¿¡åŒ…è£…"""
    
    def __init__(self, base_comm):
        self.comm = base_comm
        self.timeout = 2.0
        self.retry_count = 3
    
    def send_with_ack(self, data):
        """å¸¦ç¡®è®¤çš„å‘é€"""
        for i in range(self.retry_count):
            self.comm.send(data)
            ack = self.comm.wait_for_ack(timeout=self.timeout)
            if ack:
                return True
        return False
    
    def receive_with_checksum(self):
        """å¸¦æ ¡éªŒå’Œçš„æ¥æ”¶"""
        data = self.comm.receive()
        if self._verify_checksum(data):
            return data
        else:
            self.comm.request_retransmit()
            return None
```

---

### 9.3 å®šä½ç²¾åº¦

**æŒ‘æˆ˜ï¼š** ä»…ç”¨é›·è¾¾å’Œè½®é€Ÿè®¡ï¼Œå®šä½è¯¯å·®ç´¯ç§¯

**è§£å†³æ–¹æ¡ˆï¼š**
```python
class OdometryCorrection:
    """é‡Œç¨‹è®¡è¯¯å·®ä¿®æ­£"""
    
    def correct_with_lidar(self, odom_pose, lidar_pose):
        """ä½¿ç”¨é›·è¾¾åŒ¹é…ä¿®æ­£é‡Œç¨‹è®¡"""
        # æ‰«æåŒ¹é…ï¼ˆICPç®—æ³•ç®€åŒ–ç‰ˆï¼‰
        weight_odom = 0.7
        weight_lidar = 0.3
        
        corrected_x = weight_odom * odom_pose[0] + weight_lidar * lidar_pose[0]
        corrected_y = weight_odom * odom_pose[1] + weight_lidar * lidar_pose[1]
        corrected_theta = odom_pose[2]  # è§’åº¦ä¸»è¦é é‡Œç¨‹è®¡
        
        return (corrected_x, corrected_y, corrected_theta)
```

---

### 9.4 ç¯å¢ƒé€‚åº”æ€§

**æŒ‘æˆ˜ï¼š** å¤æ‚è¿·å®«ç¯å¢ƒï¼ˆæ­»è§’ã€å›è·¯ï¼‰

**è§£å†³æ–¹æ¡ˆï¼š**
```python
class AdaptiveExplorer:
    """è‡ªé€‚åº”æ¢ç´¢ç­–ç•¥"""
    
    def __init__(self):
        self.stuck_threshold = 5  # 5æ¬¡å°è¯•
        self.stuck_count = 0
        self.last_pose = None
    
    def select_frontier_adaptive(self, frontiers, robot_pose):
        """è‡ªé€‚åº”é€‰æ‹©ç­–ç•¥"""
        # æ£€æµ‹æ˜¯å¦å¡ä½
        if self._is_stuck(robot_pose):
            self.stuck_count += 1
            
            if self.stuck_count > self.stuck_threshold:
                # å¡ä½äº†ï¼Œé€‰æ‹©æœ€è¿œçš„frontier
                return self._select_farthest(frontiers, robot_pose)
        else:
            self.stuck_count = 0
            # æ­£å¸¸ï¼Œé€‰æ‹©æœ€è¿‘çš„
            return self._select_nearest(frontiers, robot_pose)
        
        self.last_pose = robot_pose
    
    def _is_stuck(self, current_pose):
        """æ£€æµ‹æ˜¯å¦å¡ä½"""
        if self.last_pose is None:
            return False
        dist = np.hypot(current_pose[0] - self.last_pose[0],
                       current_pose[1] - self.last_pose[1])
        return dist < 0.1  # ç§»åŠ¨è·ç¦»<10cm
```

---

## 10. å¿«é€Ÿå¼€å§‹æŒ‡å—

### 10.1 5åˆ†é’Ÿå¿«é€Ÿéƒ¨ç½²

```bash
# 1. å…‹éš†é¡¹ç›®ï¼ˆå‡è®¾å·²åˆ›å»ºï¼‰
git clone <repository_url>
cd robot_control

# 2. åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
python -m venv venv
venv\Scripts\activate  # Windows
# source venv/bin/activate  # Linux/Mac

# 3. å®‰è£…ä¾èµ–
pip install -r requirements.txt

# 4. é…ç½®ä¸²å£
# ç¼–è¾‘ config.pyï¼Œè®¾ç½®æ­£ç¡®çš„COMå£
PORT = 'COM5'  # ä¿®æ”¹ä¸ºå®é™…ç«¯å£
BAUDRATE = 115200

# 5. æµ‹è¯•é€šä¿¡
python tests/test_communication.py

# 6. è¿è¡Œä¸»ç¨‹åº
python main.py
```

---

### 10.2 ç¬¬ä¸€æ¬¡è¿è¡Œæ£€æŸ¥æ¸…å•

- [ ] âœ… STM32å›ºä»¶å·²çƒ§å½•å¹¶è¿è¡Œ
- [ ] âœ… è“ç‰™æ¨¡å—é…å¯¹æˆåŠŸ
- [ ] âœ… Pythonç¯å¢ƒå’Œä¾èµ–å®‰è£…å®Œæˆ
- [ ] âœ… ä¸²å£å·é…ç½®æ­£ç¡®
- [ ] âœ… é›·è¾¾èƒ½æ­£å¸¸æ‰«æï¼ˆå‘é€`A`å‘½ä»¤æµ‹è¯•ï¼‰
- [ ] âœ… MPUæ•°æ®å®æ—¶æ›´æ–°
- [ ] âœ… é‡Œç¨‹è®¡æ•°æ®æ­£å¸¸
- [ ] âœ… PCèƒ½æ¥æ”¶å¹¶è§£ææ‰€æœ‰æ•°æ®

---

## 11. å¸¸è§é—®é¢˜FAQ

### Q1: ä¸ºä»€ä¹ˆé€‰æ‹©è‡ªå®ç°SLAMè€Œä¸ç”¨ROSï¼Ÿ

**ç­”ï¼š** 
- âœ… **å­¦ä¹ ç›®çš„**ï¼šæ›´æ·±å…¥ç†è§£SLAMåŸç†
- âœ… **è½»é‡çº§**ï¼šæ— éœ€åºå¤§çš„ROSä¾èµ–
- âœ… **è·¨å¹³å°**ï¼šWindows/Linuxéƒ½èƒ½è¿è¡Œ
- âœ… **çµæ´»æ€§**ï¼šæ–¹ä¾¿è°ƒè¯•å’Œå®šåˆ¶

---

### Q2: åœ°å›¾åˆ†è¾¨ç‡å¦‚ä½•é€‰æ‹©ï¼Ÿ

**ç­”ï¼š**
```python
# åˆ†è¾¨ç‡æƒè¡¡
resolution = 0.05  # 5cm/æ ¼
# ä¼˜ç‚¹ï¼šç²¾ç¡®ï¼Œé€‚åˆå°ç‰©ä½“æ£€æµ‹
# ç¼ºç‚¹ï¼šå†…å­˜å ç”¨å¤§ï¼Œè®¡ç®—æ…¢

resolution = 0.1   # 10cm/æ ¼ âœ… æ¨è
# ä¼˜ç‚¹ï¼šé€‚ä¸­ï¼Œæ€§èƒ½å’Œç²¾åº¦å¹³è¡¡
# ç¼ºç‚¹ï¼šå¯èƒ½é—æ¼å°éšœç¢ç‰©

resolution = 0.2   # 20cm/æ ¼
# ä¼˜ç‚¹ï¼šå¿«é€Ÿï¼Œå†…å­˜çœ
# ç¼ºç‚¹ï¼šç²¾åº¦ä½ï¼Œä¸é€‚åˆç‹­çª„é€šé“
```

---

### Q3: å¦‚ä½•è°ƒè¯•Frontieræ£€æµ‹ä¸å·¥ä½œï¼Ÿ

**ç­”ï¼š**
```python
# è°ƒè¯•ä»£ç 
def debug_frontiers(self):
    grid = self.map.grid
    
    # 1. æ£€æŸ¥åœ°å›¾çŠ¶æ€
    unknown_ratio = np.sum(grid == 0.5) / grid.size
    print(f"æœªçŸ¥åŒºåŸŸå æ¯”: {unknown_ratio*100:.1f}%")
    
    if unknown_ratio < 0.1:
        print("âš ï¸ åœ°å›¾å‡ ä¹å®Œå…¨æ¢ç´¢ï¼Œæ— å‰æ²¿ç‚¹")
    
    # 2. å¯è§†åŒ–å‰æ²¿ç‚¹
    frontiers = self.find_frontiers()
    if frontiers:
        plt.figure()
        plt.imshow(grid, cmap='gray_r')
        f_grid = [self.map.world_to_grid(x, y) for x, y in frontiers]
        plt.scatter([p[0] for p in f_grid], [p[1] for p in f_grid], 
                   c='red', s=50)
        plt.title(f"Found {len(frontiers)} frontiers")
        plt.show()
```

---

### Q4: è·¯å¾„è§„åˆ’æ€»æ˜¯å¤±è´¥æ€ä¹ˆåŠï¼Ÿ

**ç­”ï¼š** æŒ‰é¡ºåºæ£€æŸ¥ï¼š

1. **èµ·ç‚¹/ç»ˆç‚¹æ˜¯å¦åˆæ³•ï¼Ÿ**
   ```python
   if map_obj.grid[start_y, start_x] >= 0.8:
       print("èµ·ç‚¹åœ¨éšœç¢ç‰©ä¸Šï¼")
   ```

2. **åœ°å›¾æ˜¯å¦è¿é€šï¼Ÿ**
   - æ£€æŸ¥æ˜¯å¦æœ‰å­¤å²›
   - å°è¯•ä»èµ·ç‚¹flood fillåˆ°ç»ˆç‚¹

3. **éšœç¢ç‰©è†¨èƒ€ï¼Ÿ**
   ```python
   # è†¨èƒ€éšœç¢ç‰©ï¼ˆå¢åŠ å®‰å…¨è£•åº¦ï¼‰
   from scipy.ndimage import binary_dilation
   inflated_map = binary_dilation(grid > 0.8, iterations=2)
   ```

---

## 12. æ€»ç»“ä¸å±•æœ›

### 12.1 é¡¹ç›®æ€»ç»“

è½¯ä»¶ç»„çš„æ ¸å¿ƒä»»åŠ¡æ˜¯å¼€å‘æ™ºèƒ½å°è½¦çš„"å¤§è„‘"â€”â€”ä¸»æœºç«¯Pythonæ§åˆ¶ç³»ç»Ÿã€‚é€šè¿‡æ•´åˆç°ä»£åŒ–çš„SLAMã€è·¯å¾„è§„åˆ’å’Œé€šä¿¡æŠ€æœ¯ï¼Œå®ç°æœºå™¨äººåœ¨æœªçŸ¥ç¯å¢ƒä¸­çš„è‡ªä¸»æ¢ç´¢ã€å®šä½å’Œå¯¼èˆªèƒ½åŠ›ã€‚

**å…³é”®æˆåŠŸå› ç´ ï¼š**

1. âœ… **æŠ€æœ¯æ ˆç°ä»£åŒ–**ï¼šæ‘’å¼ƒè¿‡æ—¶åº“ï¼Œé‡‡ç”¨NumPyã€Matplotlibç­‰æˆç†Ÿæ–¹æ¡ˆ
2. âœ… **é€šä¿¡åè®®æ¸…æ™°**ï¼šJSON+CSVæ··åˆæ ¼å¼ï¼Œæ˜“äºè§£æå’Œè°ƒè¯•
3. âœ… **ä»£ç æ¶æ„æ¸…æ™°**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼Œä¾¿äºå¼€å‘å’Œæµ‹è¯•
4. âœ… **æ–‡æ¡£è¯¦ç»†å®Œå–„**ï¼šä»ç†è®ºåˆ°å®è·µï¼Œä»ä»£ç åˆ°è°ƒè¯•ï¼Œå…¨è¦†ç›–

**é¢„æœŸæˆæœï¼š**

- å®Œæ•´çš„ä¸»æœºç«¯æ§åˆ¶ç³»ç»Ÿï¼ˆ~2000è¡ŒPythonä»£ç ï¼‰
- å®æ—¶SLAMåœ°å›¾æ„å»ºå’Œå¯è§†åŒ–ï¼ˆ30fps+ï¼‰
- è‡ªä¸»å¯¼èˆªå’Œè·¯å¾„è§„åˆ’èƒ½åŠ›ï¼ˆè¿·å®«æ¢ç´¢æˆåŠŸç‡>90%ï¼‰
- å¯é çš„è“ç‰™é€šä¿¡æœºåˆ¶ï¼ˆå»¶è¿Ÿ<50msï¼‰
- å®Œå–„çš„æµ‹è¯•å’Œæ–‡æ¡£

### 12.2 ä¸‹ä¸€æ­¥è®¡åˆ’

**çŸ­æœŸç›®æ ‡ï¼ˆ1-2å‘¨ï¼‰ï¼š**
- [ ] å®ŒæˆåŸºç¡€é€šä¿¡æ¨¡å—
- [ ] å®ç°ç®€å•SLAMå»ºå›¾
- [ ] å®Œæˆå¯è§†åŒ–ç•Œé¢

**ä¸­æœŸç›®æ ‡ï¼ˆ3-6å‘¨ï¼‰ï¼š**
- [ ] å®ŒæˆFrontieræ¢ç´¢ç®—æ³•
- [ ] é›†æˆA*å’ŒDWAè·¯å¾„è§„åˆ’
- [ ] å®ç°å®Œæ•´å¯¼èˆªå¾ªç¯

**é•¿æœŸç›®æ ‡ï¼ˆ7-9å‘¨ï¼‰ï¼š**
- [ ] ç³»ç»Ÿä¼˜åŒ–å’Œé²æ£’æ€§æå‡
- [ ] å®é™…ç¯å¢ƒæµ‹è¯•å’Œè°ƒè¯•
- [ ] æ–‡æ¡£å®Œå–„å’Œäº¤ä»˜

### 12.3 å¯æ‰©å±•åŠŸèƒ½

**å¦‚æœæ—¶é—´å……è£•ï¼Œå¯ä»¥è€ƒè™‘ï¼š**

1. **é«˜çº§SLAM**ï¼šç²’å­æ»¤æ³¢ã€å›¾ä¼˜åŒ–
2. **æ·±åº¦å­¦ä¹ **ï¼šç›®æ ‡è¯†åˆ«ã€è¯­ä¹‰SLAM
3. **å¤šæœºå™¨äººååŒ**ï¼šåœ°å›¾å…±äº«ã€ååŒæ¢ç´¢
4. **Webç›‘æ§ç•Œé¢**ï¼šè¿œç¨‹ç›‘æ§å’Œæ§åˆ¶
5. **VRå¯è§†åŒ–**ï¼šæ²‰æµ¸å¼åœ°å›¾æŸ¥çœ‹

---

## 13. å‚è€ƒèµ„æ–™

### 13.1 ç®—æ³•æ–‡çŒ®

- **Frontieræ¢æµ‹**ï¼šYamauchi, B. (1997). "A frontier-based approach for autonomous exploration"
- **A*ç®—æ³•**ï¼šHart, P. E., et al. (1968). "A Formal Basis for the Heuristic Determination of Minimum Cost Paths"
- **DWAç®—æ³•**ï¼šFox, D., et al. (1997). "The Dynamic Window Approach to Collision Avoidance"
- **å æ®æ …æ ¼åœ°å›¾**ï¼šElfes, A. (1989). "Using occupancy grids for mobile robot perception and navigation"

### 13.2 å¼€æºé¡¹ç›®å‚è€ƒ

- **PythonRobotics** - https://github.com/AtsushiSakai/PythonRobotics
  - A*ã€DWAã€Frontierç­‰ç®—æ³•å‚è€ƒå®ç°
- **pathfinding** - https://pypi.org/project/pathfinding/
  - A*è·¯å¾„è§„åˆ’åº“
- **NumPy** - https://numpy.org/doc/
  - æ•°å€¼è®¡ç®—æ–‡æ¡£
- **Matplotlib** - https://matplotlib.org/
  - å¯è§†åŒ–æ–‡æ¡£

### 13.3 ç›¸å…³æ–‡æ¡£

- **å›ºä»¶ç«¯æ¥å£æ–‡æ¡£**ï¼š`README.md` - ä¸²å£æŒ‡ä»¤é€ŸæŸ¥æ‰‹å†Œ
- **ç¡¬ä»¶è¿æ¥æ–¹æ¡ˆ**ï¼š`docs/ç¡¬ä»¶è¿æ¥æ–¹æ¡ˆ.md`
- **MPU6500ä½¿ç”¨æ–¹æ¡ˆ**ï¼š`docs/MPU6500ä½¿ç”¨æ–¹æ¡ˆ.md`
- **æ¿€å…‰é›·è¾¾ä½¿ç”¨æ–¹æ¡ˆ**ï¼š`docs/æ¿€å…‰é›·è¾¾ä½¿ç”¨æ–¹æ¡ˆ.md`

### 13.4 åœ¨çº¿èµ„æº

- **SLAMæ•™ç¨‹**ï¼šhttps://www.cs.cmu.edu/~rasc/Download/AMRobots3.pdf
- **è·¯å¾„è§„åˆ’ç®—æ³•å¯¹æ¯”**ï¼šhttps://qiao.github.io/PathFinding.js/visual/
- **Pythonä¸²å£ç¼–ç¨‹**ï¼šhttps://pyserial.readthedocs.io/
- **æœºå™¨äººå­¦åŸºç¡€**ï¼šhttps://modernrobotics.northwestern.edu/

---

## é™„å½•Aï¼šå®Œæ•´requirements.txt

```txt
# requirements.txt

# æ ¸å¿ƒè®¡ç®—åº“
numpy>=1.24.0
scipy>=1.10.0

# ä¸²å£é€šä¿¡
pyserial>=3.5

# å¯è§†åŒ–
matplotlib>=3.7.0
pygame>=2.5.0

# è·¯å¾„è§„åˆ’
pathfinding>=1.0.0

# æ•°æ®å¤„ç†ï¼ˆå¯é€‰ï¼‰
pandas>=2.0.0

# å›¾åƒå¤„ç†ï¼ˆå¯é€‰ï¼‰
opencv-python>=4.8.0
Pillow>=10.0.0

# å¼€å‘å·¥å…·
pytest>=7.4.0
black>=23.0.0
flake8>=6.0.0

# ç±»å‹æ£€æŸ¥ï¼ˆå¯é€‰ï¼‰
mypy>=1.5.0
```

---

## é™„å½•Bï¼šé…ç½®æ–‡ä»¶ç¤ºä¾‹

```python
# config.py

# ä¸²å£é…ç½®
SERIAL_PORT = 'COM5'  # Windows: 'COM5', Linux: '/dev/ttyUSB0'
BAUDRATE = 115200
TIMEOUT = 1.0

# SLAMé…ç½®
MAP_WIDTH = 500          # æ …æ ¼æ•°é‡
MAP_HEIGHT = 500
MAP_RESOLUTION = 0.1     # ç±³/æ …æ ¼
MAP_ORIGIN = (MAP_WIDTH // 2, MAP_HEIGHT // 2)

# æœºå™¨äººç‰©ç†å‚æ•°
WHEEL_BASE = 0.2         # è½®è·ï¼ˆç±³ï¼‰
WHEEL_RADIUS = 0.033     # è½®å­åŠå¾„ï¼ˆç±³ï¼‰
ENCODER_PPR = 360        # ç¼–ç å™¨æ¯è½¬è„‰å†²æ•°

# DWAå‚æ•°
MAX_SPEED = 1.0          # æœ€å¤§é€Ÿåº¦ m/s
MAX_YAW_RATE = 40.0      # æœ€å¤§è½¬å‘è§’é€Ÿåº¦ deg/s
MAX_ACCEL = 0.5          # æœ€å¤§åŠ é€Ÿåº¦ m/s^2
DWA_DT = 0.1             # é¢„æµ‹æ­¥é•¿ s

# Frontieræ£€æµ‹å‚æ•°
FRONTIER_CLUSTER_DIST = 0.3   # èšç±»è·ç¦» m
MIN_FRONTIER_SIZE = 5         # æœ€å°å‰æ²¿ç°‡å¤§å°

# å¯è§†åŒ–å‚æ•°
VISUALIZE_RATE = 30      # å¯è§†åŒ–å¸§ç‡ fps
SHOW_LIDAR_POINTS = True # æ˜¾ç¤ºé›·è¾¾ç‚¹äº‘
SHOW_PATH = True         # æ˜¾ç¤ºè§„åˆ’è·¯å¾„
SHOW_FRONTIERS = True    # æ˜¾ç¤ºå‰æ²¿ç‚¹
```

---

## é™„å½•Cï¼šGitå·¥ä½œæµ

```bash
# åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
git checkout -b feature/slam-module

# å¼€å‘å¹¶æäº¤
git add slam/occupancy_map.py
git commit -m "feat: implement occupancy grid SLAM"

# æ¨é€åˆ°è¿œç¨‹
git push origin feature/slam-module

# åˆå¹¶åˆ°ä¸»åˆ†æ”¯ï¼ˆé€šè¿‡PRï¼‰
git checkout main
git merge feature/slam-module

# æ ‡ç­¾ç‰ˆæœ¬
git tag -a v1.0 -m "Release version 1.0"
git push origin v1.0
```

---

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v2.0  
**åˆ›å»ºæ—¥æœŸï¼š** 2025-10-09  
**æœ€åæ›´æ–°ï¼š** 2025-10-09  
**é€‚ç”¨é¡¹ç›®ï¼š** xxqæ™ºèƒ½å°è½¦é¡¹ç›®  
**ç¼–å†™ç»„åˆ«ï¼š** è½¯ä»¶ç»„  
**ä½œè€…ï¼š** AIåŠ©æ‰‹ + è½¯ä»¶å¼€å‘å›¢é˜Ÿ

---

## âœ¨ æ–‡æ¡£æ›´æ–°è®°å½•

| æ—¥æœŸ | ç‰ˆæœ¬ | æ›´æ–°å†…å®¹ |
|------|------|---------|
| 2025-10-09 | v2.0 | å®Œæ•´é‡å†™ï¼šæŠ€æœ¯æ ˆè¯„ä¼°ã€é€šä¿¡åè®®è§„èŒƒã€å®Œæ•´ä»£ç å®ç°ã€æµ‹è¯•æ–¹æ¡ˆ |
| 2025-10-09 | v1.0 | åˆå§‹ç‰ˆæœ¬ï¼šåŸºæœ¬åŠŸèƒ½æ¨¡å—ä»‹ç» |

---

**ğŸ“§ è”ç³»æ–¹å¼ï¼š**  
å¦‚æœ‰é—®é¢˜è¯·è”ç³»è½¯ä»¶ç»„è´Ÿè´£äººæˆ–æŸ¥é˜…æœ¬æ–‡æ¡£FAQéƒ¨åˆ†ã€‚

**ğŸ¯ å¿«é€Ÿé“¾æ¥ï¼š**
- [æŠ€æœ¯æ ˆé€‰å‹](#2-æŠ€æœ¯æ ˆè¯„ä¼°ä¸é€‰å‹) 
- [é€šä¿¡åè®®](#3-é€šä¿¡åè®®è§„èŒƒ)
- [ä»£ç å®ç°](#5-å…·ä½“å®ç°ä»£ç )
- [å¼€å‘ä»»åŠ¡](#6-å¼€å‘ä»»åŠ¡æ¸…å•æŒ‰ä¼˜å…ˆçº§)
- [æµ‹è¯•è°ƒè¯•](#7-æµ‹è¯•ä¸è°ƒè¯•)
