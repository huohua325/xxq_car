# 软件组工作总结 - 主机端Python控制系统

## 📋 目录

- [1. 项目概述](#1-项目概述)
- [2. 技术栈评估与选型](#2-技术栈评估与选型)
- [3. 通信协议规范](#3-通信协议规范)
- [4. 核心功能模块](#4-核心功能模块)
- [5. 具体实现代码](#5-具体实现代码)
- [6. 开发任务清单](#6-开发任务清单)
- [7. 测试与调试](#7-测试与调试)

---

## 1. 项目概述

软件组负责开发基于Python的主机端控制系统，作为智能小车的高级决策中枢。该系统接收来自STM32固件的传感器数据（2D激光雷达扫描和里程计数据），执行智能决策、环境感知和导航规划等核心任务。

---

## 2. 技术栈评估与选型

### 2.1 技术栈对比分析

#### ❌ 原方案中可能落后的库

| 库名称 | 问题 | 推荐替代方案 |
|--------|------|--------------|
| **BreezySLAM** | ⚠️ 已停止维护(2016年)，功能简陋 | **替代1: SLAM Toolbox** (ROS2)<br>**替代2: Hector SLAM** (轻量级)<br>**替代3: 自己实现简单栅格SLAM** |
| **PyRoboViz** | ⚠️ 社区不活跃，可能不存在 | **替代: Matplotlib + OpenCV**<br>或 **pygame**（实时渲染） |
| **PythonRobotics** | ✅ 仍在维护，但仅作参考 | 保留，作为算法参考实现 |

#### ✅ 推荐的现代化技术栈

| 功能模块 | 推荐方案 | 优势 | 安装命令 |
|---------|---------|------|---------|
| **SLAM建图** | **自实现占据栅格SLAM**<br>+ NumPy优化 | 可控性强、无依赖、适合教学 | `pip install numpy` |
| **实时可视化** | **Matplotlib + Animation**<br>或 **Pygame** | 成熟稳定、文档丰富 | `pip install matplotlib pygame` |
| **路径规划** | **python-pathfinding**<br>+ 自实现DWA | 现代化、性能好 | `pip install pathfinding` |
| **串口通信** | **PySerial** | ✅ 行业标准，保持不变 | `pip install pyserial` |
| **数据处理** | **NumPy + Pandas** | 高性能数值计算 | `pip install numpy pandas` |
| **科学计算** | **SciPy** | 滤波、插值等高级功能 | `pip install scipy` |

### 2.2 最终选定技术栈

```python
# requirements.txt 完整依赖列表

# 核心计算库
numpy>=1.24.0              # 数值计算
scipy>=1.10.0              # 科学计算（滤波、优化）
pandas>=2.0.0              # 数据分析（可选）

# 通信库
pyserial>=3.5              # 蓝牙串口通信

# 可视化库
matplotlib>=3.7.0          # 实时地图可视化
pygame>=2.5.0              # 游戏引擎，用于更流畅的实时渲染（可选）

# 路径规划
pathfinding>=1.0.0         # A*等路径规划算法

# 图像处理（可选，用于地图处理）
opencv-python>=4.8.0       # OpenCV（可选）
Pillow>=10.0.0             # 图像处理（可选）

# 开发工具
pytest>=7.4.0              # 单元测试
black>=23.0.0              # 代码格式化
```

### 2.3 为什么不用ROS？

**考虑因素：**

| ROS优势 | ROS劣势 | 本项目选择 |
|---------|---------|-----------|
| 完整的SLAM工具链 | 学习曲线陡峭 | ❌ 不使用ROS |
| 丰富的导航包 | Windows支持差 | |
| 成熟的可视化工具 | 依赖复杂 | |

**结论：** 本项目采用**纯Python轻量级方案**，更灵活、更适合快速开发和调试。

---

## 3. 通信协议规范

### 3.1 通信架构总览

```
STM32固件端 (UART4蓝牙)  ←→  Python主机端
    ↓                            ↓
  传感器数据                   导航指令
  - 雷达扫描                   - 目标位置
  - MPU姿态                    - 速度控制
  - 编码器                     - 模式切换
```

### 3.2 数据包格式设计

#### 📤 上行数据（STM32 → PC）

##### 数据包1: 激光雷达数据

**格式：** JSON字符串（便于解析和调试）

```json
{
  "type": "LIDAR",
  "timestamp": 12345678,
  "data": {
    "total_points": 652,
    "angle_coverage": 359.8,
    "sectors": [
      {
        "sector_id": 0,
        "angle_center": 0,
        "count": 82,
        "min_dist": 1.25,
        "avg_dist": 3.42
      },
      // ... 8个扇区数据
    ],
    "raw_points": [  // 可选：详细点云数据
      {"angle": 0.5, "distance": 1.25, "quality": 67},
      // ...
    ]
  }
}
```

**发送时机：** 
- 方式1：固件收到 `A` 命令后主动发送完整扫描结果
- 方式2：以固定频率（如1Hz）发送最新扫描数据

**Python接收示例：**
```python
import json

def parse_lidar_data(serial_line):
    try:
        data = json.loads(serial_line)
        if data['type'] == 'LIDAR':
            return data['data']
    except json.JSONDecodeError:
        return None
```

---

##### 数据包2: MPU6500姿态数据

**格式：** 简化CSV格式（高频率数据，减少开销）

```
MPU,timestamp,roll,pitch,accel_x,accel_y,accel_z,gyro_x,gyro_y,gyro_z
```

**示例：**
```
MPU,12345678,0.23,-1.15,0.012,-0.035,9.815,0.23,-0.15,0.08
```

**字段说明：**
- `timestamp`: 毫秒时间戳
- `roll`: 横滚角（度）
- `pitch`: 俯仰角（度）
- `accel_x/y/z`: 加速度（m/s²）
- `gyro_x/y/z`: 角速度（°/s）

**发送频率：** 50Hz（每20ms一次）

**Python接收示例：**
```python
def parse_mpu_data(line):
    parts = line.strip().split(',')
    if parts[0] == 'MPU':
        return {
            'timestamp': int(parts[1]),
            'roll': float(parts[2]),
            'pitch': float(parts[3]),
            'accel': [float(parts[4]), float(parts[5]), float(parts[6])],
            'gyro': [float(parts[7]), float(parts[8]), float(parts[9])]
        }
```

---

##### 数据包3: 里程计数据

**格式：** CSV格式

```
ODO,timestamp,left_speed_rps,right_speed_rps,left_count,right_count
```

**示例：**
```
ODO,12345678,3.5,3.5,12450,12470
```

**字段说明：**
- `left/right_speed_rps`: 左右轮速度（转/秒）
- `left/right_count`: 编码器累计计数

**发送频率：** 50Hz（与MPU同步）

---

##### 数据包4: 位姿估计（融合结果）

**格式：** CSV格式

```
POSE,timestamp,x,y,theta
```

**示例：**
```
POSE,12345678,1.25,0.85,45.0
```

**字段说明：**
- `x, y`: 机器人位置（米）
- `theta`: 朝向角（度，0°为正前方）

**发送频率：** 20Hz

---

#### 📥 下行数据（PC → STM32）

##### 指令1: 导航控制

**格式：** 简洁命令格式

```
NAV,x,y,theta,speed
```

**示例：**
```
NAV,2.5,1.8,90.0,3.0
```

**字段说明：**
- `x, y`: 目标位置（米）
- `theta`: 目标朝向（度）
- `speed`: 目标速度（RPS）

---

##### 指令2: 速度控制

**格式：**
```
SPD,left_speed,right_speed
```

**示例：**
```
SPD,3.5,3.5  # 直行
SPD,2.0,4.0  # 右转
```

---

##### 指令3: 模式控制

**格式：**
```
MODE,mode_id
```

**模式定义：**
- `MODE,0` = 停止
- `MODE,1` = PID前进
- `MODE,2` = PID后退
- `MODE,3` = 左转
- `MODE,4` = 右转
- `MODE,5` = 自动导航模式

---

### 3.3 通信协议实现（STM32端）

**在 main.c 中添加数据发送函数：**

```c
/* 发送雷达JSON数据 */
void Send_Lidar_JSON(UART_HandleTypeDef *huart, RadarScanResult *result) {
    char json_buf[2048];
    int pos = 0;
    
    pos += snprintf(json_buf + pos, sizeof(json_buf) - pos, 
                    "{\"type\":\"LIDAR\",\"timestamp\":%lu,\"data\":{", HAL_GetTick());
    pos += snprintf(json_buf + pos, sizeof(json_buf) - pos,
                    "\"total_points\":%d,\"angle_coverage\":%.1f,\"sectors\":[",
                    result->total_points, result->angle_coverage);
    
    for (int i = 0; i < 8; i++) {
        pos += snprintf(json_buf + pos, sizeof(json_buf) - pos,
                        "{\"sector_id\":%d,\"angle_center\":%d,\"count\":%d,\"min_dist\":%.2f,\"avg_dist\":%.2f}",
                        i, i*45, result->sectors[i].count, 
                        result->sectors[i].min_dist, result->sectors[i].avg_dist);
        if (i < 7) pos += snprintf(json_buf + pos, sizeof(json_buf) - pos, ",");
    }
    
    pos += snprintf(json_buf + pos, sizeof(json_buf) - pos, "]}}\n");
    
    HAL_UART_Transmit(huart, (uint8_t*)json_buf, pos, 1000);
}

/* 发送MPU数据（CSV） */
void Send_MPU_CSV(UART_HandleTypeDef *huart, float roll, float pitch, 
                  float ax, float ay, float az, float gx, float gy, float gz) {
    char csv_buf[128];
    int len = snprintf(csv_buf, sizeof(csv_buf),
                       "MPU,%lu,%.2f,%.2f,%.3f,%.3f,%.3f,%.2f,%.2f,%.2f\n",
                       HAL_GetTick(), roll, pitch, ax, ay, az, gx, gy, gz);
    HAL_UART_Transmit(huart, (uint8_t*)csv_buf, len, 100);
}

/* 发送里程计数据（CSV） */
void Send_Odometry_CSV(UART_HandleTypeDef *huart, float left_rps, float right_rps,
                       int32_t left_count, int32_t right_count) {
    char csv_buf[128];
    int len = snprintf(csv_buf, sizeof(csv_buf),
                       "ODO,%lu,%.2f,%.2f,%ld,%ld\n",
                       HAL_GetTick(), left_rps, right_rps, left_count, right_count);
    HAL_UART_Transmit(huart, (uint8_t*)csv_buf, len, 100);
}

/* 发送位姿估计（CSV） */
void Send_Pose_CSV(UART_HandleTypeDef *huart, float x, float y, float theta) {
    char csv_buf[64];
    int len = snprintf(csv_buf, sizeof(csv_buf),
                       "POSE,%lu,%.3f,%.3f,%.2f\n",
                       HAL_GetTick(), x, y, theta);
    HAL_UART_Transmit(huart, (uint8_t*)csv_buf, len, 100);
}
```

---

### 3.4 通信协议实现（Python端）

**完整通信类实现：**

```python
import serial
import json
import time
import threading
from dataclasses import dataclass
from typing import Optional, Callable

@dataclass
class LidarData:
    timestamp: int
    total_points: int
    angle_coverage: float
    sectors: list

@dataclass
class MPUData:
    timestamp: int
    roll: float
    pitch: float
    accel: list  # [x, y, z]
    gyro: list   # [x, y, z]

@dataclass
class OdometryData:
    timestamp: int
    left_speed: float
    right_speed: float
    left_count: int
    right_count: int

@dataclass
class PoseData:
    timestamp: int
    x: float
    y: float
    theta: float

class RobotComm:
    """机器人通信类"""
    
    def __init__(self, port='COM5', baudrate=115200):
        self.serial = serial.Serial(port, baudrate, timeout=0.1)
        self.running = False
        self.receive_thread = None
        
        # 最新数据缓存
        self.latest_lidar: Optional[LidarData] = None
        self.latest_mpu: Optional[MPUData] = None
        self.latest_odom: Optional[OdometryData] = None
        self.latest_pose: Optional[PoseData] = None
        
        # 回调函数
        self.on_lidar_update: Optional[Callable] = None
        self.on_mpu_update: Optional[Callable] = None
        self.on_odom_update: Optional[Callable] = None
        self.on_pose_update: Optional[Callable] = None
    
    def start(self):
        """启动接收线程"""
        self.running = True
        self.receive_thread = threading.Thread(target=self._receive_loop, daemon=True)
        self.receive_thread.start()
    
    def stop(self):
        """停止通信"""
        self.running = False
        if self.receive_thread:
            self.receive_thread.join(timeout=1)
        self.serial.close()
    
    def _receive_loop(self):
        """接收循环（在独立线程中运行）"""
        buffer = ""
        
        while self.running:
            try:
                if self.serial.in_waiting:
                    data = self.serial.read(self.serial.in_waiting).decode('utf-8', errors='ignore')
                    buffer += data
                    
                    # 按行处理
                    while '\n' in buffer:
                        line, buffer = buffer.split('\n', 1)
                        self._parse_line(line.strip())
                        
            except Exception as e:
                print(f"[COMM ERROR] {e}")
                time.sleep(0.1)
    
    def _parse_line(self, line: str):
        """解析一行数据"""
        if not line:
            return
        
        # JSON格式（雷达数据）
        if line.startswith('{'):
            try:
                data = json.loads(line)
                if data['type'] == 'LIDAR':
                    self.latest_lidar = LidarData(
                        timestamp=data['timestamp'],
                        total_points=data['data']['total_points'],
                        angle_coverage=data['data']['angle_coverage'],
                        sectors=data['data']['sectors']
                    )
                    if self.on_lidar_update:
                        self.on_lidar_update(self.latest_lidar)
            except json.JSONDecodeError:
                pass
        
        # CSV格式
        else:
            parts = line.split(',')
            
            if parts[0] == 'MPU' and len(parts) == 10:
                self.latest_mpu = MPUData(
                    timestamp=int(parts[1]),
                    roll=float(parts[2]),
                    pitch=float(parts[3]),
                    accel=[float(parts[4]), float(parts[5]), float(parts[6])],
                    gyro=[float(parts[7]), float(parts[8]), float(parts[9])]
                )
                if self.on_mpu_update:
                    self.on_mpu_update(self.latest_mpu)
            
            elif parts[0] == 'ODO' and len(parts) == 6:
                self.latest_odom = OdometryData(
                    timestamp=int(parts[1]),
                    left_speed=float(parts[2]),
                    right_speed=float(parts[3]),
                    left_count=int(parts[4]),
                    right_count=int(parts[5])
                )
                if self.on_odom_update:
                    self.on_odom_update(self.latest_odom)
            
            elif parts[0] == 'POSE' and len(parts) == 5:
                self.latest_pose = PoseData(
                    timestamp=int(parts[1]),
                    x=float(parts[2]),
                    y=float(parts[3]),
                    theta=float(parts[4])
                )
                if self.on_pose_update:
                    self.on_pose_update(self.latest_pose)
    
    def send_navigation_command(self, x: float, y: float, theta: float, speed: float):
        """发送导航指令"""
        cmd = f"NAV,{x:.3f},{y:.3f},{theta:.2f},{speed:.2f}\n"
        self.serial.write(cmd.encode())
    
    def send_speed_command(self, left_speed: float, right_speed: float):
        """发送速度指令"""
        cmd = f"SPD,{left_speed:.2f},{right_speed:.2f}\n"
        self.serial.write(cmd.encode())
    
    def send_mode_command(self, mode: int):
        """发送模式指令"""
        cmd = f"MODE,{mode}\n"
        self.serial.write(cmd.encode())
    
    def request_lidar_scan(self):
        """请求雷达扫描"""
        self.serial.write(b'A')
```

---

## 4. 核心功能模块

### 2.1 自主导航与环境探索

**目标：** 在未知迷宫环境中实现自主探索并定位出口点

**技术方案：** 基于Frontier检测的自主探索算法

#### 工作原理

Frontier检测方法通过分析动态构建的占据栅格地图，识别"前沿单元格"（frontier cells）——即已知自由空间与未探索区域之间的边界。这些前沿被优先作为动态导航目标，引导机器人逐步映射整个环境。

#### 探索流程

探索过程遵循以下持续循环：

1. **前沿识别**
   - 在当前SLAM地图中识别所有前沿单元格
   - 分析已知区域与未知区域的边界

2. **目标选择**
   - 根据距离或信息增益选择最近或最有前景的前沿
   - 使用启发式算法优化探索效率

3. **路径规划**
   - 使用A*算法进行全局路径规划
   - 使用动态窗口法（DWA）[8]进行局部避障
   - 规划到选定前沿的最优路径

4. **持续探索**
   - 继续探索直到整个环境被映射完成
   - 或成功定位到出口点

5. **指令传输**
   - 将计算的导航指令传输到机器人固件执行
   - 实时监控执行状态并调整策略

#### 关键技术点

- **占据栅格地图构建**：实时更新环境地图
- **前沿检测算法**：高效识别探索边界
- **启发式搜索**：优化探索路径选择
- **动态目标调整**：根据实时反馈调整探索策略

---

### 2.2 SLAM地图构建与可视化

**目标：** 实时构建环境地图并可视化机器人状态

**技术方案：** BreezySLAM [6] + PyRoboViz [7]

#### 地图构建

使用BreezySLAM [6]作为基础代码，构建实时占据栅格地图：

- **数据融合**：集成2D激光雷达和里程计数据
- **定位估计**：准确估计机器人在迷宫中的位置和方向
- **动态更新**：随着机器人移动，持续更新SLAM构建的地图
- **轨迹记录**：记录机器人的运动轨迹

#### 实时可视化

使用PyRoboViz [7]进行实时可视化展示（如图3所示）：

![PyRoboViz示例](参考图3)

**可视化内容包括：**

- **2D激光雷达点云数据**：实时显示环境扫描结果
- **机器人当前位姿**：(x, y, θ)坐标和朝向
- **SLAM生成的地图**：占据栅格地图展示
- **运动轨迹**：机器人的移动路径

**核心组件：**

1. **BreezySLAM [6]应用**
   - 从2D激光雷达和里程计数据构建2D占据栅格地图
   - 处理传感器数据融合和地图更新

2. **PyRoboViz [7]可视化**
   - 实时展示地图构建过程
   - 显示2D激光雷达点云
   - 显示机器人当前位姿(x,y,θ)
   - 展示SLAM生成的地图和导航路径

#### 技术优势

- **实时性**：低延迟地图更新和显示
- **精确性**：多传感器融合提高定位精度
- **可视化**：直观监控机器人探索进度
- **调试友好**：便于分析和优化算法性能

---

### 2.3 路径规划与导航

**目标：** 完成探索后规划从出口返回起点的最优路径

**技术方案：** 基于PythonRobotics库的鲁棒路径规划算法

#### 规划流程

一旦定位到出口点并完成地图构建，系统将：

1. **航点确定**
   - 确定高效的迷宫探索航点
   - 标记出口检测点
   - 规划返回起点的路线

2. **全局路径规划**
   - 使用A*算法[8]进行全局路径规划
   - 在完整地图上计算最优路径
   - 考虑路径长度和安全性

3. **局部避障**
   - 使用动态窗口法（DWA）进行实时局部避障
   - 应对动态障碍物和传感器噪声
   - 确保平滑的运动轨迹

4. **前沿探索导航**
   - 使用Frontier Detection算法
   - 在未知环境中进行基于探索的导航
   - 利用PythonRobotics [8]库的参考算法

5. **指令生成与传输**
   - 生成目标位置指令(x,y,θ)
   - 将导航命令传输到机器人固件执行
   - 通过PID控制实现精确的速度和位置控制

#### 算法库

**PythonRobotics [8]库应用：**

- **A*算法**：全局最优路径搜索
- **DWA算法**：动态窗口避障
- **Frontier Detection**：未知环境探索
- **路径平滑**：优化运动轨迹

#### 控制策略

- **位置控制**：精确到达目标点
- **速度控制**：平滑加减速
- **角度控制**：准确转向
- **实时调整**：根据传感器反馈动态修正

---

### 2.4 通信与数据管理

**目标：** 实现主机与机器人之间的可靠无线通信和数据处理

**技术方案：** 基于PySerial [9]的蓝牙通信

#### 通信架构

使用PySerial [9]库通过蓝牙实现无线通信：

- **通信方式**：蓝牙（UART4）
- **波特率**：115200
- **通信模式**：双向实时通信
- **协议**：自定义数据包协议

#### 数据流向

**上行数据（机器人→主机）：**

1. **2D激光雷达数据**
   - 360°扫描点云数据
   - 距离和角度信息
   - 数据质量标志

2. **里程计数据**
   - 左右轮编码器计数
   - 轮速信息（RPS）
   - 时间戳

3. **机器人当前位姿**
   - 位置坐标(x, y)
   - 朝向角度θ
   - MPU6500姿态数据（Roll, Pitch）

**下行数据（主机→机器人）：**

1. **导航控制指令**
   - 目标位置(x, y, θ)
   - 运动模式（前进/后退/转向/停止）
   - 速度指令

2. **PID参数**
   - 速度控制参数
   - 位置控制参数
   - 实时调整指令

#### 控制循环

实现闭环控制和自适应决策：

- **数据接收**：持续接收传感器数据包
- **数据处理**：解析和验证数据
- **决策计算**：基于实时环境反馈进行路径规划
- **指令发送**：发送实时控制导航命令
- **反馈调整**：根据执行结果调整策略

#### 数据管理功能

**数据记录：**
- 离线分析日志
- 传感器数据记录
- 机器人轨迹记录
- SLAM地图保存

**调试功能：**
- 实时数据监控
- 性能评估工具
- 错误诊断日志
- 通信质量检测

**数据分析：**
- 传感器数据质量分析
- 轨迹精度评估
- SLAM准确性验证
- 系统性能评估

---

## 5. 具体实现代码

### 5.1 简单SLAM实现（占据栅格地图）

```python
import numpy as np
from typing import Tuple

class OccupancyGridMap:
    """占据栅格地图"""
    
    def __init__(self, width: int = 500, height: int = 500, resolution: float = 0.05):
        """
        Args:
            width, height: 地图栅格数量
            resolution: 分辨率（米/栅格）
        """
        self.width = width
        self.height = height
        self.resolution = resolution
        
        # 地图数据：0=未知, 0.5=空闲, 1=占用
        self.grid = np.ones((height, width)) * 0.5
        
        # 机器人初始位置（地图中心）
        self.robot_x = width // 2
        self.robot_y = height // 2
        self.robot_theta = 0.0
    
    def world_to_grid(self, x: float, y: float) -> Tuple[int, int]:
        """世界坐标 → 栅格坐标"""
        grid_x = int(self.robot_x + x / self.resolution)
        grid_y = int(self.robot_y - y / self.resolution)  # Y轴翻转
        return grid_x, grid_y
    
    def grid_to_world(self, grid_x: int, grid_y: int) -> Tuple[float, float]:
        """栅格坐标 → 世界坐标"""
        x = (grid_x - self.robot_x) * self.resolution
        y = -(grid_y - self.robot_y) * self.resolution
        return x, y
    
    def update_with_lidar(self, lidar_data, robot_pose):
        """用雷达数据更新地图
        
        Args:
            lidar_data: LidarData对象
            robot_pose: (x, y, theta) 机器人位姿
        """
        rx, ry, rtheta = robot_pose
        
        for sector in lidar_data.sectors:
            if sector['count'] == 0:
                continue
            
            # 扇区角度
            angle_deg = sector['angle_center']
            angle_rad = np.deg2rad(angle_deg) + rtheta
            
            # 障碍物位置
            dist = sector['min_dist']
            if dist > 0.1 and dist < 10.0:  # 有效范围
                obs_x = rx + dist * np.cos(angle_rad)
                obs_y = ry + dist * np.sin(angle_rad)
                
                # 转换为栅格坐标
                grid_x, grid_y = self.world_to_grid(obs_x, obs_y)
                
                # 标记障碍物
                if 0 <= grid_x < self.width and 0 <= grid_y < self.height:
                    self.grid[grid_y, grid_x] = 1.0  # 占用
                
                # 射线追踪：标记途径区域为空闲
                self._ray_trace(rx, ry, obs_x, obs_y, mark_free=True)
    
    def _ray_trace(self, x0, y0, x1, y1, mark_free=True):
        """射线追踪（Bresenham算法）"""
        gx0, gy0 = self.world_to_grid(x0, y0)
        gx1, gy1 = self.world_to_grid(x1, y1)
        
        dx = abs(gx1 - gx0)
        dy = abs(gy1 - gy0)
        sx = 1 if gx0 < gx1 else -1
        sy = 1 if gy0 < gy1 else -1
        err = dx - dy
        
        while True:
            if 0 <= gx0 < self.width and 0 <= gy0 < self.height:
                if mark_free and self.grid[gy0, gx0] != 1.0:
                    self.grid[gy0, gx0] = 0.0  # 空闲
            
            if gx0 == gx1 and gy0 == gy1:
                break
            
            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                gx0 += sx
            if e2 < dx:
                err += dx
                gy0 += sy
    
    def get_map_array(self):
        """获取地图数组（用于可视化）"""
        return self.grid
```

---

### 5.2 Frontier检测（探索算法）

```python
class FrontierDetector:
    """前沿检测器"""
    
    def __init__(self, map_obj: OccupancyGridMap):
        self.map = map_obj
    
    def find_frontiers(self):
        """查找所有前沿点"""
        frontiers = []
        grid = self.map.grid
        
        for y in range(1, self.map.height - 1):
            for x in range(1, self.map.width - 1):
                if self._is_frontier(x, y):
                    # 转换为世界坐标
                    wx, wy = self.map.grid_to_world(x, y)
                    frontiers.append((wx, wy))
        
        return self._cluster_frontiers(frontiers)
    
    def _is_frontier(self, x, y):
        """判断是否为前沿点"""
        grid = self.map.grid
        
        # 当前格子必须是空闲的
        if grid[y, x] != 0.0:
            return False
        
        # 检查8邻域是否有未知区域
        for dy in [-1, 0, 1]:
            for dx in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                ny, nx = y + dy, x + dx
                if 0 <= nx < self.map.width and 0 <= ny < self.map.height:
                    if grid[ny, nx] == 0.5:  # 未知
                        return True
        return False
    
    def _cluster_frontiers(self, frontiers, cluster_dist=0.3):
        """聚类前沿点"""
        if not frontiers:
            return []
        
        clusters = []
        used = set()
        
        for i, (x1, y1) in enumerate(frontiers):
            if i in used:
                continue
            
            cluster = [(x1, y1)]
            used.add(i)
            
            for j, (x2, y2) in enumerate(frontiers):
                if j in used:
                    continue
                dist = np.sqrt((x1-x2)**2 + (y1-y2)**2)
                if dist < cluster_dist:
                    cluster.append((x2, y2))
                    used.add(j)
            
            if len(cluster) > 5:  # 过滤小簇
                # 计算簇中心
                cx = np.mean([p[0] for p in cluster])
                cy = np.mean([p[1] for p in cluster])
                clusters.append((cx, cy))
        
        return clusters
    
    def select_best_frontier(self, frontiers, robot_pose):
        """选择最佳前沿（最近的）"""
        if not frontiers:
            return None
        
        rx, ry, _ = robot_pose
        best = None
        min_dist = float('inf')
        
        for fx, fy in frontiers:
            dist = np.sqrt((fx-rx)**2 + (fy-ry)**2)
            if dist < min_dist:
                min_dist = dist
                best = (fx, fy)
        
        return best
```

---

### 5.3 A*路径规划

```python
from pathfinding.core.grid import Grid
from pathfinding.finder.a_star import AStarFinder

class PathPlanner:
    """路径规划器"""
    
    def __init__(self, map_obj: OccupancyGridMap):
        self.map = map_obj
    
    def plan_path(self, start, goal):
        """A*路径规划
        
        Args:
            start: (x, y) 起点（世界坐标）
            goal: (x, y) 终点（世界坐标）
        
        Returns:
            路径点列表 [(x, y), ...]
        """
        # 转换为栅格坐标
        sx, sy = self.map.world_to_grid(*start)
        gx, gy = self.map.world_to_grid(*goal)
        
        # 创建网格（0=可通行, 1=障碍物）
        grid_data = (self.map.grid < 0.8).astype(int)
        grid = Grid(matrix=grid_data)
        
        start_node = grid.node(sx, sy)
        end_node = grid.node(gx, gy)
        
        finder = AStarFinder()
        path, runs = finder.find_path(start_node, end_node, grid)
        
        # 转换回世界坐标
        world_path = [self.map.grid_to_world(x, y) for x, y in path]
        
        return world_path
```

---

### 5.4 动态窗口法（DWA）局部避障

```python
class DWA:
    """动态窗口法避障"""
    
    def __init__(self):
        self.max_speed = 1.0  # m/s
        self.max_yaw_rate = 40.0  # deg/s
        self.max_accel = 0.5  # m/s^2
        self.v_resolution = 0.1
        self.yaw_rate_resolution = 5.0
        self.dt = 0.1
    
    def plan(self, robot_state, goal, lidar_data):
        """DWA规划
        
        Args:
            robot_state: (x, y, theta, v, omega)
            goal: (gx, gy)
            lidar_data: LidarData对象
        
        Returns:
            (v, omega) 速度和角速度
        """
        x, y, theta, v, omega = robot_state
        gx, gy = goal
        
        # 动态窗口
        v_range = self._calc_dynamic_window(v, omega)
        
        best_v, best_w = 0, 0
        max_score = -float('inf')
        
        # 遍历所有可能的速度
        for v_test in np.arange(v_range[0], v_range[1], self.v_resolution):
            for w_test in np.arange(v_range[2], v_range[3], np.deg2rad(self.yaw_rate_resolution)):
                # 预测轨迹
                traj = self._predict_trajectory(x, y, theta, v_test, w_test)
                
                # 评分
                heading_score = self._calc_heading_score(traj, gx, gy)
                dist_score = self._calc_dist_score(traj, lidar_data)
                vel_score = v_test / self.max_speed
                
                total_score = 0.5*heading_score + 0.3*dist_score + 0.2*vel_score
                
                if total_score > max_score:
                    max_score = total_score
                    best_v = v_test
                    best_w = w_test
        
        return best_v, best_w
    
    def _calc_dynamic_window(self, v, omega):
        """计算动态窗口"""
        v_min = max(0, v - self.max_accel * self.dt)
        v_max = min(self.max_speed, v + self.max_accel * self.dt)
        w_min = omega - np.deg2rad(self.max_yaw_rate) * self.dt
        w_max = omega + np.deg2rad(self.max_yaw_rate) * self.dt
        return [v_min, v_max, w_min, w_max]
    
    def _predict_trajectory(self, x, y, theta, v, omega):
        """预测轨迹"""
        traj = []
        for _ in range(10):  # 预测1秒
            x += v * np.cos(theta) * self.dt
            y += v * np.sin(theta) * self.dt
            theta += omega * self.dt
            traj.append((x, y, theta))
        return traj
    
    def _calc_heading_score(self, traj, gx, gy):
        """计算朝向得分"""
        x, y, theta = traj[-1]
        angle_to_goal = np.arctan2(gy - y, gx - x)
        score = 1.0 - abs(angle_to_goal - theta) / np.pi
        return max(0, score)
    
    def _calc_dist_score(self, traj, lidar_data):
        """计算距离得分（避障）"""
        # 简化：检查轨迹终点是否安全
        x, y, _ = traj[-1]
        # TODO: 根据lidar_data计算得分
        return 1.0
```

---

### 5.5 实时可视化（Matplotlib）

```python
import matplotlib.pyplot as plt
import matplotlib.animation as animation

class MapVisualizer:
    """地图可视化"""
    
    def __init__(self, map_obj: OccupancyGridMap):
        self.map = map_obj
        self.fig, self.ax = plt.subplots(figsize=(10, 10))
        
        # 初始化图像
        self.img = self.ax.imshow(map_obj.grid, cmap='gray_r', 
                                   vmin=0, vmax=1, origin='upper')
        
        # 机器人位置
        self.robot_scatter = self.ax.scatter([], [], c='blue', s=100, marker='o')
        
        # 路径
        self.path_line, = self.ax.plot([], [], 'r-', linewidth=2)
        
        # 前沿点
        self.frontier_scatter = self.ax.scatter([], [], c='green', s=50, marker='x')
        
        self.ax.set_title('SLAM Map')
        self.ax.grid(True, alpha=0.3)
    
    def update(self, robot_pose, path=None, frontiers=None):
        """更新显示"""
        # 更新地图
        self.img.set_data(self.map.grid)
        
        # 更新机器人位置
        rx, ry, _ = robot_pose
        gx, gy = self.map.world_to_grid(rx, ry)
        self.robot_scatter.set_offsets([[gx, gy]])
        
        # 更新路径
        if path:
            path_grid = [self.map.world_to_grid(x, y) for x, y in path]
            px = [p[0] for p in path_grid]
            py = [p[1] for p in path_grid]
            self.path_line.set_data(px, py)
        
        # 更新前沿点
        if frontiers:
            f_grid = [self.map.world_to_grid(x, y) for x, y in frontiers]
            self.frontier_scatter.set_offsets(f_grid)
        
        self.fig.canvas.draw()
        self.fig.canvas.flush_events()
```

---

### 5.6 主控制循环

```python
import time

class RobotController:
    """机器人主控制器"""
    
    def __init__(self, comm: RobotComm):
        self.comm = comm
        self.map = OccupancyGridMap(width=500, height=500, resolution=0.05)
        self.frontier_detector = FrontierDetector(self.map)
        self.path_planner = PathPlanner(self.map)
        self.dwa = DWA()
        self.visualizer = MapVisualizer(self.map)
        
        # 当前状态
        self.robot_pose = (0.0, 0.0, 0.0)  # x, y, theta
        self.robot_velocity = (0.0, 0.0)    # v, omega
        self.current_path = []
        self.exploration_complete = False
    
    def run(self):
        """主循环"""
        print("[ROBOT] Starting autonomous exploration...")
        
        # 启动通信
        self.comm.on_lidar_update = self.on_lidar_received
        self.comm.on_pose_update = self.on_pose_received
        self.comm.start()
        
        # 显示窗口
        plt.ion()
        plt.show()
        
        while not self.exploration_complete:
            # 1. 请求雷达扫描
            self.comm.request_lidar_scan()
            time.sleep(1)  # 等待扫描完成
            
            # 2. 检测前沿
            frontiers = self.frontier_detector.find_frontiers()
            
            if not frontiers:
                print("[ROBOT] Exploration complete!")
                self.exploration_complete = True
                break
            
            # 3. 选择目标前沿
            target = self.frontier_detector.select_best_frontier(
                frontiers, self.robot_pose
            )
            
            if target:
                print(f"[ROBOT] Target frontier: {target}")
                
                # 4. 规划路径
                self.current_path = self.path_planner.plan_path(
                    self.robot_pose[:2], target
                )
                
                # 5. 执行导航
                self.navigate_to_goal(target)
            
            # 6. 更新可视化
            self.visualizer.update(self.robot_pose, self.current_path, frontiers)
            time.sleep(0.1)
        
        print("[ROBOT] Mission complete!")
        self.comm.stop()
    
    def on_lidar_received(self, lidar_data: LidarData):
        """雷达数据回调"""
        self.map.update_with_lidar(lidar_data, self.robot_pose)
        print(f"[LIDAR] Updated map with {lidar_data.total_points} points")
    
    def on_pose_received(self, pose_data: PoseData):
        """位姿数据回调"""
        self.robot_pose = (pose_data.x, pose_data.y, np.deg2rad(pose_data.theta))
    
    def navigate_to_goal(self, goal):
        """导航到目标点"""
        print(f"[NAV] Navigating to {goal}")
        
        while True:
            # 计算距离
            rx, ry, rtheta = self.robot_pose
            dist = np.sqrt((goal[0]-rx)**2 + (goal[1]-ry)**2)
            
            if dist < 0.2:  # 到达目标
                self.comm.send_mode_command(0)  # 停止
                print("[NAV] Goal reached!")
                break
            
            # DWA避障
            v, omega = self.dwa.plan(
                (*self.robot_pose, *self.robot_velocity),
                goal,
                self.comm.latest_lidar
            )
            
            # 发送速度指令
            # 这里需要转换为左右轮速度
            wheel_base = 0.2  # 轮距（米）
            left_speed = v - omega * wheel_base / 2
            right_speed = v + omega * wheel_base / 2
            
            self.comm.send_speed_command(left_speed, right_speed)
            time.sleep(0.1)
```

---

### 5.7 完整程序入口

```python
# main.py

if __name__ == "__main__":
    # 配置串口
    PORT = 'COM5'  # Windows
    # PORT = '/dev/ttyUSB0'  # Linux
    BAUDRATE = 115200
    
    # 创建通信对象
    comm = RobotComm(port=PORT, baudrate=BAUDRATE)
    
    # 创建控制器
    controller = RobotController(comm)
    
    try:
        # 运行主循环
        controller.run()
    except KeyboardInterrupt:
        print("\n[MAIN] Interrupted by user")
    finally:
        comm.stop()
        print("[MAIN] Program exit")
```

---

## 6. 开发任务清单（按优先级）

### 📌 阶段一：基础通信（第1-2周）

- [ ] **1.1 环境搭建**
  - [ ] 安装Python 3.8+
  - [ ] 安装依赖库（`pip install -r requirements.txt`）
  - [ ] 配置开发IDE（VSCode/PyCharm）
  - [ ] 搭建版本控制（Git）

- [ ] **1.2 通信模块开发**
  - [ ] 实现 `RobotComm` 类（串口通信）
  - [ ] 实现数据包解析（JSON + CSV）
  - [ ] 实现回调机制
  - [ ] 通信稳定性测试

- [ ] **1.3 固件端配合**
  - [ ] 与固件组确定通信协议
  - [ ] 实现STM32端数据发送函数
  - [ ] 联调测试雷达数据传输
  - [ ] 联调测试MPU/里程计数据

**验收标准：** PC能正常接收和解析所有传感器数据

---

### 📌 阶段二：SLAM建图（第3-4周）

- [ ] **2.1 占据栅格地图**
  - [ ] 实现 `OccupancyGridMap` 类
  - [ ] 实现世界坐标↔栅格坐标转换
  - [ ] 实现雷达数据更新地图
  - [ ] 实现射线追踪算法

- [ ] **2.2 可视化系统**
  - [ ] 实现 `MapVisualizer` 类（Matplotlib）
  - [ ] 实时显示地图
  - [ ] 显示机器人位置和朝向
  - [ ] 显示雷达扫描点云

- [ ] **2.3 测试与调试**
  - [ ] 静态环境建图测试
  - [ ] 动态环境建图测试
  - [ ] 地图精度验证

**验收标准：** 能实时构建和显示环境地图

---

### 📌 阶段三：导航规划（第5-7周）

- [ ] **3.1 Frontier探索**
  - [ ] 实现 `FrontierDetector` 类
  - [ ] 前沿点检测算法
  - [ ] 前沿点聚类算法
  - [ ] 目标前沿选择策略

- [ ] **3.2 路径规划**
  - [ ] 集成A*算法（pathfinding库）
  - [ ] 实现 `PathPlanner` 类
  - [ ] 路径平滑处理
  - [ ] 路径可视化

- [ ] **3.3 DWA局部避障**
  - [ ] 实现 `DWA` 类
  - [ ] 动态窗口计算
  - [ ] 轨迹评分函数
  - [ ] 速度指令生成

- [ ] **3.4 主控制循环**
  - [ ] 实现 `RobotController` 类
  - [ ] 探索→规划→执行流程
  - [ ] 状态机管理
  - [ ] 异常处理机制

**验收标准：** 机器人能自主探索未知环境并返回起点

---

### 📌 阶段四：系统集成与优化（第8-9周）

- [ ] **4.1 系统集成**
  - [ ] 所有模块联调
  - [ ] 实际迷宫环境测试
  - [ ] 长时间运行稳定性测试

- [ ] **4.2 性能优化**
  - [ ] SLAM计算优化（NumPy向量化）
  - [ ] Frontier检测加速
  - [ ] 可视化帧率优化
  - [ ] 内存使用优化

- [ ] **4.3 鲁棒性提升**
  - [ ] 通信丢包处理
  - [ ] 传感器数据异常处理
  - [ ] 路径规划失败恢复
  - [ ] 卡死检测与脱困

- [ ] **4.4 文档与交付**
  - [ ] 代码注释完善
  - [ ] 用户使用手册
  - [ ] API文档
  - [ ] 演示视频制作

**验收标准：** 系统稳定运行，成功率>90%

---

## 7. 测试与调试

### 7.1 单元测试示例

```python
# tests/test_occupancy_map.py

import pytest
import numpy as np
from slam.occupancy_map import OccupancyGridMap

def test_world_to_grid_conversion():
    """测试坐标转换"""
    map_obj = OccupancyGridMap(width=100, height=100, resolution=0.1)
    
    # 测试中心点
    gx, gy = map_obj.world_to_grid(0, 0)
    assert gx == 50 and gy == 50
    
    # 测试偏移点
    gx, gy = map_obj.world_to_grid(1.0, 0.5)
    assert gx == 60 and gy == 45

def test_ray_tracing():
    """测试射线追踪"""
    map_obj = OccupancyGridMap(width=100, height=100, resolution=0.1)
    
    # 射线追踪应该标记途径格子为空闲
    map_obj._ray_trace(0, 0, 1.0, 1.0, mark_free=True)
    
    # 检查路径上的格子
    gx, gy = map_obj.world_to_grid(0.5, 0.5)
    assert map_obj.grid[gy, gx] == 0.0  # 空闲
```

---

### 7.2 通信测试脚本

```python
# tests/test_communication.py

from communication.robot_comm import RobotComm
import time

def test_lidar_reception():
    """测试雷达数据接收"""
    comm = RobotComm(port='COM5', baudrate=115200)
    comm.start()
    
    received = False
    
    def on_lidar(data):
        nonlocal received
        print(f"[TEST] Received {data.total_points} lidar points")
        received = True
    
    comm.on_lidar_update = on_lidar
    comm.request_lidar_scan()
    
    # 等待5秒
    for _ in range(50):
        time.sleep(0.1)
        if received:
            break
    
    assert received, "未收到雷达数据"
    comm.stop()

if __name__ == "__main__":
    test_lidar_reception()
```

---

### 7.3 调试技巧

#### 问题1：地图构建不准确

**排查步骤：**
```python
# 1. 检查雷达数据质量
def debug_lidar_data(lidar_data):
    print(f"总点数: {lidar_data.total_points}")
    print(f"角度覆盖: {lidar_data.angle_coverage}°")
    for sector in lidar_data.sectors:
        print(f"扇区{sector['sector_id']}: {sector['count']}点, 最近{sector['min_dist']:.2f}m")

# 2. 可视化射线追踪
def visualize_ray_trace(map_obj):
    plt.figure()
    plt.imshow(map_obj.grid, cmap='gray_r')
    plt.colorbar()
    plt.title("Ray Tracing Result")
    plt.show()

# 3. 检查坐标转换
def test_coordinate_transform(map_obj):
    test_points = [(0, 0), (1, 0), (0, 1), (-1, -1)]
    for wx, wy in test_points:
        gx, gy = map_obj.world_to_grid(wx, wy)
        wx2, wy2 = map_obj.grid_to_world(gx, gy)
        print(f"World({wx},{wy}) -> Grid({gx},{gy}) -> World({wx2:.2f},{wy2:.2f})")
```

---

#### 问题2：路径规划失败

**解决方案：**
```python
def debug_path_planning(planner, start, goal):
    # 检查起点和终点是否在地图内
    sx, sy = planner.map.world_to_grid(*start)
    gx, gy = planner.map.world_to_grid(*goal)
    
    print(f"起点栅格坐标: ({sx}, {sy})")
    print(f"终点栅格坐标: ({gx}, {gy})")
    
    # 检查是否在障碍物上
    if planner.map.grid[sy, sx] >= 0.8:
        print("⚠️ 起点在障碍物上！")
    if planner.map.grid[gy, gx] >= 0.8:
        print("⚠️ 终点在障碍物上！")
    
    # 可视化地图和起终点
    plt.figure()
    plt.imshow(planner.map.grid, cmap='gray_r')
    plt.scatter([sx], [sy], c='blue', s=100, label='Start')
    plt.scatter([gx], [gy], c='red', s=100, label='Goal')
    plt.legend()
    plt.show()
```

---

#### 问题3：通信延迟高

**优化方案：**
```python
# 1. 减少JSON数据大小（不发送raw_points）
# 2. 提高串口波特率到230400或460800
# 3. 使用二进制格式代替JSON

# 示例：二进制格式
import struct

def pack_lidar_binary(sectors):
    """将雷达数据打包为二进制"""
    # 格式: [header(2B)] + [sector_count(1B)] + [sectors...]
    # 每个sector: [id(1B), count(1B), min_dist(4B), avg_dist(4B)]
    data = b'LD'  # 头部
    data += struct.pack('B', len(sectors))
    for s in sectors:
        data += struct.pack('BBff', s['sector_id'], s['count'], 
                           s['min_dist'], s['avg_dist'])
    return data
```

---

## 8. 项目文件结构

```
robot_control/
├── requirements.txt           # 依赖库列表
├── main.py                   # 主程序入口
├── config.py                 # 配置文件
├── communication/            # 通信模块
│   ├── __init__.py
│   ├── robot_comm.py         # 通信类
│   └── protocol.py           # 协议定义
├── slam/                     # SLAM模块
│   ├── __init__.py
│   ├── occupancy_map.py      # 占据栅格地图
│   └── frontier_detector.py  # Frontier检测
├── navigation/               # 导航模块
│   ├── __init__.py
│   ├── path_planner.py       # A*路径规划
│   ├── dwa.py                # 动态窗口避障
│   └── controller.py         # 主控制器
├── visualization/            # 可视化模块
│   ├── __init__.py
│   └── map_visualizer.py     # 地图可视化
├── utils/                    # 工具函数
│   ├── __init__.py
│   ├── math_utils.py         # 数学工具
│   └── logger.py             # 日志工具
└── tests/                    # 测试代码
    ├── test_communication.py
    ├── test_slam.py
    └── test_navigation.py
```

---

## 9. 关键技术挑战与解决方案

### 9.1 实时性要求

**挑战：** SLAM计算、路径规划需要在实时内完成（<100ms）

**解决方案：**
- NumPy向量化计算（避免Python循环）
- 降低地图分辨率（0.05m→0.1m）
- 限制Frontier检测范围
- 使用C++扩展（如Cython）加速关键算法

```python
# 优化示例：向量化射线追踪
def fast_ray_trace(self, start, end, mark_free=True):
    # 使用NumPy向量操作代替循环
    points = np.linspace(start, end, num=50)
    grid_points = self.world_to_grid_vectorized(points)
    self.grid[grid_points[:, 1], grid_points[:, 0]] = 0.0
```

---

### 9.2 通信可靠性

**挑战：** 蓝牙通信可能存在延迟和丢包

**解决方案：**
```python
class ReliableComm:
    """可靠通信包装"""
    
    def __init__(self, base_comm):
        self.comm = base_comm
        self.timeout = 2.0
        self.retry_count = 3
    
    def send_with_ack(self, data):
        """带确认的发送"""
        for i in range(self.retry_count):
            self.comm.send(data)
            ack = self.comm.wait_for_ack(timeout=self.timeout)
            if ack:
                return True
        return False
    
    def receive_with_checksum(self):
        """带校验和的接收"""
        data = self.comm.receive()
        if self._verify_checksum(data):
            return data
        else:
            self.comm.request_retransmit()
            return None
```

---

### 9.3 定位精度

**挑战：** 仅用雷达和轮速计，定位误差累积

**解决方案：**
```python
class OdometryCorrection:
    """里程计误差修正"""
    
    def correct_with_lidar(self, odom_pose, lidar_pose):
        """使用雷达匹配修正里程计"""
        # 扫描匹配（ICP算法简化版）
        weight_odom = 0.7
        weight_lidar = 0.3
        
        corrected_x = weight_odom * odom_pose[0] + weight_lidar * lidar_pose[0]
        corrected_y = weight_odom * odom_pose[1] + weight_lidar * lidar_pose[1]
        corrected_theta = odom_pose[2]  # 角度主要靠里程计
        
        return (corrected_x, corrected_y, corrected_theta)
```

---

### 9.4 环境适应性

**挑战：** 复杂迷宫环境（死角、回路）

**解决方案：**
```python
class AdaptiveExplorer:
    """自适应探索策略"""
    
    def __init__(self):
        self.stuck_threshold = 5  # 5次尝试
        self.stuck_count = 0
        self.last_pose = None
    
    def select_frontier_adaptive(self, frontiers, robot_pose):
        """自适应选择策略"""
        # 检测是否卡住
        if self._is_stuck(robot_pose):
            self.stuck_count += 1
            
            if self.stuck_count > self.stuck_threshold:
                # 卡住了，选择最远的frontier
                return self._select_farthest(frontiers, robot_pose)
        else:
            self.stuck_count = 0
            # 正常，选择最近的
            return self._select_nearest(frontiers, robot_pose)
        
        self.last_pose = robot_pose
    
    def _is_stuck(self, current_pose):
        """检测是否卡住"""
        if self.last_pose is None:
            return False
        dist = np.hypot(current_pose[0] - self.last_pose[0],
                       current_pose[1] - self.last_pose[1])
        return dist < 0.1  # 移动距离<10cm
```

---

## 10. 快速开始指南

### 10.1 5分钟快速部署

```bash
# 1. 克隆项目（假设已创建）
git clone <repository_url>
cd robot_control

# 2. 创建虚拟环境
python -m venv venv
venv\Scripts\activate  # Windows
# source venv/bin/activate  # Linux/Mac

# 3. 安装依赖
pip install -r requirements.txt

# 4. 配置串口
# 编辑 config.py，设置正确的COM口
PORT = 'COM5'  # 修改为实际端口
BAUDRATE = 115200

# 5. 测试通信
python tests/test_communication.py

# 6. 运行主程序
python main.py
```

---

### 10.2 第一次运行检查清单

- [ ] ✅ STM32固件已烧录并运行
- [ ] ✅ 蓝牙模块配对成功
- [ ] ✅ Python环境和依赖安装完成
- [ ] ✅ 串口号配置正确
- [ ] ✅ 雷达能正常扫描（发送`A`命令测试）
- [ ] ✅ MPU数据实时更新
- [ ] ✅ 里程计数据正常
- [ ] ✅ PC能接收并解析所有数据

---

## 11. 常见问题FAQ

### Q1: 为什么选择自实现SLAM而不用ROS？

**答：** 
- ✅ **学习目的**：更深入理解SLAM原理
- ✅ **轻量级**：无需庞大的ROS依赖
- ✅ **跨平台**：Windows/Linux都能运行
- ✅ **灵活性**：方便调试和定制

---

### Q2: 地图分辨率如何选择？

**答：**
```python
# 分辨率权衡
resolution = 0.05  # 5cm/格
# 优点：精确，适合小物体检测
# 缺点：内存占用大，计算慢

resolution = 0.1   # 10cm/格 ✅ 推荐
# 优点：适中，性能和精度平衡
# 缺点：可能遗漏小障碍物

resolution = 0.2   # 20cm/格
# 优点：快速，内存省
# 缺点：精度低，不适合狭窄通道
```

---

### Q3: 如何调试Frontier检测不工作？

**答：**
```python
# 调试代码
def debug_frontiers(self):
    grid = self.map.grid
    
    # 1. 检查地图状态
    unknown_ratio = np.sum(grid == 0.5) / grid.size
    print(f"未知区域占比: {unknown_ratio*100:.1f}%")
    
    if unknown_ratio < 0.1:
        print("⚠️ 地图几乎完全探索，无前沿点")
    
    # 2. 可视化前沿点
    frontiers = self.find_frontiers()
    if frontiers:
        plt.figure()
        plt.imshow(grid, cmap='gray_r')
        f_grid = [self.map.world_to_grid(x, y) for x, y in frontiers]
        plt.scatter([p[0] for p in f_grid], [p[1] for p in f_grid], 
                   c='red', s=50)
        plt.title(f"Found {len(frontiers)} frontiers")
        plt.show()
```

---

### Q4: 路径规划总是失败怎么办？

**答：** 按顺序检查：

1. **起点/终点是否合法？**
   ```python
   if map_obj.grid[start_y, start_x] >= 0.8:
       print("起点在障碍物上！")
   ```

2. **地图是否连通？**
   - 检查是否有孤岛
   - 尝试从起点flood fill到终点

3. **障碍物膨胀？**
   ```python
   # 膨胀障碍物（增加安全裕度）
   from scipy.ndimage import binary_dilation
   inflated_map = binary_dilation(grid > 0.8, iterations=2)
   ```

---

## 12. 总结与展望

### 12.1 项目总结

软件组的核心任务是开发智能小车的"大脑"——主机端Python控制系统。通过整合现代化的SLAM、路径规划和通信技术，实现机器人在未知环境中的自主探索、定位和导航能力。

**关键成功因素：**

1. ✅ **技术栈现代化**：摒弃过时库，采用NumPy、Matplotlib等成熟方案
2. ✅ **通信协议清晰**：JSON+CSV混合格式，易于解析和调试
3. ✅ **代码架构清晰**：模块化设计，便于开发和测试
4. ✅ **文档详细完善**：从理论到实践，从代码到调试，全覆盖

**预期成果：**

- 完整的主机端控制系统（~2000行Python代码）
- 实时SLAM地图构建和可视化（30fps+）
- 自主导航和路径规划能力（迷宫探索成功率>90%）
- 可靠的蓝牙通信机制（延迟<50ms）
- 完善的测试和文档

### 12.2 下一步计划

**短期目标（1-2周）：**
- [ ] 完成基础通信模块
- [ ] 实现简单SLAM建图
- [ ] 完成可视化界面

**中期目标（3-6周）：**
- [ ] 完成Frontier探索算法
- [ ] 集成A*和DWA路径规划
- [ ] 实现完整导航循环

**长期目标（7-9周）：**
- [ ] 系统优化和鲁棒性提升
- [ ] 实际环境测试和调试
- [ ] 文档完善和交付

### 12.3 可扩展功能

**如果时间充裕，可以考虑：**

1. **高级SLAM**：粒子滤波、图优化
2. **深度学习**：目标识别、语义SLAM
3. **多机器人协同**：地图共享、协同探索
4. **Web监控界面**：远程监控和控制
5. **VR可视化**：沉浸式地图查看

---

## 13. 参考资料

### 13.1 算法文献

- **Frontier探测**：Yamauchi, B. (1997). "A frontier-based approach for autonomous exploration"
- **A*算法**：Hart, P. E., et al. (1968). "A Formal Basis for the Heuristic Determination of Minimum Cost Paths"
- **DWA算法**：Fox, D., et al. (1997). "The Dynamic Window Approach to Collision Avoidance"
- **占据栅格地图**：Elfes, A. (1989). "Using occupancy grids for mobile robot perception and navigation"

### 13.2 开源项目参考

- **PythonRobotics** - https://github.com/AtsushiSakai/PythonRobotics
  - A*、DWA、Frontier等算法参考实现
- **pathfinding** - https://pypi.org/project/pathfinding/
  - A*路径规划库
- **NumPy** - https://numpy.org/doc/
  - 数值计算文档
- **Matplotlib** - https://matplotlib.org/
  - 可视化文档

### 13.3 相关文档

- **固件端接口文档**：`README.md` - 串口指令速查手册
- **硬件连接方案**：`docs/硬件连接方案.md`
- **MPU6500使用方案**：`docs/MPU6500使用方案.md`
- **激光雷达使用方案**：`docs/激光雷达使用方案.md`

### 13.4 在线资源

- **SLAM教程**：https://www.cs.cmu.edu/~rasc/Download/AMRobots3.pdf
- **路径规划算法对比**：https://qiao.github.io/PathFinding.js/visual/
- **Python串口编程**：https://pyserial.readthedocs.io/
- **机器人学基础**：https://modernrobotics.northwestern.edu/

---

## 附录A：完整requirements.txt

```txt
# requirements.txt

# 核心计算库
numpy>=1.24.0
scipy>=1.10.0

# 串口通信
pyserial>=3.5

# 可视化
matplotlib>=3.7.0
pygame>=2.5.0

# 路径规划
pathfinding>=1.0.0

# 数据处理（可选）
pandas>=2.0.0

# 图像处理（可选）
opencv-python>=4.8.0
Pillow>=10.0.0

# 开发工具
pytest>=7.4.0
black>=23.0.0
flake8>=6.0.0

# 类型检查（可选）
mypy>=1.5.0
```

---

## 附录B：配置文件示例

```python
# config.py

# 串口配置
SERIAL_PORT = 'COM5'  # Windows: 'COM5', Linux: '/dev/ttyUSB0'
BAUDRATE = 115200
TIMEOUT = 1.0

# SLAM配置
MAP_WIDTH = 500          # 栅格数量
MAP_HEIGHT = 500
MAP_RESOLUTION = 0.1     # 米/栅格
MAP_ORIGIN = (MAP_WIDTH // 2, MAP_HEIGHT // 2)

# 机器人物理参数
WHEEL_BASE = 0.2         # 轮距（米）
WHEEL_RADIUS = 0.033     # 轮子半径（米）
ENCODER_PPR = 360        # 编码器每转脉冲数

# DWA参数
MAX_SPEED = 1.0          # 最大速度 m/s
MAX_YAW_RATE = 40.0      # 最大转向角速度 deg/s
MAX_ACCEL = 0.5          # 最大加速度 m/s^2
DWA_DT = 0.1             # 预测步长 s

# Frontier检测参数
FRONTIER_CLUSTER_DIST = 0.3   # 聚类距离 m
MIN_FRONTIER_SIZE = 5         # 最小前沿簇大小

# 可视化参数
VISUALIZE_RATE = 30      # 可视化帧率 fps
SHOW_LIDAR_POINTS = True # 显示雷达点云
SHOW_PATH = True         # 显示规划路径
SHOW_FRONTIERS = True    # 显示前沿点
```

---

## 附录C：Git工作流

```bash
# 创建功能分支
git checkout -b feature/slam-module

# 开发并提交
git add slam/occupancy_map.py
git commit -m "feat: implement occupancy grid SLAM"

# 推送到远程
git push origin feature/slam-module

# 合并到主分支（通过PR）
git checkout main
git merge feature/slam-module

# 标签版本
git tag -a v1.0 -m "Release version 1.0"
git push origin v1.0
```

---

**文档版本：** v2.0  
**创建日期：** 2025-10-09  
**最后更新：** 2025-10-09  
**适用项目：** xxq智能小车项目  
**编写组别：** 软件组  
**作者：** AI助手 + 软件开发团队

---

## ✨ 文档更新记录

| 日期 | 版本 | 更新内容 |
|------|------|---------|
| 2025-10-09 | v2.0 | 完整重写：技术栈评估、通信协议规范、完整代码实现、测试方案 |
| 2025-10-09 | v1.0 | 初始版本：基本功能模块介绍 |

---

**📧 联系方式：**  
如有问题请联系软件组负责人或查阅本文档FAQ部分。

**🎯 快速链接：**
- [技术栈选型](#2-技术栈评估与选型) 
- [通信协议](#3-通信协议规范)
- [代码实现](#5-具体实现代码)
- [开发任务](#6-开发任务清单按优先级)
- [测试调试](#7-测试与调试)
