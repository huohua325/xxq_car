#include "stm32f4xx_hal.h"
#include <stdio.h>
#include <math.h>  // 添加math.h头文件以解决fabsf警告
#include "main.h"
#include "motor.h"
#include "PID.h"
#include "encoder.h"
#include "OLED.h"

// 电机控制相关定义
#define MOTOR_LEFT 1
#define MOTOR_RIGHT 2

// 电机GPIO定义（根据实际硬件修改）
#define LEFT_MOTOR_DIR_PORT GPIOA
#define LEFT_MOTOR_DIR_PIN GPIO_PIN_11  // 物理左轮
#define RIGHT_MOTOR_DIR_PORT GPIOA
#define RIGHT_MOTOR_DIR_PIN GPIO_PIN_9  // 物理右轮

// 电机PWM通道定义
#define LEFT_MOTOR_PWM_CHANNEL TIM_CHANNEL_3  // PA10 物理左轮
#define RIGHT_MOTOR_PWM_CHANNEL TIM_CHANNEL_1  // PA8 物理右轮

// PID参数
//static PID_t pid1, pid2;
int balance = 0; // 平衡控制变量

// 速度校正相关定义
#define SPEED_CHECK_INTERVAL 50   // 速度检查间隔（改为50ms，提高响应速度）
#define SPEED_CORRECTION_FACTOR 0.03f  // 速度校正系数（改为3%，更平滑）
#define SPEED_INTEGRAL_LIMIT 0.2f  // 积分项限幅

// 电机校正系数（用于平衡左右轮速度差异）
#define LEFT_MOTOR_CORRECTION 1.0f  // 左电机校正系数
#define RIGHT_MOTOR_CORRECTION 1.0f  // 右电机校正系数


// 全局变量
static float g_current_speed = 0.0f;  // 当前设定的速度值
static int g_current_direction = 0;   // 当前运动方向（1=前进，-1=后退，0=停止）

extern TIM_HandleTypeDef htim2;  // 物理右轮编码器（E1A/E1B）
extern TIM_HandleTypeDef htim1;  // PWM输出
extern TIM_HandleTypeDef htim3;  // 物理左轮编码器（E2A/E2B）
// 初始化函数
// 初始化函数（单TIM1控制两个电机）
void Motor_Init(TIM_HandleTypeDef *htim) {
    // 初始化方向控制GPIO
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    // 左电机方向引脚
    GPIO_InitStruct.Pin = LEFT_MOTOR_DIR_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(LEFT_MOTOR_DIR_PORT, &GPIO_InitStruct);

    // 右电机方向引脚
    GPIO_InitStruct.Pin = RIGHT_MOTOR_DIR_PIN;
    HAL_GPIO_Init(RIGHT_MOTOR_DIR_PORT, &GPIO_InitStruct);

    // 启动PWM通道（TIM1的两个通道）
    HAL_TIM_PWM_Start(htim, LEFT_MOTOR_PWM_CHANNEL);   // 左电机 PWM
    HAL_TIM_PWM_Start(htim, RIGHT_MOTOR_PWM_CHANNEL);  // 右电机 PWM

    // 默认停止电机
    HAL_GPIO_WritePin(LEFT_MOTOR_DIR_PORT, LEFT_MOTOR_DIR_PIN, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(RIGHT_MOTOR_DIR_PORT, RIGHT_MOTOR_DIR_PIN, GPIO_PIN_RESET);
    __HAL_TIM_SET_COMPARE(htim, LEFT_MOTOR_PWM_CHANNEL, 0);
    __HAL_TIM_SET_COMPARE(htim, RIGHT_MOTOR_PWM_CHANNEL, 0);

    // 在初始化编码器后添加
    //printf("编码器初始化完成\r\n");
    // 检查编码器计数器是否正常工作
    int16_t leftCount = (int16_t)__HAL_TIM_GET_COUNTER(&htim3);
    int16_t rightCount = (int16_t)__HAL_TIM_GET_COUNTER(&htim2);
    //printf("初始计数值 - 左: %d, 右: %d\r\n", leftCount, rightCount);
}

void Motor_SetSpeed(TIM_HandleTypeDef *htim, int motor, float speedRatio, int direction) {
    // 限幅处理
    speedRatio = (speedRatio > 1.0f) ? 1.0f : (speedRatio < 0.0f) ? 0.0f : speedRatio;
    uint32_t pwm_value = (uint32_t)(speedRatio * 65535); // 计算实际PWM值

    如果需要反转某个电机的方向，取消下面的注释
    if (motor == MOTOR_RIGHT) {
        direction = -direction;  // 反转RIGHT_MOTOR的方向
    }

    if (motor == MOTOR_LEFT) {
        // 设置方向 - 左电机方向逻辑
        if (direction == 0) {
            // 停止电机
            HAL_GPIO_WritePin(LEFT_MOTOR_DIR_PORT, LEFT_MOTOR_DIR_PIN, GPIO_PIN_RESET);
            __HAL_TIM_SetCompare(htim, LEFT_MOTOR_PWM_CHANNEL, 0);
        } else if (direction == 1) {
            // 前进方向 → SET
            HAL_GPIO_WritePin(LEFT_MOTOR_DIR_PORT, LEFT_MOTOR_DIR_PIN, GPIO_PIN_SET);
            __HAL_TIM_SetCompare(htim, LEFT_MOTOR_PWM_CHANNEL, pwm_value);
        } else if (direction == -1) {
            // 后退方向 → RESET
            HAL_GPIO_WritePin(LEFT_MOTOR_DIR_PORT, LEFT_MOTOR_DIR_PIN, GPIO_PIN_RESET);
            __HAL_TIM_SetCompare(htim, LEFT_MOTOR_PWM_CHANNEL, pwm_value);
        }
    }
    else if (motor == MOTOR_RIGHT) {
        // 设置方向（统一为与左电机相同的逻辑）
        if (direction == 0) {
            // 停止电机
            HAL_GPIO_WritePin(RIGHT_MOTOR_DIR_PORT, RIGHT_MOTOR_DIR_PIN, GPIO_PIN_RESET);
            __HAL_TIM_SetCompare(htim, RIGHT_MOTOR_PWM_CHANNEL, 0);
        } else if (direction == 1) {
            // 前进方向 → SET（与LEFT_MOTOR相同）
            HAL_GPIO_WritePin(RIGHT_MOTOR_DIR_PORT, RIGHT_MOTOR_DIR_PIN, GPIO_PIN_SET);
            __HAL_TIM_SetCompare(htim, RIGHT_MOTOR_PWM_CHANNEL, pwm_value);
        } else if (direction == -1) {
            // 后退方向 → RESET（与LEFT_MOTOR相同）
            HAL_GPIO_WritePin(RIGHT_MOTOR_DIR_PORT, RIGHT_MOTOR_DIR_PIN, GPIO_PIN_RESET);
            __HAL_TIM_SetCompare(htim, RIGHT_MOTOR_PWM_CHANNEL, pwm_value);
        }
    }
}

// 速度校正函数（PID）
void Adjust_Speed(TIM_HandleTypeDef *htim, TIM_HandleTypeDef *htim_encoder_left, TIM_HandleTypeDef *htim_encoder_right) {
    static uint32_t last_check_time = 0;
    static float speed_error_integral = 0.0f;  // 速度误差积分
    uint32_t current_time = HAL_GetTick();

    // 每SPEED_CHECK_INTERVAL毫秒检查一次速度
    if (current_time - last_check_time >= SPEED_CHECK_INTERVAL && g_current_speed > 0) {
        float dt = (current_time - last_check_time) / 1000.0f;
        float left_speed, right_speed;

        // 获取两个电机的实际速度
        Encoder_GetSpeeds(htim_encoder_left, htim_encoder_right, &left_speed, &right_speed, dt);

        //printf("左轮速度: %d, 右轮速度: %d, dt: %d\r\n", (int16_t)left_speed, (int16_t)right_speed, (int16_t)dt);
        // 计算速度差异
        float speed_diff = left_speed - right_speed;

        // 更新积分项（带限幅）
        speed_error_integral += speed_diff * dt;
        if (speed_error_integral > SPEED_INTEGRAL_LIMIT) {
            speed_error_integral = SPEED_INTEGRAL_LIMIT;
        } else if (speed_error_integral < -SPEED_INTEGRAL_LIMIT) {
            speed_error_integral = -SPEED_INTEGRAL_LIMIT;
        }

        // 计算总的校正量（比例项 + 积分项）
        float correction = SPEED_CORRECTION_FACTOR * (speed_diff + speed_error_integral);

        // 应用校正
        if (fabsf(speed_diff) > 0.05f) {  // 降低校正阈值到5%
            if (speed_diff > 0) {
                // 左轮快，降低左轮速度，增加右轮速度
                Motor_SetSpeed(htim, MOTOR_LEFT, g_current_speed * (1.0f - correction), g_current_direction);
                Motor_SetSpeed(htim, MOTOR_RIGHT, g_current_speed * (1.0f + correction * 0.5f), g_current_direction);
            } else {
                // 右轮快，降低右轮速度，增加左轮速度
                Motor_SetSpeed(htim, MOTOR_RIGHT, g_current_speed * (1.0f - correction), g_current_direction);
                Motor_SetSpeed(htim, MOTOR_LEFT, g_current_speed * (1.0f + correction * 0.5f), g_current_direction);
            }
        }

        last_check_time = current_time;
    }
}

// 运动控制函数（使用GPIO控制方向）
void Car_Forward(TIM_HandleTypeDef *htim, float speed) {
    speed = (speed > 1.0f) ? 1.0f : (speed < 0.0f) ? 0.0f : speed;
    g_current_speed = speed;
    g_current_direction = 1;
    Motor_SetSpeed(htim, MOTOR_LEFT, speed, 1);   // 左轮前进
    Motor_SetSpeed(htim, MOTOR_RIGHT, speed, 1);  // 右轮前进
}

void Car_Backward(TIM_HandleTypeDef *htim, float speed) {
    speed = (speed > 1.0f) ? 1.0f : (speed < 0.0f) ? 0.0f : speed;
    g_current_speed = speed;
    g_current_direction = -1;
    Motor_SetSpeed(htim, MOTOR_LEFT, speed, -1);   // 左轮后退
    Motor_SetSpeed(htim, MOTOR_RIGHT, speed, -1);  // 右轮后退
}

void Car_Stop(TIM_HandleTypeDef *htim) {
    g_current_speed = 0;
    g_current_direction = 0;
    Motor_SetSpeed(htim, MOTOR_LEFT, 0.0f, 0);    // 左轮停止
    Motor_SetSpeed(htim, MOTOR_RIGHT, 0.0f, 0);   // 右轮停止
}

void Car_TurnLeft(TIM_HandleTypeDef *htim, float speed) {
    speed = (speed > 1.0f) ? 1.0f : (speed < 0.0f) ? 0.0f : speed;
    Motor_SetSpeed(htim, MOTOR_LEFT, speed, 0);    // 左轮停止
    Motor_SetSpeed(htim, MOTOR_RIGHT, speed, 1);   // 右轮前进
    HAL_Delay(200);
    Car_Stop(htim);
}

void Car_TurnRight(TIM_HandleTypeDef *htim, float speed) {
    speed = (speed > 1.0f) ? 1.0f : (speed < 0.0f) ? 0.0f : speed;
    Motor_SetSpeed(htim, MOTOR_LEFT, speed, 1);    // 左轮前进
    Motor_SetSpeed(htim, MOTOR_RIGHT, speed, 0);   // 右轮停止
    HAL_Delay(200);
    Car_Stop(htim);
}

// 注释：电机速度已通过校正系数实现平衡


// ======================== PID速度控制系统 ========================
// 定义两个PID控制器：分别控制左右电机速度
static PID_TypeDef pid_left_motor;
static PID_TypeDef pid_right_motor;

// 目标速度和方向
static float target_speed_left = 0.0f;
static float target_speed_right = 0.0f;
static int target_direction = 0;  // 1=前进, -1=后退, 0=停止

// 实际速度（供外部读取，避免重复调用编码器读取）
static float actual_speed_left = 0.0f;
static float actual_speed_right = 0.0f;

// PID控制定时
static uint32_t last_pid_time = 0;
#define PID_CONTROL_INTERVAL 20  // PID控制周期：20ms (50Hz)

// 初始化PID控制器
void Motor_PID_Init(void) {
    // 初始化左电机PID控制器
    // PID_Init(PID_TypeDef *pid, float kp, float ki, float kd, float maxOutput)
    // maxOutput设为1.0，表示PWM占空比最大100%
    PID_Init(&pid_left_motor, 0.15f, 0.05f, 0.01f, 1.0f);
    
    // 初始化右电机PID控制器
    PID_Init(&pid_right_motor, 0.15f, 0.05f, 0.01f, 1.0f);
    
    // 初始化目标速度
    target_speed_left = 0.0f;
    target_speed_right = 0.0f;
    target_direction = 0;
    
    last_pid_time = HAL_GetTick();
}

// PID速度控制主循环（需要在main函数中周期性调用）
void Motor_PID_Control(TIM_HandleTypeDef *htim_pwm, TIM_HandleTypeDef *htim_encoder_left, 
                       TIM_HandleTypeDef *htim_encoder_right) {
    uint32_t current_time = HAL_GetTick();
    
    // 每PID_CONTROL_INTERVAL毫秒执行一次
    if (current_time - last_pid_time >= PID_CONTROL_INTERVAL) {
        float dt = (current_time - last_pid_time) / 1000.0f;
        last_pid_time = current_time;
        
        // 读取当前速度（只在PID控制循环中读取，避免与其他地方冲突）
        Encoder_GetSpeeds(htim_encoder_left, htim_encoder_right, 
                          &actual_speed_left, &actual_speed_right, dt);
        
        // 如果目标速度为0，直接停止电机
        if (target_speed_left == 0.0f && target_speed_right == 0.0f) {
            Motor_SetSpeed(htim_pwm, MOTOR_LEFT, 0.0f, 0);
            Motor_SetSpeed(htim_pwm, MOTOR_RIGHT, 0.0f, 0);
            return;
        }
        
        // PID计算：根据目标速度和当前速度计算PWM输出
        float pwm_left = PID_Calculate(&pid_left_motor, target_speed_left, fabsf(actual_speed_left));
        float pwm_right = PID_Calculate(&pid_right_motor, target_speed_right, fabsf(actual_speed_right));
        
        // 应用PWM到电机
        // 注意：由于硬件接线，LEFT_MOTOR实际控制物理右轮，RIGHT_MOTOR实际控制物理左轮
        // 所以这里交换：左编码器的PID输出 → RIGHT_MOTOR（物理左轮）
        //            右编码器的PID输出 → LEFT_MOTOR（物理右轮）
        Motor_SetSpeed(htim_pwm, MOTOR_RIGHT, pwm_left, target_direction);   // 左编码器→物理左轮
        Motor_SetSpeed(htim_pwm, MOTOR_LEFT, pwm_right, target_direction);   // 右编码器→物理右轮
    }
}

// 设置前进目标速度
void Car_Forward_PID(float target_rps) {
    target_rps = (target_rps < 0.0f) ? 0.0f : target_rps;  // 限制最小值
    target_speed_left = target_rps;
    target_speed_right = target_rps;
    target_direction = 1;  // 前进
}

// 设置后退目标速度
void Car_Backward_PID(float target_rps) {
    target_rps = (target_rps < 0.0f) ? 0.0f : target_rps;  // 限制最小值
    target_speed_left = target_rps;
    target_speed_right = target_rps;
    target_direction = -1;  // 后退
}

// 停止并清除PID状态
void Car_Stop_PID(void) {
    target_speed_left = 0.0f;
    target_speed_right = 0.0f;
    target_direction = 0;
    
    // 清除PID积分项，防止启动时的积分累积
    pid_left_motor.integral = 0.0f;
    pid_left_motor.error = 0.0f;
    pid_left_motor.lastError = 0.0f;
    
    pid_right_motor.integral = 0.0f;
    pid_right_motor.error = 0.0f;
    pid_right_motor.lastError = 0.0f;
}

// 获取实际速度（不会干扰PID控制的编码器读取）
void Motor_GetActualSpeed(float *left_rps, float *right_rps) {
    *left_rps = actual_speed_left;
    *right_rps = actual_speed_right;
}

// 获取编码器原始计数值（调试用）
void Motor_GetEncoderRawCount(TIM_HandleTypeDef *htim_left, TIM_HandleTypeDef *htim_right, 
                               int16_t *cnt_left, int16_t *cnt_right) {
    *cnt_left = (int16_t)__HAL_TIM_GET_COUNTER(htim_left);
    *cnt_right = (int16_t)__HAL_TIM_GET_COUNTER(htim_right);
}

