# 固件端通信协议实现代码

## 📌 说明

以下代码需要添加到 `xxq/Core/Src/main.c` 文件中，实现与Python主机端的通信协议。

## 1️⃣ 在文件开头添加全局变量

在 `main.c` 的 `/* USER CODE BEGIN PV */` 和 `/* USER CODE END PV */` 之间添加：

```c
/* USER CODE BEGIN PV */

// ========== 通信协议相关 ==========

// UART4接收缓冲区（用于接收PC命令）
char uart4_rx_buffer[256];
uint8_t uart4_rx_char;
uint8_t uart4_rx_index = 0;

// 里程计累计计数
static int32_t left_encoder_count = 0;
static int32_t right_encoder_count = 0;

// 位姿估计（简化版）
static float robot_x = 0.0f;
static float robot_y = 0.0f;
static float robot_theta = 0.0f;

/* USER CODE END PV */
```

## 2️⃣ 添加数据发送函数

在 `main.c` 中添加以下函数（在 `main()` 函数之前）：

```c
/* USER CODE BEGIN 0 */

/**
 * @brief 发送雷达JSON数据
 * @param huart 串口句柄（UART4）
 * @param result 雷达扫描结果指针
 */
void Send_Lidar_JSON(UART_HandleTypeDef *huart, RadarScanResult *result) {
    char json_buf[2048];
    int pos = 0;
    
    // 构建JSON头部
    pos += snprintf(json_buf + pos, sizeof(json_buf) - pos, 
                    "{\"type\":\"LIDAR\",\"timestamp\":%lu,\"data\":{", HAL_GetTick());
    pos += snprintf(json_buf + pos, sizeof(json_buf) - pos,
                    "\"total_points\":%lu,\"angle_coverage\":%.1f,\"sectors\":[",
                    result->total_points, result->coverage_percent * 3.6f);
    
    // 添加8个扇区数据
    for (int i = 0; i < 8; i++) {
        pos += snprintf(json_buf + pos, sizeof(json_buf) - pos,
                        "{\"sector_id\":%d,\"angle_center\":%d,\"count\":%lu,\"min_dist\":%.2f,\"avg_dist\":%.2f}",
                        i, i*45, result->sectors[i].count, 
                        result->sectors[i].min_dist, result->sectors[i].avg_dist);
        if (i < 7) pos += snprintf(json_buf + pos, sizeof(json_buf) - pos, ",");
    }
    
    // 结束JSON
    pos += snprintf(json_buf + pos, sizeof(json_buf) - pos, "]}}\n");
    
    // 发送
    HAL_UART_Transmit(huart, (uint8_t*)json_buf, pos, 1000);
}

/**
 * @brief 发送MPU数据（CSV格式）
 */
void Send_MPU_CSV(UART_HandleTypeDef *huart, float roll, float pitch, 
                  float ax, float ay, float az, float gx, float gy, float gz) {
    char csv_buf[128];
    int len = snprintf(csv_buf, sizeof(csv_buf),
                       "MPU,%lu,%.2f,%.2f,%.3f,%.3f,%.3f,%.2f,%.2f,%.2f\n",
                       HAL_GetTick(), roll, pitch, ax, ay, az, gx, gy, gz);
    HAL_UART_Transmit(huart, (uint8_t*)csv_buf, len, 100);
}

/**
 * @brief 发送里程计数据（CSV格式）
 */
void Send_Odometry_CSV(UART_HandleTypeDef *huart, float left_rps, float right_rps) {
    char csv_buf[128];
    int len = snprintf(csv_buf, sizeof(csv_buf),
                       "ODO,%lu,%.2f,%.2f,%ld,%ld\n",
                       HAL_GetTick(), left_rps, right_rps, 
                       left_encoder_count, right_encoder_count);
    HAL_UART_Transmit(huart, (uint8_t*)csv_buf, len, 100);
}

/**
 * @brief 发送位姿估计（CSV格式）
 */
void Send_Pose_CSV(UART_HandleTypeDef *huart, float x, float y, float theta) {
    char csv_buf[64];
    int len = snprintf(csv_buf, sizeof(csv_buf),
                       "POSE,%lu,%.3f,%.3f,%.2f\n",
                       HAL_GetTick(), x, y, theta);
    HAL_UART_Transmit(huart, (uint8_t*)csv_buf, len, 100);
}

/**
 * @brief 解析PC命令
 * @param cmd 命令字符串
 */
void Parse_PC_Command(char *cmd) {
    // 导航指令：NAV,x,y,theta,speed
    if(strncmp(cmd, "NAV,", 4) == 0) {
        float x, y, theta, speed;
        sscanf(cmd, "NAV,%f,%f,%f,%f", &x, &y, &theta, &speed);
        
        // TODO: 实现导航控制逻辑
        printf("收到导航指令: x=%.2f, y=%.2f, theta=%.2f, speed=%.2f\n", x, y, theta, speed);
    }
    // 速度指令：SPD,left_speed,right_speed
    else if(strncmp(cmd, "SPD,", 4) == 0) {
        float left_rps, right_rps;
        sscanf(cmd, "SPD,%f,%f", &left_rps, &right_rps);
        
        // 设置电机速度
        Car_Forward_PID(left_rps);  // 简化：暂时只支持同速前进
        printf("收到速度指令: left=%.2f, right=%.2f\n", left_rps, right_rps);
    }
    // 模式指令：MODE,id
    else if(strncmp(cmd, "MODE,", 5) == 0) {
        int mode;
        sscanf(cmd, "MODE,%d", &mode);
        
        switch(mode) {
            case 0: 
                Car_Stop_PID();
                printf("模式: 停止\n");
                break;
            case 1: 
                Car_Forward_PID(1.5);
                printf("模式: PID前进\n");
                break;
            case 2: 
                Car_Backward_PID(1.5);
                printf("模式: PID后退\n");
                break;
            case 3:
                // Car_TurnLeft(&htim1, 0.5);
                printf("模式: 左转\n");
                break;
            case 4:
                // Car_TurnRight(&htim1, 0.5);
                printf("模式: 右转\n");
                break;
            case 5:
                printf("模式: 自动导航\n");
                break;
            default:
                printf("未知模式: %d\n", mode);
        }
    }
    // 雷达扫描请求：A
    else if(cmd[0] == 'A') {
        printf("收到雷达扫描请求\n");
        
        RadarScanResult scan_result;
        Radar_PerformScan(&huart3, &huart2, &scan_result);
        Send_Lidar_JSON(&huart4, &scan_result);
    }
}

/* USER CODE END 0 */
```

## 3️⃣ 添加UART中断回调

在 `main.c` 中添加（在 `main()` 函数之后）：

```c
/* USER CODE BEGIN 4 */

/**
 * @brief UART接收完成中断回调
 */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    if(huart == &huart4) {
        // UART4：接收PC命令
        if(uart4_rx_char == '\n' || uart4_rx_char == '\r') {
            // 命令结束，解析
            uart4_rx_buffer[uart4_rx_index] = '\0';
            if(uart4_rx_index > 0) {
                Parse_PC_Command(uart4_rx_buffer);
            }
            uart4_rx_index = 0;
        } else {
            // 添加字符到缓冲区
            if(uart4_rx_index < sizeof(uart4_rx_buffer) - 1) {
                uart4_rx_buffer[uart4_rx_index++] = uart4_rx_char;
            } else {
                // 缓冲区溢出，重置
                uart4_rx_index = 0;
            }
        }
        
        // 继续接收下一个字符
        HAL_UART_Receive_IT(&huart4, &uart4_rx_char, 1);
    }
}

/* USER CODE END 4 */
```

## 4️⃣ 修改 main() 函数

在 `main()` 函数的 `/* USER CODE BEGIN 2 */` 部分添加初始化代码：

```c
/* USER CODE BEGIN 2 */

// 初始化电机和编码器
Motor_Init(&htim1);
Motor_PID_Init();
Encoder_Init(&htim3, &htim2);

// 初始化MPU6500
MPU6500_Init(&hi2c1);

// 初始化雷达
Radar_Init(&huart3, &huart2);

// 启动UART4中断接收（蓝牙通信）
HAL_UART_Receive_IT(&huart4, &uart4_rx_char, 1);

printf("\n========================================\n");
printf("xxq 智能小车固件已启动\n");
printf("蓝牙通信: UART4 @ 115200\n");
printf("等待主机端连接...\n");
printf("========================================\n\n");

/* USER CODE END 2 */
```

在 `main()` 函数的主循环 `/* USER CODE BEGIN 3 */` 部分添加：

```c
/* USER CODE BEGIN 3 */

    // PID控制循环（必须持续调用）
    Motor_PID_Control(&htim1, &htim3, &htim2);
    
    static uint32_t last_mpu_time = 0;
    static uint32_t last_odom_time = 0;
    static uint32_t last_pose_time = 0;
    
    uint32_t now = HAL_GetTick();
    
    // 50Hz发送MPU数据
    if(now - last_mpu_time >= 20) {
        MPU6500_Data mpu_data;
        MPU6500_Calib calib = {0};
        float roll, pitch;
        
        MPU6500_Read_All(&hi2c1, &mpu_data);
        MPU6500_Convert_Unit(&mpu_data);
        MPU6500_CalculateAngles(&mpu_data, &roll, &pitch);
        
        Send_MPU_CSV(&huart4, roll, pitch, 
                    mpu_data.Accel_X_mps2, mpu_data.Accel_Y_mps2, mpu_data.Accel_Z_mps2,
                    mpu_data.Gyro_X_dps, mpu_data.Gyro_Y_dps, mpu_data.Gyro_Z_dps);
        
        last_mpu_time = now;
    }
    
    // 50Hz发送里程计数据
    if(now - last_odom_time >= 20) {
        float left_rps, right_rps;
        Motor_GetActualSpeed(&left_rps, &right_rps);
        
        // 更新累计计数（简化估算）
        left_encoder_count += (int32_t)(left_rps * 1560 * 0.02f);
        right_encoder_count += (int32_t)(right_rps * 780 * 0.02f);
        
        Send_Odometry_CSV(&huart4, left_rps, right_rps);
        
        last_odom_time = now;
    }
    
    // 20Hz发送位姿估计（简化版，暂时发送0,0,0）
    if(now - last_pose_time >= 50) {
        // TODO: 实现真实的位姿估计（融合里程计和MPU）
        Send_Pose_CSV(&huart4, robot_x, robot_y, robot_theta);
        
        last_pose_time = now;
    }

/* USER CODE END 3 */
```

## 5️⃣ 编译和烧录

1. **在STM32CubeIDE中编译项目**
   ```
   Project → Build All (Ctrl+B)
   ```

2. **烧录到STM32**
   ```
   Run → Debug (F11)
   ```

3. **验证通信**
   - 打开串口助手（115200波特率）
   - 应该能看到定期发送的MPU和ODO数据
   - 发送 `A` 命令，应该收到雷达JSON数据

## 6️⃣ 测试命令

在串口助手或Python端发送以下命令测试：

```
A                    # 请求雷达扫描
MODE,0              # 停止
MODE,1              # PID前进
SPD,1.5,1.5         # 设置速度（左右轮1.5 RPS）
NAV,2.0,1.0,90,2.0  # 导航到目标点
```

## 📌 注意事项

1. **UART4配置**: 确保在CubeMX中已配置UART4，波特率115200
2. **包含头文件**: 确保包含了所有必要的头文件（radar.h, Motor.h, mpu6500.h等）
3. **调试输出**: 可以保留printf语句用于调试，通过UART2查看
4. **内存管理**: JSON缓冲区较大（2KB），注意栈空间
5. **中断优先级**: 确保UART4中断优先级合适

## ✅ 验收标准

- [ ] 固件能正常编译无错误
- [ ] 烧录后能通过UART2看到启动信息
- [ ] Python端能收到MPU/ODO数据（50Hz）
- [ ] 发送 `A` 命令能收到雷达JSON数据
- [ ] 发送 `MODE,0` 能停止电机
- [ ] 发送 `SPD,1.5,1.5` 能控制电机转速




