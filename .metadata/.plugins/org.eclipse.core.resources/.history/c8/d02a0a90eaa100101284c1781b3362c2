#include "stm32f4xx_hal.h"
#include <stdio.h>
#include <math.h>  // 添加math.h头文件以解决fabsf警告
#include "main.h"
#include "motor.h"
#include "PID.h"
#include "encoder.h"
#include "OLED.h"

// 电机控制相关定义
#define MOTOR_LEFT 1
#define MOTOR_RIGHT 2

// 电机GPIO定义（根据实际硬件修改）
#define LEFT_MOTOR_DIR_PORT GPIOA
#define LEFT_MOTOR_DIR_PIN GPIO_PIN_9  // 物理左轮 (交换后)
#define RIGHT_MOTOR_DIR_PORT GPIOA
#define RIGHT_MOTOR_DIR_PIN GPIO_PIN_11  // 物理右轮 (交换后)

// 电机PWM通道定义
#define LEFT_MOTOR_PWM_CHANNEL TIM_CHANNEL_1  // PA8 物理左轮 (交换后)
#define RIGHT_MOTOR_PWM_CHANNEL TIM_CHANNEL_3  // PA10 物理右轮 (交换后)

// PID参数
//static PID_t pid1, pid2;
int balance = 0; // 平衡控制变量

// 速度校正相关定义
#define SPEED_CHECK_INTERVAL 50   // 速度检查间隔（改为50ms，提高响应速度）
#define SPEED_CORRECTION_FACTOR 0.03f  // 速度校正系数（改为3%，更平滑）
#define SPEED_INTEGRAL_LIMIT 0.2f  // 积分项限幅

// 电机校正系数（用于平衡左右轮速度差异）
#define LEFT_MOTOR_CORRECTION 1.0f  // 左电机校正系数
#define RIGHT_MOTOR_CORRECTION 1.0f  // 右电机校正系数


// 全局变量
static float g_current_speed = 0.0f;  // 当前设定的速度值
static int g_current_direction = 0;   // 当前运动方向（1=前进，-1=后退，0=停止）

extern TIM_HandleTypeDef htim2;  // 实际硬件：物理右轮编码器（PA15/PB3）
extern TIM_HandleTypeDef htim1;  // PWM输出
extern TIM_HandleTypeDef htim3;  // 实际硬件：物理左轮编码器（PC6/PC7）
// 初始化函数
// 初始化函数（单TIM1控制两个电机）
void Motor_Init(TIM_HandleTypeDef *htim) {
    // 初始化方向控制GPIO
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    // 左电机方向引脚
    GPIO_InitStruct.Pin = LEFT_MOTOR_DIR_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(LEFT_MOTOR_DIR_PORT, &GPIO_InitStruct);

    // 右电机方向引脚
    GPIO_InitStruct.Pin = RIGHT_MOTOR_DIR_PIN;
    HAL_GPIO_Init(RIGHT_MOTOR_DIR_PORT, &GPIO_InitStruct);

    // 启动PWM通道（TIM1的两个通道）
    HAL_TIM_PWM_Start(htim, LEFT_MOTOR_PWM_CHANNEL);   // 左电机 PWM
    HAL_TIM_PWM_Start(htim, RIGHT_MOTOR_PWM_CHANNEL);  // 右电机 PWM

    // 默认停止电机
    HAL_GPIO_WritePin(LEFT_MOTOR_DIR_PORT, LEFT_MOTOR_DIR_PIN, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(RIGHT_MOTOR_DIR_PORT, RIGHT_MOTOR_DIR_PIN, GPIO_PIN_RESET);
    __HAL_TIM_SET_COMPARE(htim, LEFT_MOTOR_PWM_CHANNEL, 0);       // 左轮：PWM=0 停止
    
    // 右轮：尝试禁用PWM输出（完全停止信号）
    HAL_TIM_PWM_Stop(htim, RIGHT_MOTOR_PWM_CHANNEL);
    __HAL_TIM_SET_COMPARE(htim, RIGHT_MOTOR_PWM_CHANNEL, 0);

    // 在初始化编码器后添加
    //printf("编码器初始化完成\r\n");
    // 检查编码器计数器是否正常工作
    int16_t leftCount = (int16_t)__HAL_TIM_GET_COUNTER(&htim3);
    int16_t rightCount = (int16_t)__HAL_TIM_GET_COUNTER(&htim2);
    //printf("初始计数值 - 左: %d, 右: %d\r\n", leftCount, rightCount);
}

void Motor_SetSpeed(TIM_HandleTypeDef *htim, int motor, float speedRatio, int direction) {
    // 限幅处理
    speedRatio = (speedRatio > 1.0f) ? 1.0f : (speedRatio < 0.0f) ? 0.0f : speedRatio;
    
    // ⚠️ 仅在direction=0或speedRatio=0时才强制停止
    if (speedRatio == 0.0f || direction == 0) {
        if (motor == MOTOR_LEFT) {
            // 左轮：方向RESET + PWM=0（正常停止）
            HAL_GPIO_WritePin(LEFT_MOTOR_DIR_PORT, LEFT_MOTOR_DIR_PIN, GPIO_PIN_RESET);
            __HAL_TIM_SetCompare(htim, LEFT_MOTOR_PWM_CHANNEL, 0);
        } else if (motor == MOTOR_RIGHT) {
            // 右轮：完全禁用PWM输出（最可靠的停止方法）
            HAL_TIM_PWM_Stop(htim, RIGHT_MOTOR_PWM_CHANNEL);
            HAL_GPIO_WritePin(RIGHT_MOTOR_DIR_PORT, RIGHT_MOTOR_DIR_PIN, GPIO_PIN_RESET);
            __HAL_TIM_SetCompare(htim, RIGHT_MOTOR_PWM_CHANNEL, 0);
        }
        return;
    }
    
    // 右轮特殊处理：如果之前被停止了，需要重新启动PWM通道
    if (motor == MOTOR_RIGHT) {
        HAL_TIM_PWM_Start(htim, RIGHT_MOTOR_PWM_CHANNEL);
    }
    
    // ⚠️ 右轮PWM反向：实测发现右轮PWM与速度成反比
    float actual_ratio = speedRatio;
    if (motor == MOTOR_RIGHT) {
        actual_ratio = 1.0f - speedRatio;  // 反转PWM：0.3变成0.7
    }
    
    uint32_t pwm_value = (uint32_t)(actual_ratio * 65535); // 计算实际PWM值

    // 如果需要反转某个电机的方向
    // 依据接线：左电机方向需要反转以匹配"前进"语义
    if (motor == MOTOR_LEFT) {
        direction = -direction;
    }

    if (motor == MOTOR_LEFT) {
        // 设置方向 - 左电机方向逻辑
        if (direction == 1) {
            // 前进方向 → SET
            HAL_GPIO_WritePin(LEFT_MOTOR_DIR_PORT, LEFT_MOTOR_DIR_PIN, GPIO_PIN_SET);
            __HAL_TIM_SetCompare(htim, LEFT_MOTOR_PWM_CHANNEL, pwm_value);
        } else if (direction == -1) {
            // 后退方向 → RESET
            HAL_GPIO_WritePin(LEFT_MOTOR_DIR_PORT, LEFT_MOTOR_DIR_PIN, GPIO_PIN_RESET);
            __HAL_TIM_SetCompare(htim, LEFT_MOTOR_PWM_CHANNEL, pwm_value);
        }
    }
    else if (motor == MOTOR_RIGHT) {
        // 设置方向（统一为与左电机相同的逻辑）
        if (direction == 1) {
            // 前进方向 → SET（与LEFT_MOTOR相同）
            HAL_GPIO_WritePin(RIGHT_MOTOR_DIR_PORT, RIGHT_MOTOR_DIR_PIN, GPIO_PIN_SET);
            __HAL_TIM_SetCompare(htim, RIGHT_MOTOR_PWM_CHANNEL, pwm_value);
        } else if (direction == -1) {
            // 后退方向 → RESET（与LEFT_MOTOR相同）
            HAL_GPIO_WritePin(RIGHT_MOTOR_DIR_PORT, RIGHT_MOTOR_DIR_PIN, GPIO_PIN_RESET);
            __HAL_TIM_SetCompare(htim, RIGHT_MOTOR_PWM_CHANNEL, pwm_value);
        }
    }
}

// 速度校正函数（PID）
void Adjust_Speed(TIM_HandleTypeDef *htim, TIM_HandleTypeDef *htim_encoder_left, TIM_HandleTypeDef *htim_encoder_right) {
    static uint32_t last_check_time = 0;
    static float speed_error_integral = 0.0f;  // 速度误差积分
    uint32_t current_time = HAL_GetTick();

    // 每SPEED_CHECK_INTERVAL毫秒检查一次速度
    if (current_time - last_check_time >= SPEED_CHECK_INTERVAL && g_current_speed > 0) {
        float dt = (current_time - last_check_time) / 1000.0f;
        float left_speed, right_speed;

        // 获取两个电机的实际速度
        Encoder_GetSpeeds(htim_encoder_left, htim_encoder_right, &left_speed, &right_speed, dt);

        //printf("左轮速度: %d, 右轮速度: %d, dt: %d\r\n", (int16_t)left_speed, (int16_t)right_speed, (int16_t)dt);
        // 计算速度差异
        float speed_diff = left_speed - right_speed;

        // 更新积分项（带限幅）
        speed_error_integral += speed_diff * dt;
        if (speed_error_integral > SPEED_INTEGRAL_LIMIT) {
            speed_error_integral = SPEED_INTEGRAL_LIMIT;
        } else if (speed_error_integral < -SPEED_INTEGRAL_LIMIT) {
            speed_error_integral = -SPEED_INTEGRAL_LIMIT;
        }

        // 计算总的校正量（比例项 + 积分项）
        float correction = SPEED_CORRECTION_FACTOR * (speed_diff + speed_error_integral);

        // 应用校正
        if (fabsf(speed_diff) > 0.05f) {  // 降低校正阈值到5%
            if (speed_diff > 0) {
                // 左轮快，降低左轮速度，增加右轮速度
                Motor_SetSpeed(htim, MOTOR_LEFT, g_current_speed * (1.0f - correction), g_current_direction);
                Motor_SetSpeed(htim, MOTOR_RIGHT, g_current_speed * (1.0f + correction * 0.5f), g_current_direction);
            } else {
                // 右轮快，降低右轮速度，增加左轮速度
                Motor_SetSpeed(htim, MOTOR_RIGHT, g_current_speed * (1.0f - correction), g_current_direction);
                Motor_SetSpeed(htim, MOTOR_LEFT, g_current_speed * (1.0f + correction * 0.5f), g_current_direction);
            }
        }

        last_check_time = current_time;
    }
}

// 运动控制函数（使用GPIO控制方向）
void Car_Forward(TIM_HandleTypeDef *htim, float speed) {
    speed = (speed > 1.0f) ? 1.0f : (speed < 0.0f) ? 0.0f : speed;
    g_current_speed = speed;
    g_current_direction = 1;
    Motor_SetSpeed(htim, MOTOR_LEFT, speed, 1);   // 左轮前进
    Motor_SetSpeed(htim, MOTOR_RIGHT, speed, 1);  // 右轮前进
}

void Car_Backward(TIM_HandleTypeDef *htim, float speed) {
    speed = (speed > 1.0f) ? 1.0f : (speed < 0.0f) ? 0.0f : speed;
    g_current_speed = speed;
    g_current_direction = -1;
    Motor_SetSpeed(htim, MOTOR_LEFT, speed, -1);   // 左轮后退
    Motor_SetSpeed(htim, MOTOR_RIGHT, speed, -1);  // 右轮后退
}

void Car_Stop(TIM_HandleTypeDef *htim) {
    g_current_speed = 0;
    g_current_direction = 0;
    Motor_SetSpeed(htim, MOTOR_LEFT, 0.0f, 0);    // 左轮停止
    Motor_SetSpeed(htim, MOTOR_RIGHT, 0.0f, 0);   // 右轮停止
}

void Car_TurnLeft(TIM_HandleTypeDef *htim, float speed) {
    speed = (speed > 1.0f) ? 1.0f : (speed < 0.0f) ? 0.0f : speed;
    Motor_SetSpeed(htim, MOTOR_LEFT, speed, 0);    // 左轮停止
    Motor_SetSpeed(htim, MOTOR_RIGHT, speed, 1);   // 右轮前进
    HAL_Delay(200);
    Car_Stop(htim);
}

void Car_TurnRight(TIM_HandleTypeDef *htim, float speed) {
    speed = (speed > 1.0f) ? 1.0f : (speed < 0.0f) ? 0.0f : speed;
    Motor_SetSpeed(htim, MOTOR_LEFT, speed, 1);    // 左轮前进
    Motor_SetSpeed(htim, MOTOR_RIGHT, speed, 0);   // 右轮停止
    HAL_Delay(200);
    Car_Stop(htim);
}

// 注释：电机速度已通过校正系数实现平衡


// ======================== 双轮PID闭环控制系统 ========================
// 左轮和右轮：都使用PID闭环控制，独立跟踪目标速度

static PID_TypeDef pid_left_motor;   // 左轮PID控制器
static PID_TypeDef pid_right_motor;  // 右轮PID控制器

// 目标速度
static float target_speed = 0.0f;    // 当前实际目标速度（平滑后）
static float desired_speed = 0.0f;   // 用户设定的期望速度
static int target_direction = 0;     // 1=前进, -1=后退, 0=停止

// 实际速度（供外部读取）
static float actual_speed_left = 0.0f;
static float actual_speed_right = 0.0f;

// 差速补偿状态
static float speed_diff_integral = 0.0f;  // 速度差积分

// 位置同步控制（里程计累积）
static float position_left = 0.0f;   // 左轮累积圈数
static float position_right = 0.0f;  // 右轮累积圈数

// 控制定时
static uint32_t last_pid_time = 0;
#define PID_CONTROL_INTERVAL 20  // 控制周期：20ms (50Hz)

// ========== 基于实际运行数据修正的前馈参数 ==========
// 左轮实际运行：PWM=0.35 → 1.48 RPS，需要0.36 → 1.52 RPS（匹配右轮）
// 最终修正：PWM = 0.135 × RPS + 0.16（微调+0.02）
#define LEFT_KFF           0.135f  // 前馈系数 (PWM per RPS)
#define LEFT_PWM_MIN       0.16f   // 最小PWM（微调+0.02以匹配右轮速度）
#define CORR_GAIN          0.50f   // PID校正注入比例（平衡修正速度和稳定性）
#define SPEED_LPF_ALPHA    0.5f    // 速度滤波系数（降低以减少噪声影响）

// ========== 差速补偿控制参数 ==========
#define DIFF_COMPENSATION_ENABLE  1       // 使能差速补偿（1=启用，0=禁用）
#define DIFF_COMP_GAIN           0.20f    // 差速补偿增益（提高以适应地面负载差异）
#define DIFF_COMP_INTEGRAL_LIMIT 0.08f    // 差速积分限幅（提高以处理持续偏差）

// ========== 位置同步控制参数 ==========
#define POSITION_SYNC_ENABLE     1       // 使能位置同步（1=启用，0=禁用）
#define POSITION_SYNC_GAIN       0.25f   // 位置差补偿增益（提高2.5倍，强力修正）

// ========== 速度偏置补偿（针对持续性速度差）==========
#define SPEED_BIAS_ENABLE        1       // 使能速度偏置补偿（1=启用，0=禁用）
#define RIGHT_WHEEL_SPEED_BIAS  -0.02f   // 右轮速度偏置（负值=减速，单位：RPS）

// ========== PWM上限限制（防止某轮过快）==========
#define PWM_LIMIT_ENABLE         1       // 使能PWM上限（1=启用，0=禁用）
#define RIGHT_WHEEL_PWM_MAX      0.90f   // 右轮PWM上限（0.0-1.0）
#define LEFT_WHEEL_PWM_MAX       1.00f   // 左轮PWM上限（0.0-1.0）

// ========== 软启动控制（防止弹起）==========
#define SOFT_START_ENABLE        1       // 使能软启动（1=启用，0=禁用）
#define SOFT_START_ACCEL         0.3f    // 加速度（RPS/s）- 降低到0.3，非常温和
#define SOFT_START_DECEL         1.0f    // 减速度（RPS/s）- 停止可以快一些

// PWM变化率（差异化设置，补偿两轮效率差异）
// 右轮效率高（PWM=0.27→1.5RPS），需要更慢的变化率
// 左轮效率低（PWM=0.46→1.5RPS），可以用标准变化率
#define SOFT_START_PWM_RATE_LEFT   0.05f  // 左轮PWM变化率（5%/20ms）
#define SOFT_START_PWM_RATE_RIGHT  0.02f  // 右轮PWM变化率（3%/20ms，降低40%以匹配左轮启动时间）

// 右轮标定（基于实际运行数据：PWM_sw=0.31 → 1.57 RPS）
// 调整为1.5 RPS需要PWM=0.30：PWM = 0.14 × RPS + 0.09
// ⚠️ 进一步降低以匹配左轮速度
#define RIGHT_KFF          0.13f   // 前馈系数：降低7%以减速
#define RIGHT_PWM_MIN      0.08f   // 最小PWM：降低以匹配左轮

// 初始化控制器
void Motor_PID_Init(void) {
    // 初始化左轮PID：增强积分项以适应负载变化（空中vs地面）
    // Kp=0.5（比例），Ki=0.08（提高积分消除负载误差），Kd=0.10（微分）
    PID_Init(&pid_left_motor, 0.5f, 0.08f, 0.10f, 1.0f);
    
    // 初始化右轮PID：相同参数
    PID_Init(&pid_right_motor, 0.5f, 0.08f, 0.10f, 1.0f);
    
    // 初始化目标速度
    target_speed = 0.0f;
    target_direction = 0;
    
    last_pid_time = HAL_GetTick();
}

// 混合速度控制主循环
void Motor_PID_Control(TIM_HandleTypeDef *htim_pwm, TIM_HandleTypeDef *htim_encoder_left, 
                       TIM_HandleTypeDef *htim_encoder_right) {
    uint32_t current_time = HAL_GetTick();
    
    // 每20ms执行一次
    if (current_time - last_pid_time >= PID_CONTROL_INTERVAL) {
        float dt = (current_time - last_pid_time) / 1000.0f;
        last_pid_time = current_time;
        
        // 读取当前速度，低通滤波
        float l_spd_raw, r_spd_raw;
        Encoder_GetSpeeds(htim_encoder_left, htim_encoder_right, &l_spd_raw, &r_spd_raw, dt);
        
        actual_speed_left  = (1.0f - SPEED_LPF_ALPHA) * actual_speed_left  + SPEED_LPF_ALPHA * l_spd_raw;
        actual_speed_right = (1.0f - SPEED_LPF_ALPHA) * actual_speed_right + SPEED_LPF_ALPHA * r_spd_raw;
        
        // ========== 位置累积（里程计）==========
        #if POSITION_SYNC_ENABLE
        position_left += actual_speed_left * dt;   // 累积左轮圈数
        position_right += actual_speed_right * dt; // 累积右轮圈数
        #endif
        
        // ========== 软启动：平滑加速到目标速度（防止弹起）==========
        #if SOFT_START_ENABLE
        float speed_error = desired_speed - target_speed;
        
        if (fabsf(speed_error) > 0.01f) {  // 误差超过0.01 RPS才调整
            float max_change;
            if (speed_error > 0) {
                // 加速：使用较慢的加速度
                max_change = SOFT_START_ACCEL * dt;
            } else {
                // 减速：可以快一些
                max_change = SOFT_START_DECEL * dt;
            }
            
            if (fabsf(speed_error) > max_change) {
                // 超过限制，只改变max_change
                target_speed += (speed_error > 0) ? max_change : -max_change;
            } else {
                // 在限制内，直接到达
                target_speed = desired_speed;
            }
        } else {
            target_speed = desired_speed;
        }
        #else
        target_speed = desired_speed;  // 无软启动，直接跟随
        #endif
        
        // PWM变化率限制的历史值（声明为static以保持状态）
        static float last_pwm_right = 0.0f;
        static float last_pwm_left = 0.0f;
        
        // 如果期望速度和目标速度都为0，停止电机并重置PWM历史
        if (desired_speed == 0.0f && target_speed == 0.0f) {
            Motor_SetSpeed(htim_pwm, MOTOR_LEFT, 0.0f, 0);
            Motor_SetSpeed(htim_pwm, MOTOR_RIGHT, 0.0f, 0);
            last_pwm_left = 0.0f;
            last_pwm_right = 0.0f;
            speed_diff_integral = 0.0f;  // 重置差速积分
            position_left = 0.0f;          // 重置位置
            position_right = 0.0f;
            return;
        }
        
        // ========== 右轮：PID闭环控制 + 前馈 ==========
        // 应用速度偏置（右轮持续快则给它更低的目标）
        #if SPEED_BIAS_ENABLE
        float target_speed_right = target_speed + RIGHT_WHEEL_SPEED_BIAS;
        #else
        float target_speed_right = target_speed;
        #endif
        
        float pid_right = PID_Calculate(&pid_right_motor, target_speed_right, actual_speed_right);
        float ff_right = RIGHT_KFF * fabsf(target_speed_right) + RIGHT_PWM_MIN;  // 前馈
        float pwm_right = ff_right + CORR_GAIN * pid_right;
        
        // 限幅（应用右轮特定上限）
        if (pwm_right < 0.0f) pwm_right = 0.0f;
        #if PWM_LIMIT_ENABLE
        if (pwm_right > RIGHT_WHEEL_PWM_MAX) pwm_right = RIGHT_WHEEL_PWM_MAX;
        #else
        if (pwm_right > 1.0f) pwm_right = 1.0f;
        #endif
        
        // PWM变化率限制（右轮）- 使用更慢的变化率，防止启动时右轮过快
        #if SOFT_START_ENABLE
        if (pwm_right - last_pwm_right > SOFT_START_PWM_RATE_RIGHT) {
            pwm_right = last_pwm_right + SOFT_START_PWM_RATE_RIGHT;
        } else if (pwm_right - last_pwm_right < -SOFT_START_PWM_RATE_RIGHT) {
            pwm_right = last_pwm_right - SOFT_START_PWM_RATE_RIGHT;
        }
        #endif
        last_pwm_right = pwm_right;
        
        // ========== 左轮：PID闭环控制 + 前馈 ==========
        float pid_left = PID_Calculate(&pid_left_motor, target_speed, actual_speed_left);
        float ff_left = LEFT_KFF * fabsf(target_speed) + LEFT_PWM_MIN;  // 前馈
        float pwm_left = ff_left + CORR_GAIN * pid_left;
        
        // 限幅（应用左轮特定上限）
        if (pwm_left < 0.0f) pwm_left = 0.0f;
        #if PWM_LIMIT_ENABLE
        if (pwm_left > LEFT_WHEEL_PWM_MAX) pwm_left = LEFT_WHEEL_PWM_MAX;
        #else
        if (pwm_left > 1.0f) pwm_left = 1.0f;
        #endif
        
        // PWM变化率限制（左轮）- 使用标准变化率
        #if SOFT_START_ENABLE
        if (pwm_left - last_pwm_left > SOFT_START_PWM_RATE_LEFT) {
            pwm_left = last_pwm_left + SOFT_START_PWM_RATE_LEFT;
        } else if (pwm_left - last_pwm_left < -SOFT_START_PWM_RATE_LEFT) {
            pwm_left = last_pwm_left - SOFT_START_PWM_RATE_LEFT;
        }
        #endif
        last_pwm_left = pwm_left;
        
        // ========== 差速补偿（自动平衡两轮速度）==========
        float diff_compensation = 0.0f;  // 补偿量（供调试输出）
        float position_compensation = 0.0f;  // 位置补偿量
        
        #if DIFF_COMPENSATION_ENABLE
        float speed_diff = actual_speed_left - actual_speed_right;
        
        // 差速PI控制器（比例+积分）
        float diff_p = speed_diff * DIFF_COMP_GAIN;  // 比例项
        
        // 积分项（带限幅）
        speed_diff_integral += speed_diff * dt;
        if (speed_diff_integral > DIFF_COMP_INTEGRAL_LIMIT) {
            speed_diff_integral = DIFF_COMP_INTEGRAL_LIMIT;
        } else if (speed_diff_integral < -DIFF_COMP_INTEGRAL_LIMIT) {
            speed_diff_integral = -DIFF_COMP_INTEGRAL_LIMIT;
        }
        float diff_i = speed_diff_integral * DIFF_COMP_GAIN;
        
        diff_compensation = diff_p + diff_i;
        #endif
        
        // ========== 位置同步补偿（累积偏差修正）==========
        #if POSITION_SYNC_ENABLE
        float position_diff = position_left - position_right;  // 位置差（圈数）
        position_compensation = position_diff * POSITION_SYNC_GAIN;
        // 位置落后的轮子需要加速，领先的减速
        #endif
        
        // ========== 综合应用补偿 ==========
        float total_compensation = diff_compensation + position_compensation;
        
        // 应用补偿：左轮减速，右轮加速（或反之）
        pwm_left -= total_compensation;
        pwm_right += total_compensation;
        
        // 重新限幅（应用特定PWM上限）
        if (pwm_left < 0.0f) pwm_left = 0.0f;
        #if PWM_LIMIT_ENABLE
        if (pwm_left > LEFT_WHEEL_PWM_MAX) pwm_left = LEFT_WHEEL_PWM_MAX;
        #else
        if (pwm_left > 1.0f) pwm_left = 1.0f;
        #endif
        
        if (pwm_right < 0.0f) pwm_right = 0.0f;
        #if PWM_LIMIT_ENABLE
        if (pwm_right > RIGHT_WHEEL_PWM_MAX) pwm_right = RIGHT_WHEEL_PWM_MAX;
        #else
        if (pwm_right > 1.0f) pwm_right = 1.0f;
        #endif
        
        // 调试输出：每10次输出一次（双PID版本）
        static uint8_t debug_counter = 0;
        if (++debug_counter >= 10) {
            debug_counter = 0;
            extern UART_HandleTypeDef huart4;
            char debug[256];
            float speed_diff = actual_speed_left - actual_speed_right;
            
            // 输出两轮PID控制信息（带差速补偿、位置同步、软启动状态）
            #if POSITION_SYNC_ENABLE && SOFT_START_ENABLE
            float position_diff = position_left - position_right;
            snprintf(debug, sizeof(debug), 
                     "PID: Des=%.1f->Tgt=%.1f | R[%.2f pwm=%.2f] L[%.2f pwm=%.2f] sDIFF:%.2f pDIFF:%.2f COMP:%.3f\r\n",
                     desired_speed, target_speed,
                     actual_speed_right, pwm_right,
                     actual_speed_left, pwm_left,
                     speed_diff, position_diff, total_compensation);
            #elif POSITION_SYNC_ENABLE
            float position_diff = position_left - position_right;
            snprintf(debug, sizeof(debug), 
                     "PID: Tgt=%.1f | R[%.2f pwm=%.2f] L[%.2f pwm=%.2f] sDIFF:%.2f pDIFF:%.2f COMP:%.3f\r\n",
                     target_speed, 
                     actual_speed_right, pwm_right,
                     actual_speed_left, pwm_left,
                     speed_diff, position_diff, total_compensation);
            #elif DIFF_COMPENSATION_ENABLE
            // 计算负载系数：实际PWM与理论PWM的比值
            float load_factor_left = (ff_left > 0.01f) ? (pwm_left / ff_left) : 1.0f;
            float load_factor_right = (ff_right > 0.01f) ? (pwm_right / ff_right) : 1.0f;
            
            snprintf(debug, sizeof(debug), 
                     "PID: Tgt=%.1f | R[%.2f pwm=%.2f L%.2f] L[%.2f pwm=%.2f L%.2f] DIFF:%.2f COMP:%.3f\r\n",
                     target_speed, 
                     actual_speed_right, pwm_right, load_factor_right,
                     actual_speed_left, pwm_left, load_factor_left,
                     speed_diff, diff_compensation);
            #else
            snprintf(debug, sizeof(debug), 
                     "PID: Tgt=%.1f | R[spd=%.2f pid=%.2f pwm=%.2f] L[spd=%.2f pid=%.2f pwm=%.2f] DIFF:%.2f\r\n",
                     target_speed, 
                     actual_speed_right, pid_right, pwm_right,
                     actual_speed_left, pid_left, pwm_left, 
                     speed_diff);
            #endif
            HAL_UART_Transmit(&huart4, (uint8_t*)debug, strlen(debug), 100);
        }
        
        // 应用PWM到电机
        Motor_SetSpeed(htim_pwm, MOTOR_LEFT, pwm_left, target_direction);
        Motor_SetSpeed(htim_pwm, MOTOR_RIGHT, pwm_right, target_direction);
    }
}

// 设置前进目标速度
void Car_Forward_PID(float target_rps) {
    if (target_rps < 0.0f) target_rps = 0.0f;
    desired_speed = target_rps;  // 设置期望速度（软启动会平滑到这个值）
    target_direction = 1;
}

// 设置后退目标速度
void Car_Backward_PID(float target_rps) {
    if (target_rps < 0.0f) target_rps = 0.0f;
    desired_speed = target_rps;  // 设置期望速度（软启动会平滑到这个值）
    target_direction = -1;
}

// 设置右轮目标转速（开环控制主轮）
void Motor_SetRightWheelSpeed(float target_rps) {
    if (target_rps < 0.0f) target_rps = 0.0f;
    desired_speed = target_rps;  // 设置期望速度（软启动会平滑到这个值）
    // 保持当前方向不变（如果需要改变方向，用Car_Forward_PID或Car_Backward_PID）
}

// 获取当前目标速度
float Motor_GetTargetSpeed(void) {
    return desired_speed;  // 返回用户设定的期望速度
}

// 动态调整目标速度（保持当前方向）
void Motor_AdjustTargetSpeed(float new_target_rps) {
    if (new_target_rps < 0.0f) new_target_rps = 0.0f;
    desired_speed = new_target_rps;  // 设置期望速度（软启动会平滑到这个值）
    // 保持当前方向不变（target_direction不修改）
}

// 停止并清除状态
void Car_Stop_PID(void) {
    desired_speed = 0.0f;  // 清除期望速度
    target_speed = 0.0f;   // 清除实际目标速度
    target_direction = 0;
    
    // 清除左轮PID状态
    pid_left_motor.integral = 0.0f;
    pid_left_motor.error = 0.0f;
    pid_left_motor.lastError = 0.0f;
    pid_left_motor.lastOutput = 0.0f;
    
    // 清除右轮PID状态
    pid_right_motor.integral = 0.0f;
    pid_right_motor.error = 0.0f;
    pid_right_motor.lastError = 0.0f;
    pid_right_motor.lastOutput = 0.0f;
    
    // 清除速度滤波器
    actual_speed_left = 0.0f;
    actual_speed_right = 0.0f;
    
    // 清除差速补偿状态
    speed_diff_integral = 0.0f;
    
    // 清除位置累积
    position_left = 0.0f;
    position_right = 0.0f;
}

// 获取实际速度（不会干扰PID控制的编码器读取）
void Motor_GetActualSpeed(float *left_rps, float *right_rps) {
    *left_rps = actual_speed_left;
    *right_rps = actual_speed_right;
}

// 重置位置累积（用于开始新的直线测试）
void Motor_ResetPosition(void) {
    position_left = 0.0f;
    position_right = 0.0f;
}

// 获取编码器原始计数值（调试用）
void Motor_GetEncoderRawCount(TIM_HandleTypeDef *htim_left, TIM_HandleTypeDef *htim_right, 
                               int16_t *cnt_left, int16_t *cnt_right) {
    *cnt_left = (int16_t)__HAL_TIM_GET_COUNTER(htim_left);
    *cnt_right = (int16_t)__HAL_TIM_GET_COUNTER(htim_right);
    
    // 读取后立即清零，避免计数累积
    __HAL_TIM_SET_COUNTER(htim_left, 0);
    __HAL_TIM_SET_COUNTER(htim_right, 0);
}

// ======================== 编码器诊断测试 ========================

/**
 * @brief 测试单个编码器 - 检查编码器是否正常工作
 * @param htim_pwm PWM定时器
 * @param htim_encoder 编码器定时器
 * @param motor_channel 电机通道 (MOTOR_LEFT or MOTOR_RIGHT)
 * @param test_pwm 测试PWM占空比 (0.0~1.0)
 * @param test_duration_ms 测试持续时间（毫秒）
 * @param direction 测试方向 (1=前进, -1=后退)
 */
void Motor_EncoderSingleTest(TIM_HandleTypeDef *htim_pwm,
                              TIM_HandleTypeDef *htim_encoder,
                              int motor_channel,
                              float test_pwm, uint32_t test_duration_ms, int direction) {
    extern UART_HandleTypeDef huart4;
    char msg[256];
    const char* motor_name = (motor_channel == MOTOR_LEFT) ? "LEFT" : "RIGHT";
    
    snprintf(msg, sizeof(msg), "\r\n===== Single Encoder Test [%s] =====\r\n", motor_name);
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    snprintf(msg, sizeof(msg), "PWM=%.2f, Dir=%s, Duration=%lums\r\n", 
             test_pwm, (direction == 1) ? "FWD" : "BWD", test_duration_ms);
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    
    // Clear encoder
    __HAL_TIM_SET_COUNTER(htim_encoder, 0);
    HAL_Delay(10);
    
    // Start motor
    Motor_SetSpeed(htim_pwm, motor_channel, test_pwm, direction);
    
    uint32_t start_time = HAL_GetTick();
    uint32_t last_sample_time = start_time;
    uint32_t sample_interval = 100;
    
    int16_t total_counts = 0;
    int sample_count = 0;
    
    while (HAL_GetTick() - start_time < test_duration_ms) {
        uint32_t current_time = HAL_GetTick();
        
        if (current_time - last_sample_time >= sample_interval) {
            float dt = (current_time - last_sample_time) / 1000.0f;
            
            // Read raw count
            int16_t cnt_raw = (int16_t)__HAL_TIM_GET_COUNTER(htim_encoder);
            __HAL_TIM_SET_COUNTER(htim_encoder, 0);
            
            total_counts += cnt_raw;
            sample_count++;
            
            // Calculate speed
            float ppr = (motor_channel == MOTOR_LEFT) ? ENCODER_PPR_LEFT : ENCODER_PPR_RIGHT;
            float rps = (float)cnt_raw / ppr / dt;
            if (motor_channel == MOTOR_RIGHT) {
                rps = -rps;  // Right wheel inverted
            }
            
            snprintf(msg, sizeof(msg), "t=%lums | cnt=%d | rps=%.2f\r\n",
                     current_time - start_time, cnt_raw, rps);
            HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
            
            last_sample_time = current_time;
        }
    }
    
    // Stop motor
    Motor_SetSpeed(htim_pwm, motor_channel, 0.0f, 0);
    
    // Summary
    float avg_count = (sample_count > 0) ? ((float)total_counts / sample_count) : 0.0f;
    snprintf(msg, sizeof(msg), "Summary: Avg Count=%.1f, Samples=%d\r\n", avg_count, sample_count);
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    
    if (avg_count < 10.0f) {
        snprintf(msg, sizeof(msg), "WARNING: Count too low! Check wiring!\r\n");
        HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    }
    
    snprintf(msg, sizeof(msg), "===== Test Complete =====\r\n\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
}

/**
 * @brief 编码器对比测试 - 诊断左右轮编码器读取是否一致
 * @param htim_pwm PWM定时器
 * @param htim_encoder_left 左轮编码器定时器
 * @param htim_encoder_right 右轮编码器定时器
 * @param test_pwm 测试PWM占空比 (0.0~1.0)
 * @param test_duration_ms 测试持续时间（毫秒）
 * @param direction 测试方向 (1=前进, -1=后退)
 */
void Motor_EncoderDiagnosticTest(TIM_HandleTypeDef *htim_pwm, 
                                  TIM_HandleTypeDef *htim_encoder_left,
                                  TIM_HandleTypeDef *htim_encoder_right,
                                  float test_pwm, uint32_t test_duration_ms, int direction) {
    extern UART_HandleTypeDef huart4;
    char msg[256];
    
    snprintf(msg, sizeof(msg), "\r\n========== Encoder Diagnostic Test ==========\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    snprintf(msg, sizeof(msg), "Test Params: PWM=%.2f, Dir=%s, Duration=%lums\r\n", 
             test_pwm, (direction == 1) ? "FWD" : "BWD", test_duration_ms);
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    snprintf(msg, sizeof(msg), "---------------------------------------------\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    
    // Clear encoder counters
    __HAL_TIM_SET_COUNTER(htim_encoder_left, 0);
    __HAL_TIM_SET_COUNTER(htim_encoder_right, 0);
    HAL_Delay(10);
    
    // Apply same PWM to both motors
    Motor_SetSpeed(htim_pwm, MOTOR_LEFT, test_pwm, direction);
    Motor_SetSpeed(htim_pwm, MOTOR_RIGHT, test_pwm, direction);
    
    uint32_t start_time = HAL_GetTick();
    uint32_t last_sample_time = start_time;
    uint32_t sample_interval = 500; // Sample every 500ms (简化输出)
    
    // Test loop with sampling
    while (HAL_GetTick() - start_time < test_duration_ms) {
        uint32_t current_time = HAL_GetTick();
        
        if (current_time - last_sample_time >= sample_interval) {
            float dt = (current_time - last_sample_time) / 1000.0f;
            
            // Read raw encoder counts
            int16_t cnt_left_raw = (int16_t)__HAL_TIM_GET_COUNTER(htim_encoder_left);
            int16_t cnt_right_raw = (int16_t)__HAL_TIM_GET_COUNTER(htim_encoder_right);
            
            // Clear encoder counters
            __HAL_TIM_SET_COUNTER(htim_encoder_left, 0);
            __HAL_TIM_SET_COUNTER(htim_encoder_right, 0);
            
            // Calculate speed (using same logic as Encoder_GetSpeeds)
            float rps_left = (float)cnt_left_raw / ENCODER_PPR_LEFT / dt;     // Left: no inversion
            float rps_right = -(float)cnt_right_raw / ENCODER_PPR_RIGHT / dt;  // Right: inverted
            
            // Calculate difference
            float count_diff = (float)cnt_left_raw - (-(float)cnt_right_raw); // After R inversion
            float speed_diff = rps_left - rps_right;
            float speed_ratio = (rps_right != 0.0f) ? (rps_left / rps_right) : 0.0f;
            
            // Output diagnostic info
            snprintf(msg, sizeof(msg), "t=%lums | L_cnt=%d R_cnt=%d (R_inv=%d) | ", 
                     current_time - start_time, cnt_left_raw, cnt_right_raw, -cnt_right_raw);
            HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
            
            snprintf(msg, sizeof(msg), "L_rps=%.2f R_rps=%.2f | Diff: cnt=%.0f spd=%.2f ratio=%.2f\r\n",
                     rps_left, rps_right, count_diff, speed_diff, speed_ratio);
            HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
            
            last_sample_time = current_time;
        }
    }
    
    // Stop motors
    Motor_SetSpeed(htim_pwm, MOTOR_LEFT, 0.0f, 0);
    Motor_SetSpeed(htim_pwm, MOTOR_RIGHT, 0.0f, 0);
    
    snprintf(msg, sizeof(msg), "========== Test Complete ==========\r\n\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
}

/**
 * @brief 全面编码器测试套件
 * @param htim_pwm PWM定时器
 * @param htim_encoder_left 左轮编码器定时器
 * @param htim_encoder_right 右轮编码器定时器
 */
void Motor_EncoderFullTest(TIM_HandleTypeDef *htim_pwm,
                           TIM_HandleTypeDef *htim_encoder_left,
                           TIM_HandleTypeDef *htim_encoder_right) {
    extern UART_HandleTypeDef huart4;
    char msg[200];
    
    snprintf(msg, sizeof(msg), "\r\n+========================================+\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    snprintf(msg, sizeof(msg), "|   Quick Encoder Test (Simplified)   |\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    snprintf(msg, sizeof(msg), "+========================================+\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    
    // Test 1: Medium speed forward (PWM=0.5, 3秒)
    snprintf(msg, sizeof(msg), "\r\n[Test 1/2] Forward PWM=0.5 (3s)\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    Motor_EncoderDiagnosticTest(htim_pwm, htim_encoder_left, htim_encoder_right, 0.5f, 3000, 1);
    HAL_Delay(500);
    
    // Test 2: Medium speed backward (PWM=0.5, 3秒)
    snprintf(msg, sizeof(msg), "\r\n[Test 2/2] Backward PWM=0.5 (3s)\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    Motor_EncoderDiagnosticTest(htim_pwm, htim_encoder_left, htim_encoder_right, 0.5f, 3000, -1);
    
    snprintf(msg, sizeof(msg), "\r\n+========================================+\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    snprintf(msg, sizeof(msg), "|  Test Complete! Check ratio value   |\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    snprintf(msg, sizeof(msg), "+========================================+\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    snprintf(msg, sizeof(msg), "OK: ratio 0.85~1.15 | BAD: ratio >1.5 or <0.7\r\n\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
}

/**
 * @brief PWM-速度标定测试 - 建立准确的PWM-RPS映射关系
 * @param htim_pwm PWM定时器
 * @param htim_encoder 编码器定时器
 * @param motor_channel 电机通道 (MOTOR_LEFT or MOTOR_RIGHT)
 * @param direction 测试方向 (1=前进, -1=后退)
 */
void Motor_PWM_Calibration(TIM_HandleTypeDef *htim_pwm,
                           TIM_HandleTypeDef *htim_encoder,
                           int motor_channel,
                           int direction) {
    extern UART_HandleTypeDef huart4;
    char msg[256];
    const char* motor_name = (motor_channel == MOTOR_LEFT) ? "LEFT" : "RIGHT";
    
    // 测试PWM范围：从10%到70%，步进5%
    float pwm_levels[] = {0.10f, 0.15f, 0.20f, 0.25f, 0.30f, 0.35f, 0.40f, 0.45f, 0.50f, 0.55f, 0.60f, 0.65f, 0.70f};
    int num_levels = sizeof(pwm_levels) / sizeof(pwm_levels[0]);
    
    snprintf(msg, sizeof(msg), "\r\n========== PWM-Speed Calibration [%s] ==========\r\n", motor_name);
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    snprintf(msg, sizeof(msg), "Direction: %s | Stabilization: 2s | Sample: 1s\r\n", 
             (direction == 1) ? "FWD" : "BWD");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    snprintf(msg, sizeof(msg), "------------------------------------------------\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    
    for (int i = 0; i < num_levels; i++) {
        float test_pwm = pwm_levels[i];
        
        snprintf(msg, sizeof(msg), "\r\n[Test %d/%d] PWM=%.2f\r\n", i+1, num_levels, test_pwm);
        HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
        
        // 清零编码器
        __HAL_TIM_SET_COUNTER(htim_encoder, 0);
        
        // 启动电机
        Motor_SetSpeed(htim_pwm, motor_channel, test_pwm, direction);
        
        // 等待2秒稳定
        snprintf(msg, sizeof(msg), "Stabilizing...\r\n");
        HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
        HAL_Delay(2000);
        
        // 清零计数器，开始采样
        __HAL_TIM_SET_COUNTER(htim_encoder, 0);
        uint32_t sample_start = HAL_GetTick();
        
        snprintf(msg, sizeof(msg), "Sampling...\r\n");
        HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
        HAL_Delay(1000);
        
        // 读取计数
        uint32_t sample_end = HAL_GetTick();
        int16_t cnt_raw = (int16_t)__HAL_TIM_GET_COUNTER(htim_encoder);
        float dt = (sample_end - sample_start) / 1000.0f;
        
        // 计算速度
        float ppr = (motor_channel == MOTOR_LEFT) ? ENCODER_PPR_LEFT : ENCODER_PPR_RIGHT;
        float rps = (float)cnt_raw / ppr / dt;
        if (motor_channel == MOTOR_RIGHT) {
            rps = -rps;  // Right wheel inverted
        }
        
        // 输出结果
        snprintf(msg, sizeof(msg), "Result: PWM=%.2f -> RPS=%.2f (cnt=%d, dt=%.3fs)\r\n",
                 test_pwm, rps, cnt_raw, dt);
        HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
        
        // 停止电机，等待500ms
        Motor_SetSpeed(htim_pwm, motor_channel, 0.0f, 0);
        HAL_Delay(500);
    }
    
    // 汇总输出（便于复制粘贴到Excel）
    snprintf(msg, sizeof(msg), "\r\n========== Summary (Copy to Excel) ==========\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    snprintf(msg, sizeof(msg), "PWM\tRPS\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    
    // 重新运行一遍，只输出简化数据
    for (int i = 0; i < num_levels; i++) {
        float test_pwm = pwm_levels[i];
        __HAL_TIM_SET_COUNTER(htim_encoder, 0);
        Motor_SetSpeed(htim_pwm, motor_channel, test_pwm, direction);
        HAL_Delay(2000);
        __HAL_TIM_SET_COUNTER(htim_encoder, 0);
        uint32_t sample_start = HAL_GetTick();
        HAL_Delay(1000);
        uint32_t sample_end = HAL_GetTick();
        int16_t cnt_raw = (int16_t)__HAL_TIM_GET_COUNTER(htim_encoder);
        float dt = (sample_end - sample_start) / 1000.0f;
        float ppr = (motor_channel == MOTOR_LEFT) ? ENCODER_PPR_LEFT : ENCODER_PPR_RIGHT;
        float rps = (float)cnt_raw / ppr / dt;
        if (motor_channel == MOTOR_RIGHT) rps = -rps;
        
        snprintf(msg, sizeof(msg), "%.2f\t%.2f\r\n", test_pwm, rps);
        HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
        
        Motor_SetSpeed(htim_pwm, motor_channel, 0.0f, 0);
        HAL_Delay(500);
    }
    
    snprintf(msg, sizeof(msg), "========== Calibration Complete ==========\r\n\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
}

/**
 * @brief 快速编码器检查 - 简单测试两个编码器是否工作
 * @param htim_encoder_left 左轮编码器定时器
 * @param htim_encoder_right 右轮编码器定时器
 */
void Motor_EncoderQuickCheck(TIM_HandleTypeDef *htim_encoder_left,
                              TIM_HandleTypeDef *htim_encoder_right) {
    extern UART_HandleTypeDef huart4;
    char msg[256];
    
    snprintf(msg, sizeof(msg), "\r\n===== Quick Encoder Check =====\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    snprintf(msg, sizeof(msg), "Reading encoder counters (static test)...\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    
    // Clear counters
    __HAL_TIM_SET_COUNTER(htim_encoder_left, 0);
    __HAL_TIM_SET_COUNTER(htim_encoder_right, 0);
    
    snprintf(msg, sizeof(msg), "Counters cleared. Manually rotate wheels now!\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    snprintf(msg, sizeof(msg), "Reading for 5 seconds...\r\n\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    
    for (int i = 0; i < 10; i++) {
        HAL_Delay(500);
        
        int16_t cnt_left = (int16_t)__HAL_TIM_GET_COUNTER(htim_encoder_left);
        int16_t cnt_right = (int16_t)__HAL_TIM_GET_COUNTER(htim_encoder_right);
        
        snprintf(msg, sizeof(msg), "t=%ds | L_cnt=%d | R_cnt=%d\r\n",
                 (i + 1) / 2, cnt_left, cnt_right);
        HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    }
    
    int16_t final_left = (int16_t)__HAL_TIM_GET_COUNTER(htim_encoder_left);
    int16_t final_right = (int16_t)__HAL_TIM_GET_COUNTER(htim_encoder_right);
    
    snprintf(msg, sizeof(msg), "\r\nFinal Counts: L=%d, R=%d\r\n", final_left, final_right);
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    
    if (final_left == 0 && final_right == 0) {
        snprintf(msg, sizeof(msg), "ERROR: Both encoders show 0! Check connections!\r\n");
        HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    } else if (final_left == 0) {
        snprintf(msg, sizeof(msg), "ERROR: Left encoder not working!\r\n");
        HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    } else if (final_right == 0) {
        snprintf(msg, sizeof(msg), "ERROR: Right encoder not working!\r\n");
        HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    } else {
        snprintf(msg, sizeof(msg), "OK: Both encoders are responding!\r\n");
        HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
    }
    
    snprintf(msg, sizeof(msg), "===== Check Complete =====\r\n\r\n");
    HAL_UART_Transmit(&huart4, (uint8_t*)msg, strlen(msg), 100);
}

