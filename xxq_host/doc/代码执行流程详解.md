# xxq_host 代码执行流程详解

本文档详细说明了从 `python main_exploration.py` 启动到整个系统运行的完整调用链。

---

## 📋 目录

1. [启动阶段](#1-启动阶段)
2. [通信模块工作流程](#2-通信模块工作流程)
3. [回调机制详解](#3-回调机制详解)
4. [控制器工作流程](#4-控制器工作流程)
5. [完整调用链](#5-完整调用链)
6. [关键问题答疑](#6-关键问题答疑)

---

## 1. 启动阶段

### 1.1 命令行启动

```bash
python main_exploration.py
```

### 1.2 main() 函数执行流程

```python
# 文件: xxq_host/main_exploration.py

def main():
    # ===== 步骤1: 初始化通信对象 =====
    comm = RobotComm(port=config.SERIAL_PORT, baudrate=config.BAUDRATE)
    # 作用：创建通信对象，但此时尚未连接串口
    
    # ===== 步骤2: 启动串口通信 =====
    if not comm.start():
        sys.exit(1)
    # 作用：
    #   1. 打开串口连接（serial.Serial()）
    #   2. 创建并启动独立的接收线程（_receive_loop）
    #   3. 线程开始监听串口数据
    
    # ===== 步骤3: 等待初始数据 =====
    time.sleep(1.0)
    # 作用：等待STM32发送初始的POSE、MPU、ODO数据
    
    # ===== 步骤4: 创建控制器 =====
    controller = RobotController(comm=comm, enable_visualization=False)
    # ⚠️ 关键：在这里会自动绑定回调函数（见下文）
    
    # ===== 步骤5: 运行探索 =====
    controller.run_exploration(max_steps=500, save_map=True)
    # 作用：启动自主探索主循环（详见第4节）
```

**时序图：**

```
用户                main()              RobotComm           STM32
 |                    |                     |                 |
 |--python main.py--->|                     |                 |
 |                    |--RobotComm()------->|                 |
 |                    |                     |                 |
 |                    |--comm.start()------>|                 |
 |                    |                     |--打开串口------->|
 |                    |                     |--启动接收线程--->|
 |                    |                     |                 |
 |                    |<------------------✅返回True---------|
 |                    |                     |                 |
 |                    |--sleep(1.0)-------->|                 |
 |                    |                     |<====接收数据====|  (后台线程持续运行)
 |                    |                     |   POSE,ODO,MPU  |
 |                    |                     |                 |
 |                    |--RobotController()->|                 |
 |                    |   (绑定回调)        |                 |
 |                    |                     |                 |
 |                    |--run_exploration()->|                 |
```

---

## 2. 通信模块工作流程

### 2.1 RobotComm 的核心机制

```python
# 文件: xxq_host/src/communication/robot_comm.py

class RobotComm:
    def __init__(self, port, baudrate):
        # 初始化数据缓存
        self.latest_lidar = None
        self.latest_mpu = None
        self.latest_odom = None
        self.latest_pose = None
        
        # 初始化回调函数（此时都是None）
        self.on_lidar_update = None
        self.on_mpu_update = None
        self.on_odom_update = None
        self.on_pose_update = None  # ⚠️ 重点：这个会被Controller设置
    
    def start(self):
        # 1. 打开串口
        self.serial = serial.Serial(self.port, self.baudrate)
        
        # 2. 启动独立线程
        self.running = True
        self.receive_thread = threading.Thread(target=self._receive_loop, daemon=True)
        self.receive_thread.start()  # ⚠️ 线程从这里开始运行
        
        return True
```

### 2.2 接收线程工作流程

```python
def _receive_loop(self):
    """这个函数在独立线程中持续运行"""
    buffer = ""
    
    while self.running:  # ⚠️ 只要程序不退出，就一直循环
        # 步骤1: 从串口读取数据
        if self.serial.in_waiting:
            data = self.serial.read(self.serial.in_waiting)
            decoded = data.decode('utf-8')
            buffer += decoded
            
            # 步骤2: 按行拆分数据
            while '\n' in buffer:
                line, buffer = buffer.split('\n', 1)
                self._parse_line(line.strip())  # ⚠️ 解析每一行
        else:
            time.sleep(0.001)  # 没数据时休眠1ms
```

### 2.3 数据解析流程

```python
def _parse_line(self, line: str):
    """解析STM32发来的一行数据"""
    
    # 示例: "POSE,12345,0.150,-0.320,45.2"
    #         ^^^^  ^^^^^  ^^^^^  ^^^^^^ ^^^^
    #         类型  时间戳   x      y     theta
    
    if not line:
        return
    
    # 判断数据类型
    if line.startswith('{'):
        # JSON格式 -> 雷达数据
        self._parse_lidar_json(line)
    elif ',' in line:
        # CSV格式 -> MPU/ODO/POSE
        self._parse_csv(line)

def _parse_csv(self, line: str):
    parts = line.split(',')
    data_type = parts[0]
    
    # ⚠️ 关键：解析POSE数据
    if data_type == 'POSE' and len(parts) == 5:
        # 步骤1: 创建PoseData对象
        self.latest_pose = PoseData(
            timestamp=int(parts[1]),
            x=float(parts[2]),        # 单位：米
            y=float(parts[3]),        # 单位：米
            theta=float(parts[4])     # 单位：度
        )
        
        # 步骤2: 触发回调函数（如果已设置）
        if self.on_pose_update:
            self.on_pose_update(self.latest_pose)  # ⚠️ 这里会调用Controller的回调
```

**数据流示意图：**

```
STM32固件                接收线程                  回调函数
   |                       |                         |
   |--POSE,123,0.1,0.2,45->|                         |
   |                       |                         |
   |                    解析数据                     |
   |                       |                         |
   |                    创建PoseData                 |
   |                  latest_pose = ...              |
   |                       |                         |
   |                  检查on_pose_update?            |
   |                       |                         |
   |                    ✅ 已设置                     |
   |                       |                         |
   |                       |--on_pose_update(data)-->|
   |                       |                         |
   |                       |        Controller._on_hardware_pose_update()
   |                       |        更新机器人位姿
```

---

## 3. 回调机制详解

### 3.1 回调函数的绑定

```python
# 文件: xxq_host/src/navigation/controller.py

class RobotController:
    def __init__(self, comm=None, ...):
        self.comm = comm
        
        # ⚠️ 关键：在初始化时绑定回调函数
        if self.comm:
            # 将自己的方法设置为通信对象的回调
            self.comm.on_pose_update = self._on_hardware_pose_update
            self.comm.on_lidar_update = self._on_hardware_lidar_update
            # 现在当RobotComm收到数据时，会自动调用这些方法
```

**绑定过程示意图：**

```
main_exploration.py           RobotController              RobotComm
      |                              |                         |
      |--controller=RobotController(comm)-->                   |
      |                              |                         |
      |                          __init__()                    |
      |                              |                         |
      |                        if self.comm:                   |
      |                              |                         |
      |                     self.comm.on_pose_update = self._on_hardware_pose_update
      |                              |                         |
      |                              |----设置回调函数指针----->| on_pose_update
      |                              |                         | = Controller._on_hardware_pose_update
      |                              |                         |
      |                         ✅ 绑定完成                     |
```

### 3.2 回调函数的执行

```python
def _on_hardware_pose_update(self, pose_data):
    """接收STM32的POSE数据（硬件位姿）
    
    ⚠️ 重要：这个函数在RobotComm的接收线程中被调用
    
    Args:
        pose_data: PoseData对象，包含x, y, theta
    """
    # 步骤1: 保存上次位姿（用于计算位移）
    self.last_pose = self.robot_pose.copy()
    
    # 步骤2: 更新当前位姿
    self.robot_pose[0] = pose_data.x           # x坐标（米）
    self.robot_pose[1] = pose_data.y           # y坐标（米）
    self.robot_pose[2] = np.deg2rad(pose_data.theta)  # 转为弧度
    
    # 步骤3: 计算移动距离
    displacement = np.hypot(
        self.robot_pose[0] - self.last_pose[0],
        self.robot_pose[1] - self.last_pose[1]
    )
    self.total_distance += displacement
    
    # 步骤4: 定期打印日志
    if self.exploration_steps % 50 == 0:
        print(f"[硬件POSE] x={pose_data.x:.3f}m, y={pose_data.y:.3f}m, θ={pose_data.theta:.1f}°")
```

**执行时序图：**

```
接收线程                  回调函数                  Controller状态
   |                         |                         |
   |--收到POSE数据----------->|                         |
   |                         |                         |
   |--_parse_csv()---------->|                         |
   |  创建PoseData           |                         |
   |                         |                         |
   |--调用on_pose_update---->|                         |
   |                         |                         |
   |                 _on_hardware_pose_update()        |
   |                         |                         |
   |                         |--self.robot_pose[0]=x-->| robot_pose[0] = 0.15
   |                         |--self.robot_pose[1]=y-->| robot_pose[1] = -0.32
   |                         |--self.robot_pose[2]=θ-->| robot_pose[2] = 0.785
   |                         |                         |
   |                         |--total_distance += ..-->| total_distance = 1.23
   |                         |                         |
   |                         |<------------------------✅位姿已更新
   |                         |                         |
   |--继续接收下一个数据----->|                         |
```

**⚠️ 关键点：**
- `_on_hardware_pose_update()` **不是主动调用的**，而是被 `RobotComm` 的接收线程**自动触发**
- 每次STM32发送 `POSE,xxx,xxx,xxx` 数据时，这个函数就会被调用一次
- 这是一个**异步机制**，运行在独立线程中

---

## 4. 控制器工作流程

### 4.1 探索主循环

```python
# 文件: xxq_host/src/navigation/controller.py

def run_exploration(self, max_steps=500, save_map=True):
    """运行自主探索
    
    Args:
        max_steps: 最大探索步数（默认500，约50秒）
        save_map: 是否保存地图
    """
    print("\n" + "="*70)
    print(" 开始自主探索")
    print("="*70)
    
    # ===== 初始化 =====
    self.start_time = time.time()
    self.exploration_steps = 0
    self.state = RobotState.EXPLORING
    
    # ===== 启动前请求雷达扫描 =====
    if self.comm:
        self.comm.request_lidar_scan()  # 发送 'A' 命令给STM32
        time.sleep(0.5)  # 等待雷达数据
    
    # ===== 主循环 =====
    while self.exploration_steps < max_steps:
        # 步骤1: 执行一步控制（见4.2节）
        should_continue = self._control_step()
        
        if not should_continue:
            print("[探索] 无更多前沿点，探索完成")
            break
        
        self.exploration_steps += 1
        
        # 步骤2: 定期打印统计信息
        if self.exploration_steps % 50 == 0:
            self._print_statistics()
    
    # ===== 结束清理 =====
    if self.comm:
        self.comm.stop_robot()
    
    if save_map:
        self._save_map()
    
    return self.state == RobotState.COMPLETED
```

### 4.2 单步控制流程

```python
def _control_step(self) -> bool:
    """执行一步控制（核心算法）
    
    Returns:
        是否应继续探索
    """
    # ===== 步骤1: 检测前沿点 =====
    frontiers = self.frontier_detector.detect_frontiers()
    
    if len(frontiers) == 0:
        # 没有前沿点 -> 探索完成
        self.state = RobotState.COMPLETED
        return False
    
    # ===== 步骤2: 选择目标前沿点 =====
    if self.current_target is None:
        # 根据策略选择（nearest/largest/information_gain）
        self.current_target = self.frontier_detector.select_best_frontier(
            frontiers,
            tuple(self.robot_pose),
            strategy=config.FRONTIER_SELECTION
        )
        
        # 规划全局路径（A*算法）
        self.current_path = self.path_planner.plan(
            tuple(self.robot_pose[:2]),  # 起点
            self.current_target           # 终点
        )
        
        if not self.current_path:
            # 路径规划失败
            self.current_target = None
            return True
        
        self.path_index = 0
        self.state = RobotState.NAVIGATING
        print(f"[探索] 新目标: {self.current_target}, 路径长度: {len(self.current_path)}")
    
    # ===== 步骤3: 沿路径导航 =====
    if self.path_index < len(self.current_path):
        # 获取局部目标点（路径上的下一个点）
        local_goal = self.current_path[self.path_index]
        
        # 检查是否到达当前路径点
        distance_to_goal = np.hypot(
            local_goal[0] - self.robot_pose[0],
            local_goal[1] - self.robot_pose[1]
        )
        
        if distance_to_goal < 0.1:  # 到达阈值：0.1米
            self.path_index += 1
            if self.path_index >= len(self.current_path):
                # 到达最终目标
                print("[探索] 到达目标前沿点")
                self.current_target = None
                self.state = RobotState.EXPLORING
                return True
        
        # ===== 步骤4: DWA局部避障 =====
        robot_state = tuple(self.robot_pose + self.robot_velocity)
        obstacles = []  # 简化：暂不使用障碍物列表
        
        # DWA规划速度
        v, omega = self.dwa.plan(robot_state, local_goal, obstacles)
        
        # ===== 步骤5: 发送速度指令到硬件 =====
        self._update_robot_state(v, omega, dt=0.1)
        
        # 控制频率限制
        time.sleep(0.1)  # 10Hz
        
        # ===== 步骤6: 定期请求雷达扫描 =====
        if self.comm and self.exploration_steps % 10 == 0:
            self.comm.request_lidar_scan()
    
    # ===== 步骤7: 卡住检测 =====
    displacement = np.hypot(
        self.robot_pose[0] - self.last_pose[0],
        self.robot_pose[1] - self.last_pose[1]
    )
    
    if displacement < 0.01:  # 移动小于1cm
        self.stuck_counter += 1
        if self.stuck_counter > self.stuck_threshold:
            self._handle_stuck()  # 后退+转向
    else:
        self.stuck_counter = 0
    
    # ===== 步骤8: 更新可视化 =====
    if self.enable_visualization and self.visualizer:
        self._update_visualization(frontiers)
    
    return True
```

### 4.3 速度指令发送

```python
def _update_robot_state(self, v: float, omega: float, dt: float = 0.1):
    """发送速度指令到机器人
    
    ⚠️ 注意：这个函数只发送指令，不更新位姿
    位姿更新由 _on_hardware_pose_update() 负责
    
    Args:
        v: 线速度 (m/s)
        omega: 角速度 (rad/s)
        dt: 时间步长（保留，实际未使用）
    """
    # 步骤1: 记录当前速度
    self.robot_velocity = [v, omega]
    
    if self.comm:
        # 步骤2: 差分驱动运动学转换
        wheel_base = config.WHEEL_BASE      # 轮距（米）
        wheel_radius = config.WHEEL_RADIUS  # 轮半径（米）
        
        # 左右轮线速度
        v_left = v - omega * wheel_base / 2.0
        v_right = v + omega * wheel_base / 2.0
        
        # 转换为轮速（RPS = 转/秒）
        left_rps = v_left / (2.0 * np.pi * wheel_radius)
        right_rps = v_right / (2.0 * np.pi * wheel_radius)
        
        # 步骤3: 发送速度指令
        self.comm.send_speed_command(left_rps, right_rps)
        # 这会发送: "SPD,0.85,1.23\n" 到STM32
    else:
        print("[警告] 无通信对象，无法发送速度指令")
    
    # ⚠️ 注意：这里不更新self.robot_pose
    # 位姿由 _on_hardware_pose_update() 从硬件数据更新
```

---

## 5. 完整调用链

### 5.1 启动到运行的完整流程

```
1. 用户执行: python main_exploration.py
   └─> main()
       │
       ├─> [步骤1] comm = RobotComm(...)
       │   └─> 创建通信对象（尚未连接）
       │
       ├─> [步骤2] comm.start()
       │   ├─> 打开串口
       │   └─> 启动接收线程
       │       └─> _receive_loop() 开始运行（独立线程）
       │           └─> 持续监听串口
       │               └─> 收到数据 -> _parse_line()
       │                   └─> _parse_csv()
       │                       └─> 创建PoseData
       │                           └─> 调用 on_pose_update(pose_data)
       │                               └─> Controller._on_hardware_pose_update()
       │                                   └─> 更新 self.robot_pose
       │
       ├─> [步骤3] time.sleep(1.0)
       │   └─> 等待初始数据（在此期间接收线程已在工作）
       │
       ├─> [步骤4] controller = RobotController(comm)
       │   └─> RobotController.__init__()
       │       ├─> 创建地图 OccupancyGridMap
       │       ├─> 创建前沿检测器 FrontierDetector
       │       ├─> 创建路径规划器 PathPlanner
       │       ├─> 创建DWA避障器
       │       └─> ⚠️ 绑定回调:
       │           └─> self.comm.on_pose_update = self._on_hardware_pose_update
       │           └─> self.comm.on_lidar_update = self._on_hardware_lidar_update
       │
       └─> [步骤5] controller.run_exploration()
           └─> while exploration_steps < max_steps:
               └─> _control_step()
                   ├─> 检测前沿点
                   ├─> 选择目标 + A*规划
                   ├─> DWA规划速度 (v, omega)
                   ├─> _update_robot_state(v, omega)
                   │   └─> 转换为轮速
                   │       └─> comm.send_speed_command(L, R)
                   │           └─> 发送 "SPD,L,R\n" 到STM32
                   │
                   └─> time.sleep(0.1)  # 10Hz控制频率
```

### 5.2 数据流向图

```
┌─────────────────────────────────────────────────────────────────┐
│                          STM32固件                              │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐      │
│  │ 位姿估计 │  │ 编码器   │  │ MPU6500  │  │ 雷达     │      │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘      │
│       │             │              │              │            │
│       └─────────────┴──────────────┴──────────────┘            │
│                     │                                           │
│               ┌─────▼─────┐                                     │
│               │ UART发送  │                                     │
│               └─────┬─────┘                                     │
└─────────────────────┼─────────────────────────────────────────┘
                      │ 串口
                      │ "POSE,123,0.15,-0.32,45.2\n"
                      │ "ODO,124,1.2,1.3,4567,4823\n"
                      │ "{'type':'LIDAR',...}\n"
                      │
┌─────────────────────▼─────────────────────────────────────────┐
│                    xxq_host (Python)                           │
│                                                                │
│  ┌──────────────────────────────────────────────────────┐    │
│  │          RobotComm (独立接收线程)                     │    │
│  │  ┌─────────────┐                                      │    │
│  │  │_receive_loop│ 持续运行                             │    │
│  │  └──────┬──────┘                                      │    │
│  │         │                                             │    │
│  │    ┌────▼────┐     ┌────────────┐                    │    │
│  │    │_parse   │────>│latest_pose │                    │    │
│  │    │_line    │     │latest_lidar│                    │    │
│  │    └────┬────┘     │latest_odom │                    │    │
│  │         │          └────────────┘                    │    │
│  │         │                                             │    │
│  │    ┌────▼────────────┐                               │    │
│  │    │触发回调函数      │                               │    │
│  │    │on_pose_update() │                               │    │
│  │    └────┬────────────┘                               │    │
│  └─────────┼──────────────────────────────────────────────┘    │
│            │                                                   │
│            │                                                   │
│  ┌─────────▼──────────────────────────────────────────────┐   │
│  │              RobotController                            │   │
│  │                                                         │   │
│  │  ┌────────────────────────────────────┐               │   │
│  │  │_on_hardware_pose_update(pose_data) │               │   │
│  │  │  ├─> self.robot_pose[0] = pose.x   │               │   │
│  │  │  ├─> self.robot_pose[1] = pose.y   │               │   │
│  │  │  └─> self.robot_pose[2] = pose.θ   │               │   │
│  │  └────────────────────────────────────┘               │   │
│  │                                                         │   │
│  │  ┌────────────────────────────────────┐               │   │
│  │  │ run_exploration() 主循环           │               │   │
│  │  │  while steps < max_steps:          │               │   │
│  │  │    ├─> 检测前沿                    │               │   │
│  │  │    ├─> A*规划路径                  │               │   │
│  │  │    ├─> DWA规划速度                 │               │   │
│  │  │    └─> 发送速度指令                │               │   │
│  │  └────────────┬───────────────────────┘               │   │
│  │               │                                        │   │
│  │               ▼                                        │   │
│  │  ┌────────────────────────────┐                       │   │
│  │  │_update_robot_state(v, ω)   │                       │   │
│  │  │  ├─> 计算左右轮速           │                       │   │
│  │  │  └─> comm.send_speed_cmd()  │                       │   │
│  │  └────────────┬───────────────┘                       │   │
│  └───────────────┼────────────────────────────────────────┘   │
│                  │                                            │
│                  │ "SPD,0.85,1.23\n"                         │
└──────────────────┼────────────────────────────────────────────┘
                   │
                   │ 串口
                   │
┌──────────────────▼────────────────────────────────────────────┐
│                      STM32固件                                 │
│  ┌────────────┐                                               │
│  │ UART接收   │                                               │
│  └─────┬──────┘                                               │
│        │                                                      │
│  ┌─────▼────────────┐                                         │
│  │Parse_PC_Command  │                                         │
│  │  "SPD,0.85,1.23" │                                         │
│  └─────┬────────────┘                                         │
│        │                                                      │
│  ┌─────▼──────────────────────┐                              │
│  │DiffDrive_SetWheelSpeeds()  │                              │
│  │  ├─> target_left = 0.85    │                              │
│  │  └─> target_right = 1.23   │                              │
│  └─────┬──────────────────────┘                              │
│        │                                                      │
│  ┌─────▼──────────────────┐                                  │
│  │ PID控制循环 (20Hz)     │                                  │
│  │  ├─> Motor_PID_Control │                                  │
│  │  └─> PWM输出           │                                  │
│  └────────────────────────┘                                  │
└───────────────────────────────────────────────────────────────┘
```

---

## 6. 关键问题答疑

### Q1: `_on_hardware_pose_update()` 是如何被调用的？

**答：** 通过回调机制，在独立线程中自动触发。

```python
# 1. Controller初始化时绑定
controller = RobotController(comm)
  └─> self.comm.on_pose_update = self._on_hardware_pose_update

# 2. RobotComm接收到数据时触发
RobotComm._receive_loop()  # 独立线程
  └─> _parse_csv("POSE,123,0.15,-0.32,45.2")
      └─> self.latest_pose = PoseData(...)
          └─> if self.on_pose_update:  # 检查是否设置了回调
                  self.on_pose_update(self.latest_pose)  # 调用Controller的方法
                    └─> Controller._on_hardware_pose_update(pose_data)
```

**⚠️ 关键点：**
- `_on_hardware_pose_update()` 运行在 **RobotComm的接收线程** 中
- 不是主线程调用的，是异步触发的
- 每次STM32发送POSE数据，这个函数就执行一次

---

### Q2: 位姿更新和控制循环是如何同步的？

**答：** 它们是**异步的**，通过共享变量 `self.robot_pose` 通信。

```
┌──────────────────────┐          ┌──────────────────────┐
│  接收线程（后台）    │          │  主线程（控制循环）  │
│                      │          │                      │
│  while True:         │          │  while steps < max:  │
│    收到POSE数据      │          │                      │
│    ↓                 │          │    读取robot_pose    │
│    解析数据          │          │    ↓                 │
│    ↓                 │          │    规划路径          │
│    更新robot_pose ───┼─────────>│    ↓                 │
│    ↓                 │ 共享变量 │    DWA规划           │
│    继续接收...       │          │    ↓                 │
│                      │          │    发送速度指令      │
│                      │          │    ↓                 │
│                      │          │    sleep(0.1)        │
└──────────────────────┘          └──────────────────────┘
```

**⚠️ 注意：**
- 两个线程同时运行，互不阻塞
- 接收线程持续更新 `robot_pose`
- 控制循环定期读取 `robot_pose`
- 频率不同：接收线程更快（~50Hz），控制循环较慢（10Hz）

---

### Q3: 为什么 `_update_robot_state()` 不更新位姿？

**答：** 因为采用了**硬件模式**，位姿由STM32的EKF估计器计算。

```python
# ❌ 旧版本（仿真模式）
def _update_robot_state(v, omega, dt):
    # 使用运动学公式模拟位姿变化
    self.robot_pose[0] += v * cos(theta) * dt
    self.robot_pose[1] += v * sin(theta) * dt
    self.robot_pose[2] += omega * dt

# ✅ 新版本（硬件模式）
def _update_robot_state(v, omega, dt):
    # 只发送速度指令
    left_rps, right_rps = 转换(v, omega)
    self.comm.send_speed_command(left_rps, right_rps)
    
    # 位姿更新由 _on_hardware_pose_update() 负责
    # 数据来自STM32的EKF估计器（融合编码器+IMU）
```

**优势：**
- 使用真实的编码器和IMU数据
- EKF融合多传感器，更准确
- 考虑了打滑、惯性等真实因素

---

### Q4: 如果我想修改代码，应该关注哪些地方？

**答：** 根据需求不同：

#### 📌 修改导航策略
```python
# 文件: xxq_host/src/navigation/controller.py

# 1. 修改前沿选择策略
self.current_target = self.frontier_detector.select_best_frontier(
    frontiers,
    tuple(self.robot_pose),
    strategy='information_gain'  # 改为信息增益优先
)

# 2. 修改DWA参数
dwa_config = DWAConfig(
    max_speed=1.5,         # 提高最大速度
    heading_weight=0.3,    # 调整权重
    ...
)
```

#### 📌 修改硬件接口
```python
# 文件: xxq_host/src/communication/robot_comm.py

# 1. 修改数据格式
def _parse_csv(self, line):
    # 如果STM32改变了数据格式，在这里修改解析

# 2. 添加新的数据类型
def _parse_new_data(self, line):
    # 添加新的传感器数据解析
```

#### 📌 修改控制频率
```python
# 文件: xxq_host/config.py

CONTROL_LOOP_RATE = 20  # 改为20Hz

# 文件: xxq_host/src/navigation/controller.py
time.sleep(1.0 / config.CONTROL_LOOP_RATE)  # 动态调整
```

#### 📌 调试技巧
```python
# 1. 添加日志
print(f"[DEBUG] robot_pose = {self.robot_pose}")
print(f"[DEBUG] target = {self.current_target}")
print(f"[DEBUG] velocity = {v:.2f}, {omega:.2f}")

# 2. 保存数据
import json
with open('debug_data.json', 'w') as f:
    json.dump({
        'pose': self.robot_pose,
        'path': self.current_path,
        'velocity': self.robot_velocity
    }, f)

# 3. 可视化
self.enable_visualization = True  # 启用可视化
```

---

## 7. 常见问题排查

### ❌ 问题1: 收不到POSE数据

**检查清单：**
```python
# 1. 检查STM32是否发送数据
#    - 打开串口监视器
#    - 应该看到: "POSE,123,0.00,0.00,0.00"

# 2. 检查回调是否绑定
if comm.on_pose_update is None:
    print("[错误] 回调未绑定")
else:
    print("[正常] 回调已绑定")

# 3. 检查数据格式
#    - 必须是: "POSE,timestamp,x,y,theta\n"
#    - 逗号分隔，5个字段
#    - 以换行符结束
```

### ❌ 问题2: 机器人不动

**检查清单：**
```python
# 1. 检查速度指令是否发送
comm.send_speed_command(1.0, 1.0)
print("[测试] 发送速度指令")

# 2. 检查STM32是否收到
#    - 在STM32的Parse_PC_Command添加日志
#    - 应该打印: "[PC-CMD] SPD: L=1.00 R=1.00"

# 3. 检查PID控制是否启用
#    - g_pid_control_enabled 应该为 1
#    - g_motor_mode 应该为 MOTOR_MODE_PID_CONTROL
```

### ❌ 问题3: 位姿不更新

**检查清单：**
```python
# 1. 检查编码器是否工作
#    - 查看ODO数据: left_count, right_count应该变化

# 2. 检查EKF估计器
#    - 在pose_estimator.c添加日志
#    - 确认UpdateOdometry被调用

# 3. 检查回调函数
def _on_hardware_pose_update(self, pose_data):
    print(f"[回调] 收到位姿: {pose_data.x}, {pose_data.y}, {pose_data.theta}")
    # 应该每20ms打印一次（50Hz）
```

---

## 8. 总结

### 核心执行流程

```
启动 → 创建通信对象 → 启动接收线程 → 绑定回调 → 运行控制循环
  │         │              │(后台持续)     │         │
  │         │              │               │         └─> 规划+控制(10Hz)
  │         │              │               │
  │         │              │               └─> 数据更新通过回调(50Hz)
  │         │              │
  │         │              └─> 异步接收STM32数据
  │         │
  │         └─> 打开串口
  │
  └─> python main_exploration.py
```

### 关键设计模式

1. **回调模式**：数据接收异步触发
2. **多线程**：接收线程和主线程并行
3. **生产者-消费者**：接收线程产生数据，控制循环消费数据
4. **配置中心**：所有参数在 `config.py` 统一管理

### 代码质量评估

✅ **优点：**
- 模块化清晰，职责分明
- 使用硬件数据，准确性高
- 参数可配置，易于调优
- 异步机制，效率高

⚠️ **可改进：**
- 线程安全性（考虑加锁保护 `robot_pose`）
- 错误处理（串口断开、数据异常）
- 日志系统（替换print为logging）
- 单元测试（添加测试用例）

---

**文档版本：** v1.0  
**最后更新：** 2025-01-11  
**作者：** AI Assistant

