# é›·è¾¾ç³»ç»Ÿé‡æ„æ–¹æ¡ˆ

## ğŸ“‹ é—®é¢˜è¯Šæ–­

### 1. æ–¹å‘å®šä¹‰é”™è¯¯
- **é—®é¢˜**ï¼šæ‰‡åŒº0ï¼ˆ0Â°ï¼‰åº”è¯¥æ˜¯æ­£å‰æ–¹ï¼Œä½†å®é™…æ£€æµ‹åˆ°çš„æ˜¯åæ–¹
- **åŸå› **ï¼šå›ºä»¶ä¸­æ‰‡åŒºè®¡ç®—æˆ–ä¼ æ„Ÿå™¨ç‰©ç†å®‰è£…æ–¹å‘ä¸å¯¹
- **å½±å“**ï¼šå¯¼èˆªå’Œé¿éšœå†³ç­–é”™è¯¯

### 2. ç»Ÿè®¡æŒ‡æ ‡ä¸è¶³
- **å½“å‰**ï¼šåªæœ‰ `min_dist` å’Œ `avg_dist`
- **é—®é¢˜**ï¼š
  - `min_dist` å®¹æ˜“å—å™ªå£°å½±å“ï¼ˆå¦‚0.10må¯èƒ½æ˜¯ç¦»ç¾¤å€¼ï¼‰
  - `avg_dist` åœ¨æ•°æ®åˆ†å¸ƒä¸å‡æ—¶ä¸å‡†ç¡®
  - æ— æ³•åˆ¤æ–­æ•°æ®è´¨é‡å’Œå¯ä¿¡åº¦

### 3. ç¼ºå°‘æ•°æ®è¿‡æ»¤
- **é—®é¢˜**ï¼šæ²¡æœ‰ç¦»ç¾¤å€¼è¿‡æ»¤ã€å™ªå£°æŠ‘åˆ¶
- **å½±å“**ï¼šå¼‚å¸¸å€¼å½±å“é¿éšœå†³ç­–

## ğŸ¯ è®¾è®¡ç›®æ ‡

### 1. é¿éšœéœ€æ±‚
- å¿«é€Ÿå“åº”ï¼š< 100ms
- å¯é æ€§ï¼šæŠ—å™ªå£°ã€æŠ—ç¦»ç¾¤å€¼
- ç²¾ç¡®åº¦ï¼š5cmåˆ†è¾¨ç‡
- è¦†ç›–èŒƒå›´ï¼š360Â°ï¼Œ0.1-10m

### 2. SLAMéœ€æ±‚
- ç‚¹äº‘å®Œæ•´æ€§ï¼šä¿ç•™æ‰€æœ‰æœ‰æ•ˆç‚¹
- æ•°æ®å¯†åº¦ï¼šæ¯åº¦â‰¥1ä¸ªç‚¹
- æ—¶é—´åŒæ­¥ï¼šç»Ÿä¸€æ—¶é—´æˆ³
- è§’åº¦ç²¾åº¦ï¼šÂ±1Â°

## ğŸ“Š æ–°è®¾è®¡æ–¹æ¡ˆ

### æ–¹æ¡ˆAï¼šå¢å¼º8æ‰‡åŒºç»Ÿè®¡ï¼ˆæ¨èç”¨äºé¿éšœï¼‰

#### æ•°æ®ç»“æ„
```json
{
  "type": "LIDAR",
  "timestamp": 625079,
  "total_points": 66,
  "angle_coverage": 39.1,
  "sectors": [
    {
      "sector_id": 0,
      "angle_center": 0,
      "angle_range": [337.5, 22.5],
      "count": 15,
      "statistics": {
        "min": 0.50,           // æœ€å°è·ç¦»ï¼ˆç±³ï¼‰
        "max": 8.20,           // æœ€å¤§è·ç¦»
        "mean": 3.45,          // å¹³å‡å€¼
        "median": 2.80,        // ä¸­ä½æ•° â­ æ–°å¢
        "p10": 0.85,           // 10%åˆ†ä½æ•° â­ æ–°å¢ï¼ˆå¾ˆè¿‘çš„éšœç¢ï¼‰
        "p90": 6.50,           // 90%åˆ†ä½æ•°
        "std": 1.23,           // æ ‡å‡†å·® â­ æ–°å¢
        "mode_range": [2.5, 3.0],  // ä¼—æ•°åŒºé—´ â­ æ–°å¢
        "density": 0.33        // æ•°æ®å¯†åº¦ï¼ˆç‚¹æ•°/è§’åº¦èŒƒå›´ï¼‰
      },
      "quality": {
        "avg_quality": 85,     // å¹³å‡ä¿¡å·è´¨é‡ï¼ˆ0-127ï¼‰
        "valid_ratio": 0.95,   // æœ‰æ•ˆç‚¹æ¯”ä¾‹
        "outlier_count": 1     // ç¦»ç¾¤å€¼æ•°é‡
      },
      "obstacle_level": "NEAR"  // éšœç¢ç‰©ç­‰çº§ï¼šCLEAR/FAR/MEDIUM/NEAR/CRITICAL
    }
  ]
}
```

#### å…³é”®æ”¹è¿›
1. **ä¸­ä½æ•°ï¼ˆmedianï¼‰**ï¼šå¯¹ç¦»ç¾¤å€¼ä¸æ•æ„Ÿï¼Œæ¯”å¹³å‡å€¼æ›´å¯é 
2. **ç™¾åˆ†ä½æ•°ï¼ˆp10/p90ï¼‰**ï¼š
   - p10ï¼šæœ€è¿‘10%çš„éšœç¢ç‰©è·ç¦»ï¼Œç”¨äºç´§æ€¥é¿éšœ
   - p90ï¼šç”¨äºåˆ¤æ–­æ˜¯å¦æœ‰è¿œè·ç¦»å¹²æ‰°
3. **æ ‡å‡†å·®ï¼ˆstdï¼‰**ï¼šåˆ¤æ–­æ•°æ®åˆ†æ•£ç¨‹åº¦ï¼Œstdå¤§è¯´æ˜ç¯å¢ƒå¤æ‚
4. **ä¼—æ•°åŒºé—´ï¼ˆmode_rangeï¼‰**ï¼šæœ€å¸¸å‡ºç°çš„è·ç¦»èŒƒå›´ï¼Œæœ€å¯é çš„æµ‹é‡
5. **è´¨é‡æŒ‡æ ‡**ï¼šæ•°æ®å¯ä¿¡åº¦è¯„ä¼°

### æ–¹æ¡ˆBï¼šä¿ç•™åŸå§‹ç‚¹äº‘ï¼ˆç”¨äºSLAMï¼‰

#### æ•°æ®ç»“æ„
```json
{
  "type": "LIDAR_CLOUD",
  "timestamp": 625079,
  "points": [
    {"angle": 0.5, "distance": 2.45, "quality": 87},
    {"angle": 1.2, "distance": 2.48, "quality": 92},
    // ... æœ€å¤š360ä¸ªç‚¹
  ]
}
```

### æ–¹æ¡ˆCï¼šåŒæ¨¡å¼æ··åˆï¼ˆæ¨èï¼‰ â­

- **å®æ—¶é¿éšœæ¨¡å¼**ï¼šå‘é€å¢å¼º8æ‰‡åŒºç»Ÿè®¡ï¼ˆ50Hzï¼‰
- **SLAMå»ºå›¾æ¨¡å¼**ï¼šå‘é€å®Œæ•´ç‚¹äº‘ï¼ˆæŒ‰éœ€ï¼‰
- **åˆ‡æ¢å‘½ä»¤**ï¼š
  - `A` - 8æ‰‡åŒºæ¨¡å¼ï¼ˆé»˜è®¤ï¼‰
  - `A2` - ç‚¹äº‘æ¨¡å¼

## ğŸ› ï¸ å®ç°æ–¹æ¡ˆ

### 1. ä¿®å¤æ–¹å‘å®šä¹‰

#### é€‰é¡¹Aï¼šå›ºä»¶ç«¯ä¿®å¤ï¼ˆæ¨èï¼‰
```c
// ä¿®æ”¹æ‰‡åŒºè®¡ç®—å®ï¼Œæ·»åŠ 180åº¦åç§»
#define RADAR_GET_SECTOR(angle_deg) \
    ((int)(((angle_deg) + 180.0f + 22.5f) / 45.0f) % 8)
```

#### é€‰é¡¹Bï¼šPythonç«¯æ˜ å°„
```python
def fix_sector_direction(sector_id):
    """ä¿®æ­£æ‰‡åŒºæ–¹å‘"""
    return (sector_id + 4) % 8  # æ—‹è½¬180åº¦
```

### 2. æ•°æ®è¿‡æ»¤ç®—æ³•

#### ç¦»ç¾¤å€¼æ£€æµ‹ï¼ˆå›ºä»¶ç«¯ï¼‰
```c
/**
 * @brief ç¦»ç¾¤å€¼æ£€æµ‹ï¼ˆIQRæ–¹æ³•ï¼‰
 * 
 * æ­¥éª¤ï¼š
 * 1. è®¡ç®—Q1ï¼ˆ25%åˆ†ä½ï¼‰å’ŒQ3ï¼ˆ75%åˆ†ä½ï¼‰
 * 2. IQR = Q3 - Q1
 * 3. ç¦»ç¾¤å€¼ï¼š< Q1 - 1.5*IQR æˆ– > Q3 + 1.5*IQR
 */
void filter_outliers(float* data, int count, float* filtered, int* new_count) {
    // æ’åº
    qsort(data, count, sizeof(float), compare_float);
    
    // è®¡ç®—åˆ†ä½æ•°
    float q1 = data[count / 4];
    float q3 = data[count * 3 / 4];
    float iqr = q3 - q1;
    
    float lower = q1 - 1.5f * iqr;
    float upper = q3 + 1.5f * iqr;
    
    // è¿‡æ»¤
    *new_count = 0;
    for (int i = 0; i < count; i++) {
        if (data[i] >= lower && data[i] <= upper) {
            filtered[(*new_count)++] = data[i];
        }
    }
}
```

#### è¿ç»­æ€§æ£€æŸ¥
```c
/**
 * @brief æ£€æŸ¥ç›¸é‚»ç‚¹è·ç¦»è¿ç»­æ€§
 * 
 * å¦‚æœç›¸é‚»ç‚¹è·ç¦»å·®å¼‚ > 0.5mï¼Œå¯èƒ½æ˜¯å™ªå£°
 */
bool is_continuous(float dist1, float dist2) {
    return fabs(dist1 - dist2) < 0.5f;
}
```

#### ä¿¡å·è´¨é‡åŠ æƒ
```c
/**
 * @brief åŠ æƒå¹³å‡ï¼ˆè´¨é‡è¶Šé«˜æƒé‡è¶Šå¤§ï¼‰
 */
float weighted_average(float* distances, uint8_t* qualities, int count) {
    float sum_weight = 0.0f;
    float sum_value = 0.0f;
    
    for (int i = 0; i < count; i++) {
        float weight = qualities[i] / 127.0f;  // å½’ä¸€åŒ–åˆ°0-1
        sum_weight += weight;
        sum_value += distances[i] * weight;
    }
    
    return (sum_weight > 0) ? (sum_value / sum_weight) : 0.0f;
}
```

### 3. å¢å¼ºç»Ÿè®¡è®¡ç®—

#### ä¸­ä½æ•°
```c
float calculate_median(float* data, int count) {
    if (count == 0) return 0.0f;
    
    // æ’åºï¼ˆä½¿ç”¨å¿«é€Ÿé€‰æ‹©ç®—æ³•æ›´é«˜æ•ˆï¼‰
    qsort(data, count, sizeof(float), compare_float);
    
    if (count % 2 == 0) {
        return (data[count/2 - 1] + data[count/2]) / 2.0f;
    } else {
        return data[count/2];
    }
}
```

#### ç™¾åˆ†ä½æ•°
```c
float calculate_percentile(float* data, int count, float p) {
    if (count == 0) return 0.0f;
    
    qsort(data, count, sizeof(float), compare_float);
    
    int idx = (int)(count * p);
    if (idx >= count) idx = count - 1;
    
    return data[idx];
}
```

#### æ ‡å‡†å·®
```c
float calculate_std(float* data, int count, float mean) {
    if (count < 2) return 0.0f;
    
    float sum_sq = 0.0f;
    for (int i = 0; i < count; i++) {
        float diff = data[i] - mean;
        sum_sq += diff * diff;
    }
    
    return sqrtf(sum_sq / (count - 1));
}
```

#### ä¼—æ•°åŒºé—´
```c
/**
 * @brief è®¡ç®—ä¼—æ•°åŒºé—´ï¼ˆ10cmåˆ†è¾¨ç‡ï¼‰
 */
void calculate_mode_range(float* data, int count, float* mode_start, float* mode_end) {
    if (count == 0) {
        *mode_start = 0.0f;
        *mode_end = 0.0f;
        return;
    }
    
    // ç›´æ–¹å›¾ç»Ÿè®¡ï¼ˆ10cmåˆ†è¾¨ç‡ï¼Œ0-10mèŒƒå›´ï¼‰
    int bins[100] = {0};
    for (int i = 0; i < count; i++) {
        int bin = (int)(data[i] / 0.1f);
        if (bin >= 0 && bin < 100) {
            bins[bin]++;
        }
    }
    
    // æ‰¾æœ€å¤§é¢‘æ•°çš„åŒºé—´
    int max_bin = 0;
    for (int i = 1; i < 100; i++) {
        if (bins[i] > bins[max_bin]) {
            max_bin = i;
        }
    }
    
    *mode_start = max_bin * 0.1f;
    *mode_end = (max_bin + 1) * 0.1f;
}
```

## ğŸ¯ éšœç¢ç‰©ç­‰çº§åˆ¤æ–­

```c
typedef enum {
    OBSTACLE_CLEAR = 0,      // > 3mï¼Œç•…é€š
    OBSTACLE_FAR = 1,        // 1.5-3mï¼Œè¿œè·ç¦»
    OBSTACLE_MEDIUM = 2,     // 0.6-1.5mï¼Œä¸­è·ç¦»
    OBSTACLE_NEAR = 3,       // 0.2-0.6mï¼Œè¿‘è·ç¦»
    OBSTACLE_CRITICAL = 4    // < 0.2mï¼Œå±é™©
} ObstacleLevel_t;

ObstacleLevel_t judge_obstacle_level(float p10_dist, float median_dist) {
    // ä¼˜å…ˆè€ƒè™‘10%åˆ†ä½è·ç¦»ï¼ˆæœ€è¿‘çš„éšœç¢ï¼‰
    if (p10_dist < 0.2f) return OBSTACLE_CRITICAL;
    if (p10_dist < 0.6f) return OBSTACLE_NEAR;
    
    // å…¶æ¬¡è€ƒè™‘ä¸­ä½æ•°
    if (median_dist < 1.5f) return OBSTACLE_MEDIUM;
    if (median_dist < 3.0f) return OBSTACLE_FAR;
    
    return OBSTACLE_CLEAR;
}
```

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–

### å›ºä»¶ç«¯
- ä½¿ç”¨å›ºå®šå¤§å°ç¼“å†²åŒºé¿å…åŠ¨æ€å†…å­˜åˆ†é…
- éƒ¨åˆ†ç»Ÿè®¡é‡å¢é‡è®¡ç®—ï¼ˆmeanã€stdï¼‰
- æ’åºä½¿ç”¨å¿«é€Ÿé€‰æ‹©ç®—æ³•ï¼ˆO(n)è€ŒéO(n log n)ï¼‰

### Pythonç«¯
- ä½¿ç”¨NumPyå‘é‡åŒ–è®¡ç®—
- ç¼“å­˜æ‰‡åŒºæ˜ å°„è¡¨
- å¼‚æ­¥æ•°æ®å¤„ç†

## ğŸ§ª æµ‹è¯•éªŒè¯

### æµ‹è¯•åœºæ™¯
1. **ç©ºæ—·ç¯å¢ƒ**ï¼šæ‰€æœ‰æ‰‡åŒº > 5m
2. **å•ä¾§å¢™å£**ï¼šä¸€ä¾§0.5mï¼Œå…¶ä»–ä¾§ > 5m
3. **èµ°å»Šç¯å¢ƒ**ï¼šå·¦å³0.5mï¼Œå‰å > 2m
4. **è§’è½ç¯å¢ƒ**ï¼šä¸¤ä¾§éƒ½æœ‰è¿‘è·ç¦»éšœç¢
5. **åŠ¨æ€éšœç¢**ï¼šç§»åŠ¨ç‰©ä½“

### éªŒæ”¶æ ‡å‡†
- æ–¹å‘å‡†ç¡®ç‡ï¼š100%
- è·ç¦»ç²¾åº¦ï¼šÂ±5cmï¼ˆ< 3mèŒƒå›´ï¼‰
- å“åº”æ—¶é—´ï¼š< 100ms
- å‡é˜³æ€§ç‡ï¼š< 5%
- æ¼æ£€ç‡ï¼š< 1%

## ğŸ“‹ å®æ–½æ­¥éª¤

### é˜¶æ®µ1ï¼šå¿«é€Ÿä¿®å¤ï¼ˆ1å°æ—¶ï¼‰
- [x] ä¿®å¤æ–¹å‘å®šä¹‰é—®é¢˜
- [ ] Pythonç«¯æ·»åŠ æ‰‡åŒºæ˜ å°„è½¬æ¢
- [ ] æµ‹è¯•éªŒè¯æ–¹å‘æ­£ç¡®æ€§

### é˜¶æ®µ2ï¼šå¢å¼ºç»Ÿè®¡ï¼ˆ2å°æ—¶ï¼‰
- [ ] å›ºä»¶æ·»åŠ ä¸­ä½æ•°ã€ç™¾åˆ†ä½æ•°è®¡ç®—
- [ ] å›ºä»¶æ·»åŠ æ ‡å‡†å·®ã€ä¼—æ•°è®¡ç®—
- [ ] æ›´æ–°JSONè¾“å‡ºæ ¼å¼
- [ ] Pythonè§£ææ–°æ ¼å¼

### é˜¶æ®µ3ï¼šæ•°æ®è¿‡æ»¤ï¼ˆ2å°æ—¶ï¼‰
- [ ] å®ç°ç¦»ç¾¤å€¼æ£€æµ‹
- [ ] å®ç°è¿ç»­æ€§æ£€æŸ¥
- [ ] å®ç°è´¨é‡åŠ æƒ
- [ ] é›†æˆæµ‹è¯•

### é˜¶æ®µ4ï¼šå®Œæ•´æµ‹è¯•ï¼ˆ1å°æ—¶ï¼‰
- [ ] åˆ›å»ºæµ‹è¯•è„šæœ¬
- [ ] å¤šåœºæ™¯éªŒè¯
- [ ] æ€§èƒ½æµ‹è¯•
- [ ] æ–‡æ¡£æ›´æ–°

## ğŸ’¡ æ¨èæ–¹æ¡ˆ

### çŸ­æœŸï¼ˆè€ƒè¯•å‰ï¼‰
**ä»…ä¿®å¤æ–¹å‘å®šä¹‰ + Pythonç«¯ç®€å•ç»Ÿè®¡å¢å¼º**
- ä¼˜ç‚¹ï¼šæ”¹åŠ¨å°ã€é£é™©ä½ã€å¿«é€Ÿ
- ç¼ºç‚¹ï¼šå›ºä»¶ç«¯ä»ç„¶åªæœ‰min/avg

### é•¿æœŸï¼ˆè€ƒè¯•åï¼‰
**å®Œæ•´å®æ–½å¢å¼ºç»Ÿè®¡ + æ•°æ®è¿‡æ»¤**
- ä¼˜ç‚¹ï¼šæ€§èƒ½æœ€ä¼˜ã€æœ€å¯é 
- ç¼ºç‚¹ï¼šéœ€è¦é‡æ–°ç¼–è¯‘å›ºä»¶ã€æµ‹è¯•æ—¶é—´é•¿

## ğŸ”§ ç«‹å³å¯ç”¨çš„ä¸´æ—¶æ–¹æ¡ˆ

åœ¨Pythonç«¯å¯¹ç°æœ‰8æ‰‡åŒºæ•°æ®è¿›è¡Œå¢å¼ºå¤„ç†ï¼š

```python
import numpy as np
from scipy import stats

class EnhancedLidarProcessor:
    """å¢å¼ºçš„é›·è¾¾æ•°æ®å¤„ç†å™¨"""
    
    def __init__(self, direction_fix=True):
        self.direction_fix = direction_fix
    
    def process_sector_data(self, lidar_data):
        """å¤„ç†å¹¶å¢å¼ºæ‰‡åŒºæ•°æ®"""
        enhanced_sectors = []
        
        for sector in lidar_data.sectors:
            sector_id = sector['sector_id']
            
            # ä¿®æ­£æ–¹å‘
            if self.direction_fix:
                sector_id = (sector_id + 4) % 8  # æ—‹è½¬180åº¦
            
            # å¦‚æœæœ‰åŸå§‹ç‚¹äº‘ï¼Œè®¡ç®—å¢å¼ºç»Ÿè®¡
            if hasattr(lidar_data, 'raw_points'):
                points = self._get_sector_points(
                    lidar_data.raw_points, 
                    sector_id
                )
                stats = self._calculate_statistics(points)
            else:
                # é€€åŒ–åˆ°ç°æœ‰æ•°æ®
                stats = {
                    'median': sector['avg_dist'],
                    'p10': sector['min_dist'],
                    'p90': sector['avg_dist'],
                }
            
            enhanced_sectors.append({
                'sector_id': sector_id,
                'count': sector['count'],
                **stats
            })
        
        return enhanced_sectors
    
    def _calculate_statistics(self, distances):
        """è®¡ç®—å®Œæ•´ç»Ÿè®¡æŒ‡æ ‡"""
        if len(distances) == 0:
            return {
                'min': 15.0, 'max': 15.0, 'mean': 0.0,
                'median': 15.0, 'p10': 15.0, 'p90': 15.0,
                'std': 0.0, 'obstacle_level': 'CLEAR'
            }
        
        # ç¦»ç¾¤å€¼è¿‡æ»¤
        filtered = self._filter_outliers(distances)
        
        if len(filtered) == 0:
            filtered = distances
        
        # è®¡ç®—ç»Ÿè®¡é‡
        result = {
            'min': float(np.min(filtered)),
            'max': float(np.max(filtered)),
            'mean': float(np.mean(filtered)),
            'median': float(np.median(filtered)),
            'p10': float(np.percentile(filtered, 10)),
            'p90': float(np.percentile(filtered, 90)),
            'std': float(np.std(filtered)),
        }
        
        # åˆ¤æ–­éšœç¢ç‰©ç­‰çº§
        result['obstacle_level'] = self._judge_obstacle(
            result['p10'], 
            result['median']
        )
        
        return result
    
    def _filter_outliers(self, data):
        """IQRæ–¹æ³•è¿‡æ»¤ç¦»ç¾¤å€¼"""
        q1 = np.percentile(data, 25)
        q3 = np.percentile(data, 75)
        iqr = q3 - q1
        
        lower = q1 - 1.5 * iqr
        upper = q3 + 1.5 * iqr
        
        return data[(data >= lower) & (data <= upper)]
    
    def _judge_obstacle(self, p10, median):
        """åˆ¤æ–­éšœç¢ç‰©ç­‰çº§"""
        if p10 < 0.2:
            return 'CRITICAL'
        elif p10 < 0.6:
            return 'NEAR'
        elif median < 1.5:
            return 'MEDIUM'
        elif median < 3.0:
            return 'FAR'
        else:
            return 'CLEAR'
```

ä½¿ç”¨æ–¹æ³•ï¼š
```python
processor = EnhancedLidarProcessor(direction_fix=True)
enhanced_data = processor.process_sector_data(lidar_data)

# é¿éšœå†³ç­–
front_sector = enhanced_data[0]
if front_sector['obstacle_level'] in ['CRITICAL', 'NEAR']:
    # ç´§æ€¥è½¬å‘
    turn()
```

## ğŸ“š å‚è€ƒèµ„æ–™

- [Laser Scan Matching for Mobile Robot Localization](https://en.wikipedia.org/wiki/Lidar)
- [ROS sensor_msgs/LaserScan](http://docs.ros.org/en/api/sensor_msgs/html/msg/LaserScan.html)
- [PCL Point Cloud Library](https://pointclouds.org/)

