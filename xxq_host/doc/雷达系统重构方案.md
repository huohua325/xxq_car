# 雷达系统重构方案

## 📋 问题诊断

### 1. 方向定义错误
- **问题**：扇区0（0°）应该是正前方，但实际检测到的是后方
- **原因**：固件中扇区计算或传感器物理安装方向不对
- **影响**：导航和避障决策错误

### 2. 统计指标不足
- **当前**：只有 `min_dist` 和 `avg_dist`
- **问题**：
  - `min_dist` 容易受噪声影响（如0.10m可能是离群值）
  - `avg_dist` 在数据分布不均时不准确
  - 无法判断数据质量和可信度

### 3. 缺少数据过滤
- **问题**：没有离群值过滤、噪声抑制
- **影响**：异常值影响避障决策

## 🎯 设计目标

### 1. 避障需求
- 快速响应：< 100ms
- 可靠性：抗噪声、抗离群值
- 精确度：5cm分辨率
- 覆盖范围：360°，0.1-10m

### 2. SLAM需求
- 点云完整性：保留所有有效点
- 数据密度：每度≥1个点
- 时间同步：统一时间戳
- 角度精度：±1°

## 📊 新设计方案

### 方案A：增强8扇区统计（推荐用于避障）

#### 数据结构
```json
{
  "type": "LIDAR",
  "timestamp": 625079,
  "total_points": 66,
  "angle_coverage": 39.1,
  "sectors": [
    {
      "sector_id": 0,
      "angle_center": 0,
      "angle_range": [337.5, 22.5],
      "count": 15,
      "statistics": {
        "min": 0.50,           // 最小距离（米）
        "max": 8.20,           // 最大距离
        "mean": 3.45,          // 平均值
        "median": 2.80,        // 中位数 ⭐ 新增
        "p10": 0.85,           // 10%分位数 ⭐ 新增（很近的障碍）
        "p90": 6.50,           // 90%分位数
        "std": 1.23,           // 标准差 ⭐ 新增
        "mode_range": [2.5, 3.0],  // 众数区间 ⭐ 新增
        "density": 0.33        // 数据密度（点数/角度范围）
      },
      "quality": {
        "avg_quality": 85,     // 平均信号质量（0-127）
        "valid_ratio": 0.95,   // 有效点比例
        "outlier_count": 1     // 离群值数量
      },
      "obstacle_level": "NEAR"  // 障碍物等级：CLEAR/FAR/MEDIUM/NEAR/CRITICAL
    }
  ]
}
```

#### 关键改进
1. **中位数（median）**：对离群值不敏感，比平均值更可靠
2. **百分位数（p10/p90）**：
   - p10：最近10%的障碍物距离，用于紧急避障
   - p90：用于判断是否有远距离干扰
3. **标准差（std）**：判断数据分散程度，std大说明环境复杂
4. **众数区间（mode_range）**：最常出现的距离范围，最可靠的测量
5. **质量指标**：数据可信度评估

### 方案B：保留原始点云（用于SLAM）

#### 数据结构
```json
{
  "type": "LIDAR_CLOUD",
  "timestamp": 625079,
  "points": [
    {"angle": 0.5, "distance": 2.45, "quality": 87},
    {"angle": 1.2, "distance": 2.48, "quality": 92},
    // ... 最多360个点
  ]
}
```

### 方案C：双模式混合（推荐） ⭐

- **实时避障模式**：发送增强8扇区统计（50Hz）
- **SLAM建图模式**：发送完整点云（按需）
- **切换命令**：
  - `A` - 8扇区模式（默认）
  - `A2` - 点云模式

## 🛠️ 实现方案

### 1. 修复方向定义

#### 选项A：固件端修复（推荐）
```c
// 修改扇区计算宏，添加180度偏移
#define RADAR_GET_SECTOR(angle_deg) \
    ((int)(((angle_deg) + 180.0f + 22.5f) / 45.0f) % 8)
```

#### 选项B：Python端映射
```python
def fix_sector_direction(sector_id):
    """修正扇区方向"""
    return (sector_id + 4) % 8  # 旋转180度
```

### 2. 数据过滤算法

#### 离群值检测（固件端）
```c
/**
 * @brief 离群值检测（IQR方法）
 * 
 * 步骤：
 * 1. 计算Q1（25%分位）和Q3（75%分位）
 * 2. IQR = Q3 - Q1
 * 3. 离群值：< Q1 - 1.5*IQR 或 > Q3 + 1.5*IQR
 */
void filter_outliers(float* data, int count, float* filtered, int* new_count) {
    // 排序
    qsort(data, count, sizeof(float), compare_float);
    
    // 计算分位数
    float q1 = data[count / 4];
    float q3 = data[count * 3 / 4];
    float iqr = q3 - q1;
    
    float lower = q1 - 1.5f * iqr;
    float upper = q3 + 1.5f * iqr;
    
    // 过滤
    *new_count = 0;
    for (int i = 0; i < count; i++) {
        if (data[i] >= lower && data[i] <= upper) {
            filtered[(*new_count)++] = data[i];
        }
    }
}
```

#### 连续性检查
```c
/**
 * @brief 检查相邻点距离连续性
 * 
 * 如果相邻点距离差异 > 0.5m，可能是噪声
 */
bool is_continuous(float dist1, float dist2) {
    return fabs(dist1 - dist2) < 0.5f;
}
```

#### 信号质量加权
```c
/**
 * @brief 加权平均（质量越高权重越大）
 */
float weighted_average(float* distances, uint8_t* qualities, int count) {
    float sum_weight = 0.0f;
    float sum_value = 0.0f;
    
    for (int i = 0; i < count; i++) {
        float weight = qualities[i] / 127.0f;  // 归一化到0-1
        sum_weight += weight;
        sum_value += distances[i] * weight;
    }
    
    return (sum_weight > 0) ? (sum_value / sum_weight) : 0.0f;
}
```

### 3. 增强统计计算

#### 中位数
```c
float calculate_median(float* data, int count) {
    if (count == 0) return 0.0f;
    
    // 排序（使用快速选择算法更高效）
    qsort(data, count, sizeof(float), compare_float);
    
    if (count % 2 == 0) {
        return (data[count/2 - 1] + data[count/2]) / 2.0f;
    } else {
        return data[count/2];
    }
}
```

#### 百分位数
```c
float calculate_percentile(float* data, int count, float p) {
    if (count == 0) return 0.0f;
    
    qsort(data, count, sizeof(float), compare_float);
    
    int idx = (int)(count * p);
    if (idx >= count) idx = count - 1;
    
    return data[idx];
}
```

#### 标准差
```c
float calculate_std(float* data, int count, float mean) {
    if (count < 2) return 0.0f;
    
    float sum_sq = 0.0f;
    for (int i = 0; i < count; i++) {
        float diff = data[i] - mean;
        sum_sq += diff * diff;
    }
    
    return sqrtf(sum_sq / (count - 1));
}
```

#### 众数区间
```c
/**
 * @brief 计算众数区间（10cm分辨率）
 */
void calculate_mode_range(float* data, int count, float* mode_start, float* mode_end) {
    if (count == 0) {
        *mode_start = 0.0f;
        *mode_end = 0.0f;
        return;
    }
    
    // 直方图统计（10cm分辨率，0-10m范围）
    int bins[100] = {0};
    for (int i = 0; i < count; i++) {
        int bin = (int)(data[i] / 0.1f);
        if (bin >= 0 && bin < 100) {
            bins[bin]++;
        }
    }
    
    // 找最大频数的区间
    int max_bin = 0;
    for (int i = 1; i < 100; i++) {
        if (bins[i] > bins[max_bin]) {
            max_bin = i;
        }
    }
    
    *mode_start = max_bin * 0.1f;
    *mode_end = (max_bin + 1) * 0.1f;
}
```

## 🎯 障碍物等级判断

```c
typedef enum {
    OBSTACLE_CLEAR = 0,      // > 3m，畅通
    OBSTACLE_FAR = 1,        // 1.5-3m，远距离
    OBSTACLE_MEDIUM = 2,     // 0.6-1.5m，中距离
    OBSTACLE_NEAR = 3,       // 0.2-0.6m，近距离
    OBSTACLE_CRITICAL = 4    // < 0.2m，危险
} ObstacleLevel_t;

ObstacleLevel_t judge_obstacle_level(float p10_dist, float median_dist) {
    // 优先考虑10%分位距离（最近的障碍）
    if (p10_dist < 0.2f) return OBSTACLE_CRITICAL;
    if (p10_dist < 0.6f) return OBSTACLE_NEAR;
    
    // 其次考虑中位数
    if (median_dist < 1.5f) return OBSTACLE_MEDIUM;
    if (median_dist < 3.0f) return OBSTACLE_FAR;
    
    return OBSTACLE_CLEAR;
}
```

## 📈 性能优化

### 固件端
- 使用固定大小缓冲区避免动态内存分配
- 部分统计量增量计算（mean、std）
- 排序使用快速选择算法（O(n)而非O(n log n)）

### Python端
- 使用NumPy向量化计算
- 缓存扇区映射表
- 异步数据处理

## 🧪 测试验证

### 测试场景
1. **空旷环境**：所有扇区 > 5m
2. **单侧墙壁**：一侧0.5m，其他侧 > 5m
3. **走廊环境**：左右0.5m，前后 > 2m
4. **角落环境**：两侧都有近距离障碍
5. **动态障碍**：移动物体

### 验收标准
- 方向准确率：100%
- 距离精度：±5cm（< 3m范围）
- 响应时间：< 100ms
- 假阳性率：< 5%
- 漏检率：< 1%

## 📋 实施步骤

### 阶段1：快速修复（1小时）
- [x] 修复方向定义问题
- [ ] Python端添加扇区映射转换
- [ ] 测试验证方向正确性

### 阶段2：增强统计（2小时）
- [ ] 固件添加中位数、百分位数计算
- [ ] 固件添加标准差、众数计算
- [ ] 更新JSON输出格式
- [ ] Python解析新格式

### 阶段3：数据过滤（2小时）
- [ ] 实现离群值检测
- [ ] 实现连续性检查
- [ ] 实现质量加权
- [ ] 集成测试

### 阶段4：完整测试（1小时）
- [ ] 创建测试脚本
- [ ] 多场景验证
- [ ] 性能测试
- [ ] 文档更新

## 💡 推荐方案

### 短期（考试前）
**仅修复方向定义 + Python端简单统计增强**
- 优点：改动小、风险低、快速
- 缺点：固件端仍然只有min/avg

### 长期（考试后）
**完整实施增强统计 + 数据过滤**
- 优点：性能最优、最可靠
- 缺点：需要重新编译固件、测试时间长

## 🔧 立即可用的临时方案

在Python端对现有8扇区数据进行增强处理：

```python
import numpy as np
from scipy import stats

class EnhancedLidarProcessor:
    """增强的雷达数据处理器"""
    
    def __init__(self, direction_fix=True):
        self.direction_fix = direction_fix
    
    def process_sector_data(self, lidar_data):
        """处理并增强扇区数据"""
        enhanced_sectors = []
        
        for sector in lidar_data.sectors:
            sector_id = sector['sector_id']
            
            # 修正方向
            if self.direction_fix:
                sector_id = (sector_id + 4) % 8  # 旋转180度
            
            # 如果有原始点云，计算增强统计
            if hasattr(lidar_data, 'raw_points'):
                points = self._get_sector_points(
                    lidar_data.raw_points, 
                    sector_id
                )
                stats = self._calculate_statistics(points)
            else:
                # 退化到现有数据
                stats = {
                    'median': sector['avg_dist'],
                    'p10': sector['min_dist'],
                    'p90': sector['avg_dist'],
                }
            
            enhanced_sectors.append({
                'sector_id': sector_id,
                'count': sector['count'],
                **stats
            })
        
        return enhanced_sectors
    
    def _calculate_statistics(self, distances):
        """计算完整统计指标"""
        if len(distances) == 0:
            return {
                'min': 15.0, 'max': 15.0, 'mean': 0.0,
                'median': 15.0, 'p10': 15.0, 'p90': 15.0,
                'std': 0.0, 'obstacle_level': 'CLEAR'
            }
        
        # 离群值过滤
        filtered = self._filter_outliers(distances)
        
        if len(filtered) == 0:
            filtered = distances
        
        # 计算统计量
        result = {
            'min': float(np.min(filtered)),
            'max': float(np.max(filtered)),
            'mean': float(np.mean(filtered)),
            'median': float(np.median(filtered)),
            'p10': float(np.percentile(filtered, 10)),
            'p90': float(np.percentile(filtered, 90)),
            'std': float(np.std(filtered)),
        }
        
        # 判断障碍物等级
        result['obstacle_level'] = self._judge_obstacle(
            result['p10'], 
            result['median']
        )
        
        return result
    
    def _filter_outliers(self, data):
        """IQR方法过滤离群值"""
        q1 = np.percentile(data, 25)
        q3 = np.percentile(data, 75)
        iqr = q3 - q1
        
        lower = q1 - 1.5 * iqr
        upper = q3 + 1.5 * iqr
        
        return data[(data >= lower) & (data <= upper)]
    
    def _judge_obstacle(self, p10, median):
        """判断障碍物等级"""
        if p10 < 0.2:
            return 'CRITICAL'
        elif p10 < 0.6:
            return 'NEAR'
        elif median < 1.5:
            return 'MEDIUM'
        elif median < 3.0:
            return 'FAR'
        else:
            return 'CLEAR'
```

使用方法：
```python
processor = EnhancedLidarProcessor(direction_fix=True)
enhanced_data = processor.process_sector_data(lidar_data)

# 避障决策
front_sector = enhanced_data[0]
if front_sector['obstacle_level'] in ['CRITICAL', 'NEAR']:
    # 紧急转向
    turn()
```

## 📚 参考资料

- [Laser Scan Matching for Mobile Robot Localization](https://en.wikipedia.org/wiki/Lidar)
- [ROS sensor_msgs/LaserScan](http://docs.ros.org/en/api/sensor_msgs/html/msg/LaserScan.html)
- [PCL Point Cloud Library](https://pointclouds.org/)

