# 测试指南

## 📋 测试策略

### 开发阶段测试方案

```
阶段1: Python模块测试（无硬件）✅
  ↓
阶段2: 模拟器测试（虚拟串口）
  ↓
阶段3: 硬件联调（实际STM32）
```

---

## 🧪 阶段1：Python模块测试（当前）

### 快速验证

```bash
cd xxq_host
chmod +x scripts/quick_test.sh
./scripts/quick_test.sh
```

**验证内容：**
- ✅ 数据协议类正确导入
- ✅ 通信类结构完整
- ✅ 无语法错误

---

## 🔄 阶段2：模拟器测试

### 方式1：使用虚拟串口对（推荐）

#### 步骤1：创建虚拟串口
```bash
# 安装socat（如未安装）
sudo apt install socat

# 创建虚拟串口对
socat -d -d pty,raw,echo=0 pty,raw,echo=0
```

输出示例：
```
2025/10/09 14:30:25 socat[12345] N PTY is /dev/pts/2
2025/10/09 14:30:25 socat[12345] N PTY is /dev/pts/3
```

#### 步骤2：运行模拟器（终端1）
```bash
conda activate xxq_host
python scripts/simulate_robot.py /dev/pts/2
```

#### 步骤3：运行Python主程序（终端2）
```bash
# 修改config.py
# SERIAL_PORT = '/dev/pts/3'  # 使用另一个端口

conda activate xxq_host
python main.py
```

#### 步骤4：测试命令
在main.py中输入：
```
a - 请求雷达扫描
f - 前进 (设置速度)
s - 停止
```

**预期结果：**
- ✅ 能看到MPU数据（50Hz）
- ✅ 能看到里程计数据（50Hz）
- ✅ 发送'a'能收到雷达JSON
- ✅ 发送速度命令，模拟器能响应

---

### 方式2：回环测试（简化版）

如果没有虚拟串口，可以测试数据解析：

```python
# test_parsing.py
import sys
sys.path.insert(0, 'src')

from communication.robot_comm import RobotComm

comm = RobotComm()

# 测试MPU数据解析
comm._parse_csv("MPU,12345,0.23,-1.15,0.012,-0.035,9.815,0.23,-0.15,0.08")
assert comm.latest_mpu is not None
print(f"✓ MPU解析: roll={comm.latest_mpu.roll}°")

# 测试雷达JSON解析
json_data = '{"type":"LIDAR","timestamp":12345,"data":{"total_points":650,"angle_coverage":359.8,"sectors":[{"sector_id":0,"count":80,"min_dist":1.2,"avg_dist":2.5}]}}'
comm._parse_json(json_data)
assert comm.latest_lidar is not None
print(f"✓ 雷达解析: {comm.latest_lidar.total_points}点")

print("\n数据解析测试通过!")
```

---

## 🔌 阶段3：硬件联调

### 前提条件

**固件端：**
- [ ] 将 `doc/固件端通信代码.md` 集成到 `xxq/Core/Src/main.c`
- [ ] 编译并烧录固件
- [ ] 蓝牙模块正常工作

**Python端：**
- [x] 通信模块已完成 ✅
- [ ] 配置正确的串口

### WSL串口配置

```bash
# 1. 查看可用串口
ls /dev/tty*

# 2. 给予权限
sudo chmod 666 /dev/ttyUSB0  # 或实际串口

# 3. 添加用户到dialout组（永久）
sudo usermod -a -G dialout $USER
# 需要重新登录生效
```

### 测试步骤

#### 1. 修改配置
```python
# config.py
SERIAL_PORT = '/dev/ttyUSB0'  # WSL/Linux
# SERIAL_PORT = 'COM5'         # Windows
BAUDRATE = 115200
```

#### 2. 运行主程序
```bash
conda activate xxq_host
python main.py
```

#### 3. 验证通信

**发送命令测试：**
```
s - 停止（MODE,0）
f - 前进（SPD,1.5,1.5）
a - 雷达扫描
```

**接收数据测试：**
- 观察是否有MPU数据（50Hz）
- 观察是否有里程计数据（50Hz）
- 发送'a'后是否收到雷达JSON

#### 4. 调试工具

使用串口监听器：
```bash
# 方式1: minicom
sudo apt install minicom
minicom -D /dev/ttyUSB0 -b 115200

# 方式2: screen
screen /dev/ttyUSB0 115200

# 方式3: Python pyserial-miniterm
python -m serial.tools.miniterm /dev/ttyUSB0 115200
```

---

## ✅ 验收标准

### Week 1 完成标准

- [x] **Python模块**
  - [x] protocol.py 无语法错误 ✅
  - [x] robot_comm.py 无语法错误 ✅
  - [x] 数据类可正常实例化 ✅

- [ ] **模拟测试**（可选）
  - [ ] 虚拟串口通信正常
  - [ ] 数据解析正确
  - [ ] 指令发送正常

- [ ] **硬件联调**（Week 1结束前）
  - [ ] 实际串口连接
  - [ ] 收到MPU数据
  - [ ] 收到雷达数据
  - [ ] 指令控制有效

---

## 🐛 常见问题

### Q1: ImportError: No module named 'serial'
```bash
conda activate xxq_host
pip install pyserial
```

### Q2: Permission denied: '/dev/ttyUSB0'
```bash
sudo chmod 666 /dev/ttyUSB0
# 或永久解决
sudo usermod -a -G dialout $USER
```

### Q3: 虚拟串口创建失败
```bash
# 确保socat已安装
sudo apt install socat

# 使用完整路径
socat -d -d pty,raw,echo=0,link=/tmp/vserial1 pty,raw,echo=0,link=/tmp/vserial2
```

### Q4: 收不到数据
**检查清单：**
1. 串口是否正确？`ls /dev/tty*`
2. 波特率是否匹配？（115200）
3. 固件是否在发送数据？
4. 用minicom能看到数据吗？

---

## 📊 测试记录模板

```
测试日期: 2025-10-09
测试人员: [姓名]
测试环境: WSL Ubuntu / Windows / 虚拟串口

【Python模块测试】
□ protocol.py导入      ✅/❌
□ robot_comm.py导入    ✅/❌
□ 数据类创建          ✅/❌

【模拟器测试】
□ 虚拟串口创建        ✅/❌
□ MPU数据接收         ✅/❌
□ 雷达数据接收        ✅/❌
□ 命令发送            ✅/❌

【硬件联调】
□ 串口连接            ✅/❌
□ 实际数据接收        ✅/❌
□ 电机控制            ✅/❌

问题记录:
1. 
2. 

解决方案:
1. 
2. 
```

---

**更新日期**: 2025-10-09  
**版本**: v1.0

