# 🎯 墙跟随探索系统 - 分阶段开发计划

**项目目标**：实现从入口到出口的自主探索 + 路径回放返回  
**技术方案**：墙跟随算法 + 停顿扫描策略 + 实时SLAM建图  
**预计开发时间**：3-5天  
**成功标准**：小车能走到出口并返回起点，有完整地图展示

---

## 📋 当前硬件功能检查清单

### ✅ 已验证功能
- [x] **BLE通信**：能正常连接和发送命令
- [x] **基础运动**：前进、后退、左转、右转
- [x] **雷达扫描**：`A\n` 命令能触发扫描并返回JSON数据
- [x] **编码器数据**：ODO数据正常发送（待验证：是否周期性发送）

### 🔍 待确认功能
- [ ] **ODO数据自动发送**：是否在main()循环中自动发送？（10Hz）
- [ ] **位姿数据POSE**：是否有POSE数据发送？（可选）
- [ ] **运动参数标准化**：转向是否精确90度？前进步长是否一致？

---

## 🏗️ 开发阶段总览

```
第一阶段: 硬件端完善（0.5天）
    ↓
第二阶段: Python基础功能（1天）
    ↓
第三阶段: 墙跟随算法（1天）
    ↓
第四阶段: 实时SLAM可视化（1天）
    ↓
第五阶段: 路径回放返回（0.5天）
    ↓
第六阶段: 集成测试与优化（1天）
```

---

## 📅 第一阶段：硬件端完善（半天，4小时）

### 🎯 阶段目标
确保硬件端提供所有必要的数据支持

### 📝 任务清单

#### 任务1.1：验证ODO数据自动发送 ⭐
**检查内容**：
```c
// 在main.c的while(1)循环中是否有类似代码？
void main() {
    while(1) {
        // ... 其他代码 ...
        send_odometry_data();  // ← 是否有这个？
        // ... 其他代码 ...
    }
}
```

**如果没有**，需要添加：
```c
// main.c 中添加全局变量
uint32_t last_odo_time = 0;
#define ODO_SEND_INTERVAL 100  // 100ms = 10Hz

// main.c 中添加函数
void send_odometry_data() {
    uint32_t now = HAL_GetTick();
    if (now - last_odo_time < ODO_SEND_INTERVAL) return;
    last_odo_time = now;
    
    // 读取编码器计数
    int32_t left_count = (int32_t)TIM3->CNT;   // 左轮
    int32_t right_count = (int32_t)TIM4->CNT;  // 右轮
    
    // 计算速度
    static int32_t last_left = 0, last_right = 0;
    float dt = 0.1f;  // 100ms
    float left_rps = (left_count - last_left) / (1560.0f * dt);
    float right_rps = (right_count - last_right) / (780.0f * dt);
    
    last_left = left_count;
    last_right = right_count;
    
    // 发送ODO数据
    printf("ODO,%lu,%.2f,%.2f,%ld,%ld\n", 
           now, left_rps, right_rps, (long)left_count, (long)right_count);
}

// 在main()的while(1)中调用
while(1) {
    // ... 原有代码 ...
    
    send_odometry_data();  // 添加这行
    
    // ... 原有代码 ...
    Python_ParseCommand();
    HAL_Delay(10);
}
```

**验收标准**：
```bash
# 运行Python测试，查看是否持续收到ODO数据
python -c "
from ble_robot_control import SimpleBLERobotComm
robot = SimpleBLERobotComm('C4:25:01:20:02:8E')
robot.on_odom_update = lambda d: print(f'ODO: L={d.left_speed:.2f}, R={d.right_speed:.2f}')
robot.connect()
input('Press Enter to stop...')
robot.disconnect()
"
```

**期望结果**：每秒看到约10条ODO数据打印

---

#### 任务1.2：标定转向精度 🎯
**测试方法**：
```bash
# 1. 手动测试左转90度
python -c "
from ble_robot_control import SimpleBLERobotComm
import time
robot = SimpleBLERobotComm('C4:25:01:20:02:8E')
robot.connect()
robot.send_command('TURN,0,0.50,0.50\n')  # 左转
time.sleep(1.5)
robot.send_command('MODE,0\n')  # 停止
robot.disconnect()
"

# 观察小车是否转了接近90度
# 如果不足90度：增加时间或PWM值
# 如果超过90度：减少时间或PWM值
```

**调整参数**：
```c
// Motor.c 或 main.c 中定义标准参数
#define TURN_LEFT_LEFT_PWM   0.50f    // 左转时左轮PWM
#define TURN_LEFT_RIGHT_PWM  0.50f    // 左转时右轮PWM
#define TURN_RIGHT_LEFT_PWM  0.55f    // 右转时左轮PWM
#define TURN_RIGHT_RIGHT_PWM 0.45f    // 右转时右轮PWM
#define TURN_DURATION_MS     1000     // 转向持续时间

// 修改TURN命令处理，增加计时停止
// 在接收到TURN命令后：
if (strncmp(rx_command_buffer, "TURN,", 5) == 0) {
    // ... 解析参数 ...
    
    // 执行转向
    if (direction == 0) {
        Car_TurnLeft_Continuous(&htim1, left_pwm, right_pwm);
    } else {
        Car_TurnRight_Continuous(&htim1, left_pwm, right_pwm);
    }
    
    // 自动停止（可选）
    HAL_Delay(TURN_DURATION_MS);
    Car_Stop_PID();
}
```

**验收标准**：
- 左转90度误差 < 10度
- 右转90度误差 < 10度
- 可重复性好（连续3次转向角度接近）

---

#### 任务1.3：标定前进步长 📏
**测试方法**：
```bash
# 测试前进0.5秒的距离
python -c "
from ble_robot_control import SimpleBLERobotComm
import time
robot = SimpleBLERobotComm('C4:25:01:20:02:8E')
robot.connect()
robot.send_command('MODE,1\n')  # 前进
time.sleep(0.5)
robot.send_command('MODE,0\n')  # 停止
robot.disconnect()
"

# 用尺子测量实际前进距离
# 期望：0.15-0.20米（速度0.3-0.4 m/s）
```

**调整参数**：
```c
// main.c 中定义
#define FORWARD_STEP_TIME_MS  500   // 前进步长时间（毫秒）
#define FORWARD_SPEED_PWM     0.3f  // 前进速度（PWM占空比）
```

**验收标准**：
- 前进0.5秒距离 ≈ 15-20cm
- 速度稳定，不会突然加速或减速

---

### ✅ 第一阶段完成检查

- [ ] ODO数据每秒自动发送约10次
- [ ] 左转、右转能精确转90度（误差<10度）
- [ ] 前进步长一致（误差<2cm）
- [ ] 所有基础运动命令响应正常

**完成时间预计**：4小时

---

## 📅 第二阶段：Python基础功能（1天，6-8小时）

### 🎯 阶段目标
搭建Python端的基础架构和数据处理

### 📝 任务清单

#### 任务2.1：创建简化位姿估计器 📍
**文件**：`xxq_host/simple_pose_estimator.py`

**代码框架**：
```python
"""
简化的位姿估计器
仅使用编码器数据，不使用IMU
"""
import math

class SimplePoseEstimator:
    def __init__(self):
        """初始化位姿估计器"""
        # 当前位姿
        self.x = 0.0        # X坐标（米）
        self.y = 0.0        # Y坐标（米）
        self.theta = 0.0    # 航向角（弧度）
        
        # 历史编码器值
        self.last_left_count = 0
        self.last_right_count = 0
        
        # 机器人参数（必须与config.py一致）
        self.wheel_base = 0.20      # 轮距（米）
        self.wheel_radius = 0.033   # 轮半径（米）
        self.left_ppr = 1560        # 左轮编码器分辨率
        self.right_ppr = 780        # 右轮编码器分辨率
    
    def update(self, odo_data):
        """
        从里程计数据更新位姿
        
        Args:
            odo_data: 字典，包含 left_count, right_count
        
        Returns:
            (x, y, theta): 当前位姿
        """
        # TODO: 实现位姿更新逻辑
        pass
    
    def get_pose(self):
        """获取当前位姿"""
        return (self.x, self.y, self.theta)
    
    def reset(self, x=0.0, y=0.0, theta=0.0):
        """重置位姿"""
        self.x = x
        self.y = y
        self.theta = theta
```

**实现步骤**：
1. 实现 `update()` 方法（参考最简化通过考试方案.md中的代码）
2. 测试位姿估计精度（与实际位置对比）

**验收标准**：
```python
# 测试代码
estimator = SimplePoseEstimator()

# 模拟前进1米
for i in range(10):
    estimator.update({'left_count': 1560*i, 'right_count': 780*i})
    print(f"位姿: {estimator.get_pose()}")

# 期望最终位姿接近 (1.0, 0.0, 0.0)
```

---

#### 任务2.2：创建雷达数据包装器 📡
**文件**：`xxq_host/simple_lidar.py`

**代码框架**：
```python
"""
雷达数据包装器
简化雷达数据访问
"""

class SimpleLidarWrapper:
    def __init__(self, robot):
        """
        Args:
            robot: SimpleBLERobotComm实例
        """
        self.robot = robot
        self.latest_scan = None
        
        # 注册回调
        self.robot.on_lidar_update = self._on_lidar_callback
    
    def _on_lidar_callback(self, lidar_data):
        """雷达数据回调"""
        # 转换为简化格式
        self.latest_scan = self._convert_sectors_to_points(lidar_data)
    
    def _convert_sectors_to_points(self, lidar_data):
        """
        将扇区数据转换为点集
        
        Returns:
            list: [{"angle": 0, "distance": 1.2}, ...]
        """
        points = []
        for sector in lidar_data.sectors:
            angle = sector.get('angle_center', 0)
            min_dist = sector.get('min_dist', 0)
            avg_dist = sector.get('avg_dist', 0)
            count = sector.get('count', 0)
            
            if count > 0 and min_dist > 0:
                points.append({
                    'angle': angle,
                    'distance': min_dist,  # 使用最小距离（保守）
                    'avg_distance': avg_dist
                })
        
        return points
    
    def request_scan(self, timeout=3.0):
        """
        请求雷达扫描并等待结果
        
        Args:
            timeout: 超时时间（秒）
        
        Returns:
            list: 扫描点集，或None如果超时
        """
        import time
        
        self.latest_scan = None
        self.robot.send_command('A\n')
        
        start_time = time.time()
        while self.latest_scan is None:
            if time.time() - start_time > timeout:
                return None
            time.sleep(0.1)
        
        return self.latest_scan
    
    def get_distance_at_angle(self, target_angle, tolerance=15):
        """
        获取指定角度的距离
        
        Args:
            target_angle: 目标角度（度，0=正前方，270=右侧）
            tolerance: 角度容差（度）
        
        Returns:
            float: 距离（米），如果无数据返回999.0
        """
        if not self.latest_scan:
            return 999.0
        
        distances = [
            p['distance'] for p in self.latest_scan
            if abs(p['angle'] - target_angle) < tolerance
        ]
        
        return min(distances) if distances else 999.0
```

**验收标准**：
```python
# 测试代码
from ble_robot_control import SimpleBLERobotComm
from simple_lidar import SimpleLidarWrapper

robot = SimpleBLERobotComm('C4:25:01:20:02:8E')
robot.connect()

lidar = SimpleLidarWrapper(robot)
scan = lidar.request_scan()

if scan:
    print(f"扫描点数: {len(scan)}")
    print(f"正前方距离: {lidar.get_distance_at_angle(0):.2f}m")
    print(f"右侧距离: {lidar.get_distance_at_angle(270):.2f}m")
else:
    print("扫描失败")

robot.disconnect()
```

---

#### 任务2.3：创建运动控制包装器 🚗
**文件**：`xxq_host/simple_motion.py`

**代码框架**：
```python
"""
运动控制包装器
标准化运动命令
"""
import time

class SimpleMotionController:
    def __init__(self, robot):
        self.robot = robot
        
        # 标准化运动参数
        self.forward_time = 0.5      # 前进步长时间（秒）
        self.turn_time = 1.0         # 转向时间（秒）
        self.settle_time = 0.1       # 稳定时间（秒）
    
    def stop(self):
        """停止"""
        self.robot.send_command('MODE,0\n')
        time.sleep(self.settle_time)
    
    def forward(self, duration=None):
        """
        前进一步
        
        Args:
            duration: 持续时间（秒），None使用默认值
        """
        self.robot.send_command('MODE,1\n')
        time.sleep(duration or self.forward_time)
        self.stop()
    
    def turn_left(self):
        """左转90度"""
        self.robot.send_command('TURN,0,0.50,0.50\n')
        time.sleep(self.turn_time)
        self.stop()
    
    def turn_right(self):
        """右转90度"""
        self.robot.send_command('TURN,1,0.55,0.45\n')
        time.sleep(self.turn_time)
        self.stop()
```

**验收标准**：
```python
# 测试代码 - 执行一个"回"字形路线
from ble_robot_control import SimpleBLERobotComm
from simple_motion import SimpleMotionController

robot = SimpleBLERobotComm('C4:25:01:20:02:8E')
robot.connect()

motion = SimpleMotionController(robot)

# 回字形
for i in range(4):
    motion.forward()
    motion.turn_right()

robot.disconnect()
```

---

### ✅ 第二阶段完成检查

- [ ] `SimplePoseEstimator` 类能正确估计位姿
- [ ] `SimpleLidarWrapper` 能请求扫描并获取距离
- [ ] `SimpleMotionController` 能执行标准化运动
- [ ] 测试代码能正常运行

**完成时间预计**：6-8小时

---

## 📅 第三阶段：墙跟随算法（1天，6-8小时）

### 🎯 阶段目标
实现墙跟随决策逻辑

### 📝 任务清单

#### 任务3.1：实现墙跟随决策器 🧠
**文件**：`xxq_host/simple_wall_follower.py`

**完整代码**：
```python
"""
墙跟随算法（右手法则）
保持右侧贴墙行走
"""

class WallFollower:
    def __init__(self, wall_distance=0.4):
        """
        Args:
            wall_distance: 期望与墙的距离（米）
        """
        self.wall_distance = wall_distance
        
        # 决策参数
        self.front_threshold = 0.3   # 前方障碍物阈值（米）
        self.right_threshold = 0.6   # 右侧空旷阈值（米）
    
    def decide(self, lidar_wrapper):
        """
        根据雷达数据决策下一步动作
        
        Args:
            lidar_wrapper: SimpleLidarWrapper实例
        
        Returns:
            str: 'forward', 'turn_left', 'turn_right', 'stop'
        """
        # 获取关键方向距离
        front = lidar_wrapper.get_distance_at_angle(0)      # 正前方
        right = lidar_wrapper.get_distance_at_angle(270)    # 右侧
        left = lidar_wrapper.get_distance_at_angle(90)      # 左侧
        
        print(f"  [决策] 前={front:.2f}m, 右={right:.2f}m, 左={left:.2f}m")
        
        # 右手法则决策
        if front < self.front_threshold:
            # 前方有障碍 → 左转
            print(f"  → 决策: 左转（前方障碍物 {front:.2f}m < {self.front_threshold}m）")
            return 'turn_left'
        
        elif right > self.right_threshold:
            # 右侧空旷 → 右转（贴墙）
            print(f"  → 决策: 右转（右侧空旷 {right:.2f}m > {self.right_threshold}m）")
            return 'turn_right'
        
        else:
            # 直走
            print(f"  → 决策: 前进")
            return 'forward'
```

**验收标准**：
```python
# 单元测试
from simple_wall_follower import WallFollower
from simple_lidar import SimpleLidarWrapper

# 模拟雷达数据
class MockLidar:
    def __init__(self, front, right, left):
        self.front = front
        self.right = right
        self.left = left
    
    def get_distance_at_angle(self, angle):
        if angle == 0:
            return self.front
        elif angle == 270:
            return self.right
        elif angle == 90:
            return self.left

follower = WallFollower()

# 测试场景1：前方有障碍
mock = MockLidar(front=0.2, right=0.4, left=1.0)
assert follower.decide(mock) == 'turn_left'

# 测试场景2：右侧空旷
mock = MockLidar(front=2.0, right=0.8, left=1.0)
assert follower.decide(mock) == 'turn_right'

# 测试场景3：正常前进
mock = MockLidar(front=1.0, right=0.4, left=1.0)
assert follower.decide(mock) == 'forward'

print("✅ 墙跟随决策器测试通过")
```

---

#### 任务3.2：实现探索主循环 🔄
**文件**：`xxq_host/simple_explorer.py`

**代码框架**：
```python
"""
探索主循环
集成墙跟随、位姿估计、雷达扫描
"""
import time
from simple_wall_follower import WallFollower
from simple_pose_estimator import SimplePoseEstimator
from simple_lidar import SimpleLidarWrapper
from simple_motion import SimpleMotionController

class SimpleExplorer:
    def __init__(self, robot):
        """
        Args:
            robot: SimpleBLERobotComm实例
        """
        self.robot = robot
        
        # 组件
        self.wall_follower = WallFollower()
        self.pose_estimator = SimplePoseEstimator()
        self.lidar = SimpleLidarWrapper(robot)
        self.motion = SimpleMotionController(robot)
        
        # 数据记录
        self.path_history = []  # 记录路径
        self.step_count = 0
        
        # 探索参数
        self.max_steps = 100    # 最大步数
        self.scan_time = 0.8    # 雷达扫描时间
    
    def explore_step(self):
        """
        执行一步探索
        
        Returns:
            bool: True=继续探索, False=到达出口
        """
        self.step_count += 1
        print(f"\n{'='*60}")
        print(f"第 {self.step_count} 步探索")
        print(f"{'='*60}")
        
        # 1. 停止并扫描
        print("⏹️  停止运动")
        self.motion.stop()
        
        print("🔄 雷达扫描中...")
        scan = self.lidar.request_scan(timeout=3.0)
        
        if not scan:
            print("⚠️  扫描失败，跳过本步")
            return True
        
        # 2. 更新位姿（TODO: 从robot获取ODO数据）
        # current_pose = self.pose_estimator.update(odo_data)
        current_pose = self.pose_estimator.get_pose()
        print(f"📍 当前位姿: ({current_pose[0]:.2f}, {current_pose[1]:.2f}, {current_pose[2]:.2f}rad)")
        
        # 3. 墙跟随决策
        action = self.wall_follower.decide(self.lidar)
        
        # 4. 执行动作
        if action == 'forward':
            self.motion.forward()
        elif action == 'turn_left':
            self.motion.turn_left()
        elif action == 'turn_right':
            self.motion.turn_right()
        
        # 5. 记录路径
        self.path_history.append({
            'step': self.step_count,
            'pose': current_pose,
            'action': action,
            'scan': scan
        })
        
        # 6. 检测出口（简化：固定步数）
        if self.step_count >= self.max_steps:
            print("\n🎉 达到最大步数，视为找到出口")
            return False
        
        return True
    
    def run_exploration(self):
        """运行完整探索"""
        print("\n🚀 开始墙跟随探索")
        print("="*60)
        
        try:
            while self.explore_step():
                time.sleep(0.5)  # 短暂停顿
            
            print("\n✅ 探索完成！")
            print(f"总步数: {self.step_count}")
            print(f"路径点数: {len(self.path_history)}")
            
        except KeyboardInterrupt:
            print("\n⏹️  手动停止探索")
        finally:
            self.motion.stop()
```

**验收标准**：
```python
# 测试代码
from ble_robot_control import SimpleBLERobotComm
from simple_explorer import SimpleExplorer

robot = SimpleBLERobotComm('C4:25:01:20:02:8E')
robot.connect()

explorer = SimpleExplorer(robot)
explorer.max_steps = 10  # 测试时只走10步

explorer.run_exploration()

robot.disconnect()

# 期望：小车能沿着墙壁走10步
```

---

### ✅ 第三阶段完成检查

- [ ] 墙跟随决策器单元测试通过
- [ ] 探索主循环能正常运行
- [ ] 小车能沿墙行走（即使不完美）
- [ ] 路径数据被正确记录

**完成时间预计**：6-8小时

---

## 📅 第四阶段：实时SLAM可视化（1天，6-8小时）

**说明**：这个阶段的代码已经在最简化通过考试方案.md中提供完整实现，这里简化为集成任务。

### 📝 任务清单

#### 任务4.1：复制SLAM可视化代码
**文件**：`xxq_host/real_time_slam_visualizer.py`

**操作**：
1. 从最简化通过考试方案.md复制 `RealTimeSLAMVisualizer` 类代码
2. 测试可视化界面是否能正常显示

---

#### 任务4.2：集成到探索循环
**修改**：`simple_explorer.py`

**添加代码**：
```python
from real_time_slam_visualizer import RealTimeSLAMVisualizer

class SimpleExplorer:
    def __init__(self, robot):
        # ... 原有代码 ...
        
        # 添加可视化
        self.slam_viz = RealTimeSLAMVisualizer(
            width=8.0, height=8.0, resolution=0.05
        )
    
    def explore_step(self):
        # ... 原有代码 ...
        
        # 在执行动作后添加可视化更新
        self.slam_viz.update_map(
            current_pose[0], current_pose[1], current_pose[2], scan
        )
```

**验收标准**：运行探索时能看到实时更新的地图界面

---

### ✅ 第四阶段完成检查

- [ ] SLAM可视化界面能正常显示
- [ ] 探索过程中地图实时更新
- [ ] 能看到机器人轨迹和雷达扫描
- [ ] 地图能保存为图片

**完成时间预计**：6-8小时

---

## 📅 第五阶段：路径回放返回（半天，4小时）

### 📝 任务清单

#### 任务5.1：实现路径回放
**文件**：`simple_explorer.py` 添加方法

**代码**：
```python
class SimpleExplorer:
    # ... 原有代码 ...
    
    def return_to_start(self):
        """路径回放返回起点"""
        print("\n🏠 开始返回起点")
        print("="*60)
        
        if not self.path_history:
            print("❌ 无路径数据")
            return
        
        # 路径倒序（每5步取一个航点）
        waypoints = list(reversed(self.path_history[::5]))
        
        print(f"📍 计划路径: {len(waypoints)} 个航点")
        
        for i, record in enumerate(waypoints):
            print(f"\n🧭 航点 {i+1}/{len(waypoints)}")
            
            target_pose = record['pose']
            action = record['action']
            
            # 简单策略：执行反向动作
            if action == 'forward':
                self.motion.forward()  # 继续前进
            elif action == 'turn_left':
                self.motion.turn_right()  # 左转的反向是右转
            elif action == 'turn_right':
                self.motion.turn_left()  # 右转的反向是左转
            
            time.sleep(0.5)
        
        print("\n🏁 返回完成！")
```

**验收标准**：小车能沿原路返回（允许误差）

---

### ✅ 第五阶段完成检查

- [ ] 路径回放功能能运行
- [ ] 小车大致能返回起点附近
- [ ] 无严重撞墙或偏离

**完成时间预计**：4小时

---

## 📅 第六阶段：集成测试与优化（1天）

### 📝 任务清单

#### 任务6.1：端到端测试
**测试脚本**：`test_complete_exploration.py`

```python
"""完整探索测试"""
from ble_robot_control import SimpleBLERobotComm
from simple_explorer import SimpleExplorer

robot = SimpleBLERobotComm('C4:25:01:20:02:8E')
robot.connect()

explorer = SimpleExplorer(robot)
explorer.max_steps = 30  # 探索30步

# 阶段1: 探索
explorer.run_exploration()

input("\n⏸️  探索完成，按Enter开始返回...")

# 阶段2: 返回
explorer.return_to_start()

# 保存地图
explorer.slam_viz.save_final_map("final_map.png")

robot.disconnect()
```

---

#### 任务6.2：参数调优
**需要调整的参数**：
- 墙跟随阈值（front_threshold, right_threshold）
- 运动时间（forward_time, turn_time）
- 转向PWM值

**调优方法**：
1. 观察小车行为
2. 记录问题（如撞墙、偏离）
3. 调整参数
4. 重复测试

---

### ✅ 第六阶段完成检查

- [ ] 端到端测试通过
- [ ] 小车能稳定沿墙行走
- [ ] 能生成清晰的地图
- [ ] 返回功能基本可用

**完成时间预计**：8小时

---

## 🎯 最终验收标准

### 必须达到（保底）
- [x] 小车能从起点探索一段距离
- [x] 能生成地图（即使不完美）
- [x] 能返回起点附近（允许误差）
- [x] 有实时可视化界面

### 理想达到（加分）
- [ ] 探索路径较优（少撞墙）
- [ ] 地图清晰展示障碍物
- [ ] 返回精度高（误差<0.5米）
- [ ] 可视化界面美观

---

## 📊 开发进度追踪

### 当前状态
- [x] 硬件功能验证完成
- [ ] 第一阶段：硬件端完善
- [ ] 第二阶段：Python基础功能
- [ ] 第三阶段：墙跟随算法
- [ ] 第四阶段：实时SLAM可视化
- [ ] 第五阶段：路径回放返回
- [ ] 第六阶段：集成测试与优化

### 每日检查
**Day 1**：
- [ ] 完成第一阶段
- [ ] 开始第二阶段

**Day 2**：
- [ ] 完成第二阶段
- [ ] 完成第三阶段

**Day 3**：
- [ ] 完成第四阶段
- [ ] 开始第五阶段

**Day 4**：
- [ ] 完成第五阶段
- [ ] 开始第六阶段

**Day 5**：
- [ ] 完成第六阶段
- [ ] 准备演示

---

## 💡 开发建议

### 调试技巧
1. **分步测试**：每完成一个小功能就测试
2. **打印日志**：关键步骤都打印信息
3. **录制视频**：记录测试过程，方便回放分析
4. **参数记录**：每次调整参数都记录下来

### 常见问题
1. **小车不停转圈**：检查转向参数，可能需要降低转向时间
2. **雷达数据不稳定**：增加扫描时间，确保数据完整
3. **位姿估计漂移**：这是正常的，简化方案允许一定误差
4. **返回不准确**：可以用更多航点，增加路径密度

---

## 🚀 立即开始

**第一步**：验证当前硬件状态
```bash
# 运行测试
python test_complete_motion.py
python test_lidar.py
```

**第二步**：确认需要添加的硬件功能
- 查看main.c是否有ODO自动发送

**第三步**：开始第一阶段开发
- 按照任务清单逐项完成

**准备好了吗？让我们开始吧！** 🎯

