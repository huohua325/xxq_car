---
description: SLAM algorithms and navigation algorithms implementation details
---

# 核心算法实现规范

本规则提供xxq_host项目中核心算法的实现细节和最佳实践。

## 1. 占据栅格SLAM

### 算法原理
使用 **Log-odds贝叶斯更新** 算法构建占据栅格地图。

### 实现文件
- [occupancy_map.py](mdc:xxq_host/src/slam/occupancy_map.py)

### 关键参数
```python
from config import (
    MAP_WIDTH,           # 栅格数量（X方向）
    MAP_HEIGHT,          # 栅格数量（Y方向）
    MAP_RESOLUTION,      # 米/栅格
    MAP_PROB_OCCUPIED,   # 检测到障碍物的概率（0.9）
    MAP_PROB_FREE,       # 射线路径空闲的概率（0.3）
)
```

### 核心公式
```python
# Log-odds表示
def prob_to_logodds(prob):
    return np.log(prob / (1 - prob))

def logodds_to_prob(logodds):
    return 1 - 1 / (1 + np.exp(logodds))

# 贝叶斯更新
logodds_map[cell] += logodds_occupied  # 检测到障碍物
logodds_map[cell] += logodds_free      # 射线路径空闲
```

### 坐标系统
- **世界坐标**: (x, y) 米，原点在地图中心
- **栅格坐标**: (grid_x, grid_y) 整数，(0,0)在左上角

```python
def world_to_grid(self, x: float, y: float) -> Tuple[int, int]:
    """世界坐标 → 栅格坐标"""
    grid_x = int((x / self.resolution) + self.origin_x)
    grid_y = int((-y / self.resolution) + self.origin_y)
    return grid_x, grid_y
```

### 性能优化
- 使用NumPy向量化操作更新地图
- 使用Bresenham算法高效绘制射线
- 限制地图更新范围避免全图扫描

---

## 2. Frontier前沿探索

### 算法原理
1. **前沿检测**: 找到空闲栅格与未知栅格的边界
2. **DBSCAN聚类**: 将相邻前沿点聚成簇
3. **前沿选择**: 根据策略选择最优前沿

### 实现文件
- [frontier_detector.py](mdc:xxq_host/src/slam/frontier_detector.py)

### 前沿定义
一个栅格是前沿点，当且仅当：
1. 该栅格是空闲的（占据概率 < 0.3）
2. 至少有一个8邻域栅格是未知的（占据概率 ≈ 0.5）

```python
def is_frontier(self, grid_x: int, grid_y: int) -> bool:
    """检查栅格是否为前沿点"""
    # 1. 当前栅格必须是空闲的
    if self.map.get_cell(grid_x, grid_y) > MAP_FREE_THRESHOLD:
        return False
    
    # 2. 至少有一个未知邻域
    for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
        nx, ny = grid_x + dx, grid_y + dy
        if self.map.is_unknown(nx, ny):
            return True
    
    return False
```

### DBSCAN聚类参数
```python
from sklearn.cluster import DBSCAN
from config import FRONTIER_CLUSTER_DIST, MIN_FRONTIER_SIZE

dbscan = DBSCAN(eps=FRONTIER_CLUSTER_DIST, min_samples=MIN_FRONTIER_SIZE)
```

### 前沿选择策略
```python
from config import FRONTIER_SELECTION

if FRONTIER_SELECTION == 'nearest':
    # 选择距离机器人最近的前沿
    target = min(frontiers, key=lambda f: distance(robot_pose, f))

elif FRONTIER_SELECTION == 'largest':
    # 选择点数最多的前沿簇
    target = max(frontiers, key=lambda f: f.size)

elif FRONTIER_SELECTION == 'information_gain':
    # 选择信息增益最大的前沿
    target = max(frontiers, key=lambda f: score(f, robot_pose))
```

---

## 3. A*路径规划

### 算法原理
经典A*算法，启发式函数使用欧几里得距离。

### 实现文件
- [path_planner.py](mdc:xxq_host/src/navigation/path_planner.py)

### 代价函数
```python
def heuristic(node, goal):
    """A*启发式函数（欧几里得距离）"""
    return np.sqrt((node[0] - goal[0])**2 + (node[1] - goal[1])**2)

# 总代价 = 已走代价 + 启发式
f_score = g_score + heuristic(current, goal)
```

### 对角线移动
```python
from config import PATH_ALLOW_DIAGONAL, PATH_DIAGONAL_COST

if PATH_ALLOW_DIAGONAL:
    # 8邻域（包括对角线）
    neighbors = [(0,1), (1,0), (0,-1), (-1,0),
                 (1,1), (1,-1), (-1,1), (-1,-1)]
    
    # 对角线代价为√2
    cost = PATH_DIAGONAL_COST if abs(dx) + abs(dy) == 2 else 1.0
else:
    # 4邻域（仅上下左右）
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    cost = 1.0
```

### 障碍物膨胀
为确保安全，膨胀障碍物边界：

```python
from config import PATH_INFLATION_RADIUS

def inflate_obstacles(self):
    """膨胀障碍物边界"""
    from scipy.ndimage import binary_dilation
    
    obstacle_map = self.grid > PATH_OBSTACLE_THRESHOLD
    inflated = binary_dilation(obstacle_map, 
                               iterations=PATH_INFLATION_RADIUS)
    return inflated
```

### 路径平滑（Douglas-Peucker算法）
```python
from config import PATH_SMOOTHING_TOLERANCE

def smooth_path(self, path: List[Tuple[float, float]]) -> List[Tuple[float, float]]:
    """使用Douglas-Peucker算法简化路径"""
    from rdp import rdp  # Ramer-Douglas-Peucker
    
    return rdp(path, epsilon=PATH_SMOOTHING_TOLERANCE)
```

---

## 4. DWA动态窗口避障

### 算法原理
在动态窗口内采样速度，选择评价最优的速度组合。

### 实现文件
- [dwa.py](mdc:xxq_host/src/navigation/dwa.py)
- 详细文档: [DWA动态窗口避障算法详解.md](mdc:xxq_host/doc/description/DWA动态窗口避障算法详解.md)

### 动态窗口计算
```python
from config import (
    DWA_MAX_SPEED, DWA_MAX_YAW_RATE,
    DWA_MAX_ACCEL, DWA_MAX_YAW_ACCEL,
    DWA_DT
)

def calculate_dynamic_window(current_v, current_w):
    """计算动态窗口"""
    # 机器人能力约束
    v_min, v_max = 0, DWA_MAX_SPEED
    w_min, w_max = -DWA_MAX_YAW_RATE, DWA_MAX_YAW_RATE
    
    # 加速度约束
    v_min = max(v_min, current_v - DWA_MAX_ACCEL * DWA_DT)
    v_max = min(v_max, current_v + DWA_MAX_ACCEL * DWA_DT)
    w_min = max(w_min, current_w - DWA_MAX_YAW_ACCEL * DWA_DT)
    w_max = min(w_max, current_w + DWA_MAX_YAW_ACCEL * DWA_DT)
    
    return v_min, v_max, w_min, w_max
```

### 轨迹预测
```python
from config import DWA_PREDICT_TIME, DWA_DT

def predict_trajectory(x, y, theta, v, w):
    """预测机器人轨迹"""
    trajectory = []
    for t in np.arange(0, DWA_PREDICT_TIME, DWA_DT):
        x += v * np.cos(theta) * DWA_DT
        y += v * np.sin(theta) * DWA_DT
        theta += w * DWA_DT
        trajectory.append((x, y))
    return trajectory
```

### 评价函数
```python
from config import (
    DWA_WEIGHT_HEADING,
    DWA_WEIGHT_CLEARANCE,
    DWA_WEIGHT_VELOCITY
)

def evaluate_trajectory(trajectory, goal, obstacles):
    """评价轨迹优劣"""
    # 1. 朝向得分（朝向目标越准越好）
    heading_score = calculate_heading_score(trajectory, goal)
    
    # 2. 障碍物距离得分（离障碍物越远越好）
    clearance_score = calculate_clearance_score(trajectory, obstacles)
    
    # 3. 速度得分（速度越快越好）
    velocity_score = v / DWA_MAX_SPEED
    
    # 加权求和
    total_score = (DWA_WEIGHT_HEADING * heading_score +
                   DWA_WEIGHT_CLEARANCE * clearance_score +
                   DWA_WEIGHT_VELOCITY * velocity_score)
    
    return total_score
```

### 碰撞检测
```python
from config import DWA_OBSTACLE_RADIUS, DWA_MIN_CLEARANCE

def is_collision(trajectory, obstacles):
    """检查轨迹是否与障碍物碰撞"""
    for point in trajectory:
        for obs in obstacles:
            dist = np.linalg.norm(np.array(point) - np.array(obs))
            if dist < DWA_OBSTACLE_RADIUS + DWA_MIN_CLEARANCE:
                return True
    return False
```

---

## 5. 差分驱动运动学

### 实现位置
- **STM32端**: [xxq/Core/Src/hardware/differential_drive.c](mdc:xxq/Core/Src/hardware/differential_drive.c)
- **Python端**: [xxq_host/src/navigation/controller.py](mdc:xxq_host/src/navigation/controller.py)

### 正向运动学
从轮速计算机器人速度：

```python
from config import WHEEL_BASE, WHEEL_RADIUS

def forward_kinematics(left_rps: float, right_rps: float) -> Tuple[float, float]:
    """
    正向运动学：轮速 → 机器人速度
    
    Args:
        left_rps: 左轮转速（转/秒）
        right_rps: 右轮转速（转/秒）
    
    Returns:
        v: 线速度（m/s）
        w: 角速度（rad/s）
    """
    # 轮速转换为线速度
    v_left = left_rps * 2 * np.pi * WHEEL_RADIUS
    v_right = right_rps * 2 * np.pi * WHEEL_RADIUS
    
    # 计算机器人速度
    v = (v_left + v_right) / 2.0
    w = (v_right - v_left) / WHEEL_BASE
    
    return v, w
```

### 逆向运动学
从目标速度计算轮速：

```python
def inverse_kinematics(v: float, w: float) -> Tuple[float, float]:
    """
    逆向运动学：机器人速度 → 轮速
    
    Args:
        v: 线速度（m/s）
        w: 角速度（rad/s）
    
    Returns:
        left_rps: 左轮转速（转/秒）
        right_rps: 右轮转速（转/秒）
    """
    # 计算轮子线速度
    v_left = v - (w * WHEEL_BASE / 2.0)
    v_right = v + (w * WHEEL_BASE / 2.0)
    
    # 转换为转速
    left_rps = v_left / (2 * np.pi * WHEEL_RADIUS)
    right_rps = v_right / (2 * np.pi * WHEEL_RADIUS)
    
    return left_rps, right_rps
```

### 位姿更新（里程计）
```python
def update_pose(x, y, theta, left_rps, right_rps, dt):
    """
    使用里程计更新位姿
    
    Args:
        x, y, theta: 当前位姿
        left_rps, right_rps: 左右轮转速（转/秒）
        dt: 时间间隔（秒）
    
    Returns:
        new_x, new_y, new_theta: 更新后的位姿
    """
    v, w = forward_kinematics(left_rps, right_rps)
    
    # 位姿更新
    theta += w * dt
    x += v * np.cos(theta) * dt
    y += v * np.sin(theta) * dt
    
    return x, y, theta
```

---

## 6. 位姿估计（传感器融合）

### STM32端卡尔曼滤波
在固件端融合里程计和IMU数据。

### 参数配置
```python
from config import (
    POSE_PROCESS_NOISE_POS,       # 位置过程噪声
    POSE_PROCESS_NOISE_THETA,     # 角度过程噪声
    POSE_MEASUREMENT_NOISE_THETA  # IMU测量噪声
)
```

### Python端使用
```python
# Python端直接使用STM32计算的位姿
pose_data = comm.read_pose()
x, y, theta = pose_data['x'], pose_data['y'], pose_data['theta']
```

---

## 算法性能指标

| 算法 | 目标性能 | 实际性能 |
|-----|---------|---------|
| 地图更新 | <50ms | ~30ms ✅ |
| 前沿检测 | <100ms | ~80ms ✅ |
| A*路径规划 | <500ms | ~300ms ✅ |
| DWA避障 | <100ms | ~60ms ✅ |
| 可视化 | 30fps | 30-60fps ✅ |

---

## 参考文献

### SLAM
- Thrun, S., Burgard, W., & Fox, D. (2005). *Probabilistic Robotics*

### Frontier探索
- Yamauchi, B. (1997). "A frontier-based approach for autonomous exploration"

### A*路径规划
- Hart, P. E., Nilsson, N. J., & Raphael, B. (1968). "A Formal Basis for the Heuristic Determination of Minimum Cost Paths"

### DWA避障
- Fox, D., Burgard, W., & Thrun, S. (1997). "The dynamic window approach to collision avoidance"

### 详细文档
- [DWA动态窗口避障算法详解.md](mdc:xxq_host/doc/description/DWA动态窗口避障算法详解.md)
- [POSE实现完成报告.md](mdc:xxq_host/doc/description/POSE实现完成报告.md)
- [Controller控制器详细解析.md](mdc:xxq_host/doc/description/Controller控制器详细解析.md)
